(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var h = require("virtual-dom/h"), diff = require("virtual-dom/diff"), patch = require("virtual-dom/patch"), createElement = require("virtual-dom/create-element"), markdownit = require("markdown-it"), h2h = require("html2hscript"), md = markdownit({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(lang, code).value;
                    } catch (e) {}
                }
                return "";
            }
        });
        function Item(page) {
            return {
                page: page,
                init: function() {
                    this.id = this.page.id || -1;
                    this.title = this.page.title || "";
                    this.text = this.page.text || "";
                    this.references = this.page.references || [];
                    this.category = this.page.category || [];
                    this.originalTitle = this.page.title || "";
                    this.originalText = this.page.text || "";
                    this.contentType = this.page.contentType || "Content";
                    this.listItemType = this.page.listItemType || "";
                    this.timestamp = this.page.timestamp || null;
                    return this;
                },
                update: function(data) {
                    for (var label in data) {
                        if (this.hasOwnProperty(label)) {
                            this[label] = data[label];
                        }
                    }
                    return this;
                }
            };
        }
        function pageSetup(rootNode) {
            try {
                var wrapperTmp = document.getElementById("wrapper");
                wrapperTmp.parentNode.replaceChild(rootNode, wrapperTmp);
            } catch (e) {
                try {
                    wrapperTmp = document.getElementById("content");
                    wrapperTmp.style.display = "none";
                    wrapperTmp.parentNode.appendChild(rootNode);
                } catch (err) {
                    document.body.appendChild(rootNode);
                }
            }
            try {
                var leftNav = document.getElementById("leftnav");
                leftNav.parentNode.removeChild(leftNav);
            } catch (e) {}
        }
        var item = new Item({
            id: 2,
            originalTitle: "Title",
            originalText: "Text",
            references: [ "AFI48-123", "AFI44-170" ],
            timestamp: Date.now() || new Date(),
            category: "/fhm/pha".split("/"),
            contentType: "Content",
            text: "Text",
            title: "Title",
            listItemType: "DP.Speshul"
        });
        var dirtyDOM, rootNode, refresh, patches;
        item.init();
        h2h(md.render("# " + item.title + "\n" + item.text), function(err, hscript) {
            "use strict";
            console.log(hscript);
            dirtyDOM = render(hscript);
            console.log(dirtyDOM);
            rootNode = createElement(dirtyDOM);
            pageSetup(rootNode);
        });
        function render(content) {
            console.log(createElement(new Function("h('div', ['We out'])")));
            return h("#wrapper", [ h("#content.fullPage", [ h("#buttons"), h("#contentWrap", [ h("#output"), content ]) ]) ]);
        }
        function flushDOM(content) {
            "use strict";
            h2h(md.render("# " + content.title + "YES???\n" + content.text), function(err, hscript) {
                console.log(hscript);
                refresh = render(hscript);
                console.log(refresh);
                patches = diff(dirtyDOM, refresh);
                rootNode = patch(rootNode, patches);
                dirtyDOM = refresh;
            });
        }
        flushDOM(item);
    }, {
        html2hscript: 27,
        "markdown-it": 62,
        "virtual-dom/create-element": 127,
        "virtual-dom/diff": 128,
        "virtual-dom/h": 129,
        "virtual-dom/patch": 137
    } ],
    2: [ function(require, module, exports) {}, {} ],
    3: [ function(require, module, exports) {
        var base64 = require("base64-js");
        var ieee754 = require("ieee754");
        var isArray = require("is-array");
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        var rootParent = {};
        Buffer.TYPED_ARRAY_SUPPORT = function() {
            function Foo() {}
            try {
                var buf = new ArrayBuffer(0);
                var arr = new Uint8Array(buf);
                arr.foo = function() {
                    return 42;
                };
                arr.constructor = Foo;
                return arr.foo() === 42 && arr.constructor === Foo && typeof arr.subarray === "function" && new Uint8Array(1).subarray(1, 1).byteLength === 0;
            } catch (e) {
                return false;
            }
        }();
        function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function Buffer(arg) {
            if (!(this instanceof Buffer)) {
                if (arguments.length > 1) return new Buffer(arg, arguments[1]);
                return new Buffer(arg);
            }
            this.length = 0;
            this.parent = undefined;
            if (typeof arg === "number") {
                return fromNumber(this, arg);
            }
            if (typeof arg === "string") {
                return fromString(this, arg, arguments.length > 1 ? arguments[1] : "utf8");
            }
            return fromObject(this, arg);
        }
        function fromNumber(that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < length; i++) {
                    that[i] = 0;
                }
            }
            return that;
        }
        function fromString(that, string, encoding) {
            if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
            var length = byteLength(string, encoding) | 0;
            that = allocate(that, length);
            that.write(string, encoding);
            return that;
        }
        function fromObject(that, object) {
            if (Buffer.isBuffer(object)) return fromBuffer(that, object);
            if (isArray(object)) return fromArray(that, object);
            if (object == null) {
                throw new TypeError("must start with number, buffer, array or string");
            }
            if (typeof ArrayBuffer !== "undefined" && object.buffer instanceof ArrayBuffer) {
                return fromTypedArray(that, object);
            }
            if (object.length) return fromArrayLike(that, object);
            return fromJsonObject(that, object);
        }
        function fromBuffer(that, buffer) {
            var length = checked(buffer.length) | 0;
            that = allocate(that, length);
            buffer.copy(that, 0, 0, length);
            return that;
        }
        function fromArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
            }
            return that;
        }
        function fromTypedArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
            }
            return that;
        }
        function fromArrayLike(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
            }
            return that;
        }
        function fromJsonObject(that, object) {
            var array;
            var length = 0;
            if (object.type === "Buffer" && isArray(object.data)) {
                array = object.data;
                length = checked(array.length) | 0;
            }
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
            }
            return that;
        }
        function allocate(that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = Buffer._augment(new Uint8Array(length));
            } else {
                that.length = length;
                that._isBuffer = true;
            }
            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
            if (fromPool) that.parent = rootParent;
            return that;
        }
        function checked(length) {
            if (length >= kMaxLength()) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
            }
            return length | 0;
        }
        function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
        }
        Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
        };
        Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError("Arguments must be Buffers");
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            var i = 0;
            var len = Math.min(x, y);
            while (i < len) {
                if (a[i] !== b[i]) break;
                ++i;
            }
            if (i !== len) {
                x = a[i];
                y = b[i];
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;

              default:
                return false;
            }
        };
        Buffer.concat = function concat(list, length) {
            if (!isArray(list)) throw new TypeError("list argument must be an Array of Buffers.");
            if (list.length === 0) {
                return new Buffer(0);
            } else if (list.length === 1) {
                return list[0];
            }
            var i;
            if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; i++) {
                    length += list[i].length;
                }
            }
            var buf = new Buffer(length);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
                var item = list[i];
                item.copy(buf, pos);
                pos += item.length;
            }
            return buf;
        };
        function byteLength(string, encoding) {
            if (typeof string !== "string") string = "" + string;
            var len = string.length;
            if (len === 0) return 0;
            var loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "binary":
                  case "raw":
                  case "raws":
                    return len;

                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;

                  case "hex":
                    return len >>> 1;

                  case "base64":
                    return base64ToBytes(string).length;

                  default:
                    if (loweredCase) return utf8ToBytes(string).length;
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.byteLength = byteLength;
        Buffer.prototype.length = undefined;
        Buffer.prototype.parent = undefined;
        function slowToString(encoding, start, end) {
            var loweredCase = false;
            start = start | 0;
            end = end === undefined || end === Infinity ? this.length : end | 0;
            if (!encoding) encoding = "utf8";
            if (start < 0) start = 0;
            if (end > this.length) end = this.length;
            if (end <= start) return "";
            while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "binary":
                    return binarySlice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
        };
        Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
                str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                if (this.length > max) str += " ... ";
            }
            return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return 0;
            return Buffer.compare(this, b);
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 2147483647) byteOffset = 2147483647; else if (byteOffset < -2147483648) byteOffset = -2147483648;
            byteOffset >>= 0;
            if (this.length === 0) return -1;
            if (byteOffset >= this.length) return -1;
            if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === "string") {
                if (val.length === 0) return -1;
                return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
                return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === "number") {
                if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
                    return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
                }
                return arrayIndexOf(this, [ val ], byteOffset);
            }
            function arrayIndexOf(arr, val, byteOffset) {
                var foundIndex = -1;
                for (var i = 0; byteOffset + i < arr.length; i++) {
                    if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                        if (foundIndex === -1) foundIndex = i;
                        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
                    } else {
                        foundIndex = -1;
                    }
                }
                return -1;
            }
            throw new TypeError("val must be string, number or Buffer");
        };
        Buffer.prototype.get = function get(offset) {
            console.log(".get() is deprecated. Access using array indexes instead.");
            return this.readUInt8(offset);
        };
        Buffer.prototype.set = function set(v, offset) {
            console.log(".set() is deprecated. Access using array indexes instead.");
            return this.writeUInt8(v, offset);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0) throw new Error("Invalid hex string");
            if (length > strLen / 2) {
                length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) throw new Error("Invalid hex string");
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
            } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
            } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                    length = length | 0;
                    if (encoding === undefined) encoding = "utf8";
                } else {
                    encoding = length;
                    length = undefined;
                }
            } else {
                var swap = encoding;
                encoding = offset;
                offset = length | 0;
                length = swap;
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("attempt to write outside buffer bounds");
            }
            if (!encoding) encoding = "utf8";
            var loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                    return asciiWrite(this, string, offset, length);

                  case "binary":
                    return binaryWrite(this, string, offset, length);

                  case "base64":
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        };
        Buffer.prototype.toJSON = function toJSON() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
            } else {
                return base64.fromByteArray(buf.slice(start, end));
            }
        }
        function utf8Slice(buf, start, end) {
            var res = "";
            var tmp = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                if (buf[i] <= 127) {
                    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                    tmp = "";
                } else {
                    tmp += "%" + buf[i].toString(16);
                }
            }
            return res + decodeUtf8Char(tmp);
        }
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
        }
        function binarySlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i]);
            }
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for (var i = start; i < end; i++) {
                out += toHex(buf[i]);
            }
            return out;
        }
        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) {
                start = len;
            }
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) {
                end = len;
            }
            if (end < start) end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = Buffer._augment(this.subarray(start, end));
            } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start];
                }
            }
            if (newBuf.length) newBuf.parent = this.parent || this;
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
                val += this[offset + --byteLength] * mul;
            }
            return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError("buffer must be a Buffer instance");
            if (value > max || value < min) throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length) throw new RangeError("index out of range");
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value;
            return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value;
            return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min) throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length) throw new RangeError("index out of range");
            if (offset < 0) throw new RangeError("index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
            }
            var len = end - start;
            if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < len; i++) {
                    target[i + targetStart] = this[i + start];
                }
            } else {
                target._set(this.subarray(start, start + len), targetStart);
            }
            return len;
        };
        Buffer.prototype.fill = function fill(value, start, end) {
            if (!value) value = 0;
            if (!start) start = 0;
            if (!end) end = this.length;
            if (end < start) throw new RangeError("end < start");
            if (end === start) return;
            if (this.length === 0) return;
            if (start < 0 || start >= this.length) throw new RangeError("start out of bounds");
            if (end < 0 || end > this.length) throw new RangeError("end out of bounds");
            var i;
            if (typeof value === "number") {
                for (i = start; i < end; i++) {
                    this[i] = value;
                }
            } else {
                var bytes = utf8ToBytes(value.toString());
                var len = bytes.length;
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len];
                }
            }
            return this;
        };
        Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
            if (typeof Uint8Array !== "undefined") {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    return new Buffer(this).buffer;
                } else {
                    var buf = new Uint8Array(this.length);
                    for (var i = 0, len = buf.length; i < len; i += 1) {
                        buf[i] = this[i];
                    }
                    return buf.buffer;
                }
            } else {
                throw new TypeError("Buffer.toArrayBuffer not supported in this browser");
            }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function _augment(arr) {
            arr.constructor = Buffer;
            arr._isBuffer = true;
            arr._set = arr.set;
            arr.get = BP.get;
            arr.set = BP.set;
            arr.write = BP.write;
            arr.toString = BP.toString;
            arr.toLocaleString = BP.toString;
            arr.toJSON = BP.toJSON;
            arr.equals = BP.equals;
            arr.compare = BP.compare;
            arr.indexOf = BP.indexOf;
            arr.copy = BP.copy;
            arr.slice = BP.slice;
            arr.readUIntLE = BP.readUIntLE;
            arr.readUIntBE = BP.readUIntBE;
            arr.readUInt8 = BP.readUInt8;
            arr.readUInt16LE = BP.readUInt16LE;
            arr.readUInt16BE = BP.readUInt16BE;
            arr.readUInt32LE = BP.readUInt32LE;
            arr.readUInt32BE = BP.readUInt32BE;
            arr.readIntLE = BP.readIntLE;
            arr.readIntBE = BP.readIntBE;
            arr.readInt8 = BP.readInt8;
            arr.readInt16LE = BP.readInt16LE;
            arr.readInt16BE = BP.readInt16BE;
            arr.readInt32LE = BP.readInt32LE;
            arr.readInt32BE = BP.readInt32BE;
            arr.readFloatLE = BP.readFloatLE;
            arr.readFloatBE = BP.readFloatBE;
            arr.readDoubleLE = BP.readDoubleLE;
            arr.readDoubleBE = BP.readDoubleBE;
            arr.writeUInt8 = BP.writeUInt8;
            arr.writeUIntLE = BP.writeUIntLE;
            arr.writeUIntBE = BP.writeUIntBE;
            arr.writeUInt16LE = BP.writeUInt16LE;
            arr.writeUInt16BE = BP.writeUInt16BE;
            arr.writeUInt32LE = BP.writeUInt32LE;
            arr.writeUInt32BE = BP.writeUInt32BE;
            arr.writeIntLE = BP.writeIntLE;
            arr.writeIntBE = BP.writeIntBE;
            arr.writeInt8 = BP.writeInt8;
            arr.writeInt16LE = BP.writeInt16LE;
            arr.writeInt16BE = BP.writeInt16BE;
            arr.writeInt32LE = BP.writeInt32LE;
            arr.writeInt32BE = BP.writeInt32BE;
            arr.writeFloatLE = BP.writeFloatLE;
            arr.writeFloatBE = BP.writeFloatBE;
            arr.writeDoubleLE = BP.writeDoubleLE;
            arr.writeDoubleBE = BP.writeDoubleBE;
            arr.fill = BP.fill;
            arr.inspect = BP.inspect;
            arr.toArrayBuffer = BP.toArrayBuffer;
            return arr;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;
        function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) {
                str = str + "=";
            }
            return str;
        }
        function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex(n) {
            if (n < 16) return "0" + n.toString(16);
            return n.toString(16);
        }
        function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            var i = 0;
            for (;i < length; i++) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (leadSurrogate) {
                        if (codePoint < 56320) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            leadSurrogate = codePoint;
                            continue;
                        } else {
                            codePoint = leadSurrogate - 55296 << 10 | codePoint - 56320 | 65536;
                            leadSurrogate = null;
                        }
                    } else {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else {
                            leadSurrogate = codePoint;
                            continue;
                        }
                    }
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    leadSurrogate = null;
                }
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 2097152) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                    throw new Error("Invalid code point");
                }
            }
            return bytes;
        }
        function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
                byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
            }
            return i;
        }
        function decodeUtf8Char(str) {
            try {
                return decodeURIComponent(str);
            } catch (err) {
                return String.fromCharCode(65533);
            }
        }
    }, {
        "base64-js": 4,
        ieee754: 5,
        "is-array": 6
    } ],
    4: [ function(require, module, exports) {
        var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        (function(exports) {
            "use strict";
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var PLUS = "+".charCodeAt(0);
            var SLASH = "/".charCodeAt(0);
            var NUMBER = "0".charCodeAt(0);
            var LOWER = "a".charCodeAt(0);
            var UPPER = "A".charCodeAt(0);
            var PLUS_URL_SAFE = "-".charCodeAt(0);
            var SLASH_URL_SAFE = "_".charCodeAt(0);
            function decode(elt) {
                var code = elt.charCodeAt(0);
                if (code === PLUS || code === PLUS_URL_SAFE) return 62;
                if (code === SLASH || code === SLASH_URL_SAFE) return 63;
                if (code < NUMBER) return -1;
                if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
                if (code < UPPER + 26) return code - UPPER;
                if (code < LOWER + 26) return code - LOWER + 26;
            }
            function b64ToByteArray(b64) {
                var i, j, l, tmp, placeHolders, arr;
                if (b64.length % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var len = b64.length;
                placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
                arr = new Arr(b64.length * 3 / 4 - placeHolders);
                l = placeHolders > 0 ? b64.length - 4 : b64.length;
                var L = 0;
                function push(v) {
                    arr[L++] = v;
                }
                for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                    push((tmp & 16711680) >> 16);
                    push((tmp & 65280) >> 8);
                    push(tmp & 255);
                }
                if (placeHolders === 2) {
                    tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                    push(tmp & 255);
                } else if (placeHolders === 1) {
                    tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                    push(tmp >> 8 & 255);
                    push(tmp & 255);
                }
                return arr;
            }
            function uint8ToBase64(uint8) {
                var i, extraBytes = uint8.length % 3, output = "", temp, length;
                function encode(num) {
                    return lookup.charAt(num);
                }
                function tripletToBase64(num) {
                    return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
                }
                for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                    output += tripletToBase64(temp);
                }
                switch (extraBytes) {
                  case 1:
                    temp = uint8[uint8.length - 1];
                    output += encode(temp >> 2);
                    output += encode(temp << 4 & 63);
                    output += "==";
                    break;

                  case 2:
                    temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                    output += encode(temp >> 10);
                    output += encode(temp >> 4 & 63);
                    output += encode(temp << 2 & 63);
                    output += "=";
                    break;
                }
                return output;
            }
            exports.toByteArray = b64ToByteArray;
            exports.fromByteArray = uint8ToBase64;
        })(typeof exports === "undefined" ? this.base64js = {} : exports);
    }, {} ],
    5: [ function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
            e = e << mLen | m;
            eLen += mLen;
            for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
            buffer[offset + i - d] |= s * 128;
        };
    }, {} ],
    6: [ function(require, module, exports) {
        var isArray = Array.isArray;
        var str = Object.prototype.toString;
        module.exports = isArray || function(val) {
            return !!val && "[object Array]" == str.call(val);
        };
    }, {} ],
    7: [ function(require, module, exports) {
        function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        EventEmitter.defaultMaxListeners = 10;
        EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
            this._maxListeners = n;
            return this;
        };
        EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === "error") {
                if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                    er = arguments[1];
                    if (er instanceof Error) {
                        throw er;
                    }
                    throw TypeError('Uncaught, unspecified "error" event.');
                }
            }
            handler = this._events[type];
            if (isUndefined(handler)) return false;
            if (isFunction(handler)) {
                switch (arguments.length) {
                  case 1:
                    handler.call(this);
                    break;

                  case 2:
                    handler.call(this, arguments[1]);
                    break;

                  case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;

                  default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                    handler.apply(this, args);
                }
            } else if (isObject(handler)) {
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                listeners = handler.slice();
                len = listeners.length;
                for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }
            return true;
        };
        EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
            if (!this._events[type]) this._events[type] = listener; else if (isObject(this._events[type])) this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
            if (isObject(this._events[type]) && !this._events[type].warned) {
                var m;
                if (!isUndefined(this._maxListeners)) {
                    m = this._maxListeners;
                } else {
                    m = EventEmitter.defaultMaxListeners;
                }
                if (m && m > 0 && this._events[type].length > m) {
                    this._events[type].warned = true;
                    console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                    if (typeof console.trace === "function") {
                        console.trace();
                    }
                }
            }
            return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            var fired = false;
            function g() {
                this.removeListener(type, g);
                if (!fired) {
                    fired = true;
                    listener.apply(this, arguments);
                }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
        };
        EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
                delete this._events[type];
                if (this._events.removeListener) this.emit("removeListener", type, listener);
            } else if (isObject(list)) {
                for (i = length; i-- > 0; ) {
                    if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                        position = i;
                        break;
                    }
                }
                if (position < 0) return this;
                if (list.length === 1) {
                    list.length = 0;
                    delete this._events[type];
                } else {
                    list.splice(position, 1);
                }
                if (this._events.removeListener) this.emit("removeListener", type, listener);
            }
            return this;
        };
        EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
                if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type];
                return this;
            }
            if (arguments.length === 0) {
                for (key in this._events) {
                    if (key === "removeListener") continue;
                    this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = {};
                return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
                this.removeListener(type, listeners);
            } else {
                while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
        };
        EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [ this._events[type] ]; else ret = this._events[type].slice();
            return ret;
        };
        EventEmitter.listenerCount = function(emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type]) ret = 0; else if (isFunction(emitter._events[type])) ret = 1; else ret = emitter._events[type].length;
            return ret;
        };
        function isFunction(arg) {
            return typeof arg === "function";
        }
        function isNumber(arg) {
            return typeof arg === "number";
        }
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        function isUndefined(arg) {
            return arg === void 0;
        }
    }, {} ],
    8: [ function(require, module, exports) {
        if (typeof Object.create === "function") {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            };
        }
    }, {} ],
    9: [ function(require, module, exports) {
        module.exports = Array.isArray || function(arr) {
            return Object.prototype.toString.call(arr) == "[object Array]";
        };
    }, {} ],
    10: [ function(require, module, exports) {
        var process = module.exports = {};
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = setTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    currentQueue[queueIndex].run();
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            clearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                setTimeout(drainQueue, 0);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    11: [ function(require, module, exports) {
        (function(global) {
            (function(root) {
                var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                var freeModule = typeof module == "object" && module && !module.nodeType && module;
                var freeGlobal = typeof global == "object" && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                function error(type) {
                    throw RangeError(errors[type]);
                }
                function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }
                function mapDomain(string, fn) {
                    var parts = string.split("@");
                    var result = "";
                    if (parts.length > 1) {
                        result = parts[0] + "@";
                        string = parts[1];
                    }
                    string = string.replace(regexSeparators, ".");
                    var labels = string.split(".");
                    var encoded = map(labels, fn).join(".");
                    return result + encoded;
                }
                function ucs2decode(string) {
                    var output = [], counter = 0, length = string.length, value, extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 55296 && value <= 56319 && counter < length) {
                            extra = string.charCodeAt(counter++);
                            if ((extra & 64512) == 56320) {
                                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                            } else {
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }
                function ucs2encode(array) {
                    return map(array, function(value) {
                        var output = "";
                        if (value > 65535) {
                            value -= 65536;
                            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                            value = 56320 | value & 1023;
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join("");
                }
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }
                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }
                    for (j = 0; j < basic; ++j) {
                        if (input.charCodeAt(j) >= 128) {
                            error("not-basic");
                        }
                        output.push(input.charCodeAt(j));
                    }
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                        for (oldi = i, w = 1, k = base; ;k += base) {
                            if (index >= inputLength) {
                                error("invalid-input");
                            }
                            digit = basicToDigit(input.charCodeAt(index++));
                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error("overflow");
                            }
                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (digit < t) {
                                break;
                            }
                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error("overflow");
                            }
                            w *= baseMinusT;
                        }
                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);
                        if (floor(i / out) > maxInt - n) {
                            error("overflow");
                        }
                        n += floor(i / out);
                        i %= out;
                        output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                    input = ucs2decode(input);
                    inputLength = input.length;
                    n = initialN;
                    delta = 0;
                    bias = initialBias;
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 128) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }
                    handledCPCount = basicLength = output.length;
                    if (basicLength) {
                        output.push(delimiter);
                    }
                    while (handledCPCount < inputLength) {
                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error("overflow");
                        }
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < n && ++delta > maxInt) {
                                error("overflow");
                            }
                            if (currentValue == n) {
                                for (q = delta, k = base; ;k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join("");
                }
                function toUnicode(input) {
                    return mapDomain(input, function(string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }
                function toASCII(input) {
                    return mapDomain(input, function(string) {
                        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                    });
                }
                punycode = {
                    version: "1.3.2",
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: toASCII,
                    toUnicode: toUnicode
                };
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    define("punycode", function() {
                        return punycode;
                    });
                } else if (freeExports && freeModule) {
                    if (module.exports == freeExports) {
                        freeModule.exports = punycode;
                    } else {
                        for (key in punycode) {
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                        }
                    }
                } else {
                    root.punycode = punycode;
                }
            })(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    12: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js");
    }, {
        "./lib/_stream_duplex.js": 13
    } ],
    13: [ function(require, module, exports) {
        (function(process) {
            module.exports = Duplex;
            var objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) keys.push(key);
                return keys;
            };
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var Readable = require("./_stream_readable");
            var Writable = require("./_stream_writable");
            util.inherits(Duplex, Readable);
            forEach(objectKeys(Writable.prototype), function(method) {
                if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
            });
            function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                if (options && options.readable === false) this.readable = false;
                if (options && options.writable === false) this.writable = false;
                this.allowHalfOpen = true;
                if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
                this.once("end", onend);
            }
            function onend() {
                if (this.allowHalfOpen || this._writableState.ended) return;
                process.nextTick(this.end.bind(this));
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
        }).call(this, require("_process"));
    }, {
        "./_stream_readable": 15,
        "./_stream_writable": 17,
        _process: 10,
        "core-util-is": 18,
        inherits: 8
    } ],
    14: [ function(require, module, exports) {
        module.exports = PassThrough;
        var Transform = require("./_stream_transform");
        var util = require("core-util-is");
        util.inherits = require("inherits");
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);
            Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
            cb(null, chunk);
        };
    }, {
        "./_stream_transform": 16,
        "core-util-is": 18,
        inherits: 8
    } ],
    15: [ function(require, module, exports) {
        (function(process) {
            module.exports = Readable;
            var isArray = require("isarray");
            var Buffer = require("buffer").Buffer;
            Readable.ReadableState = ReadableState;
            var EE = require("events").EventEmitter;
            if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
                return emitter.listeners(type).length;
            };
            var Stream = require("stream");
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var StringDecoder;
            var debug = require("util");
            if (debug && debug.debuglog) {
                debug = debug.debuglog("stream");
            } else {
                debug = function() {};
            }
            util.inherits(Readable, Stream);
            function ReadableState(options, stream) {
                var Duplex = require("./_stream_duplex");
                options = options || {};
                var hwm = options.highWaterMark;
                var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                this.highWaterMark = ~~this.highWaterMark;
                this.buffer = [];
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.objectMode = !!options.objectMode;
                if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.ranOut = false;
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                    if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                }
            }
            function Readable(options) {
                var Duplex = require("./_stream_duplex");
                if (!(this instanceof Readable)) return new Readable(options);
                this._readableState = new ReadableState(options, this);
                this.readable = true;
                Stream.call(this);
            }
            Readable.prototype.push = function(chunk, encoding) {
                var state = this._readableState;
                if (util.isString(chunk) && !state.objectMode) {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = new Buffer(chunk, encoding);
                        encoding = "";
                    }
                }
                return readableAddChunk(this, state, chunk, encoding, false);
            };
            Readable.prototype.unshift = function(chunk) {
                var state = this._readableState;
                return readableAddChunk(this, state, chunk, "", true);
            };
            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                var er = chunkInvalid(state, chunk);
                if (er) {
                    stream.emit("error", er);
                } else if (util.isNullOrUndefined(chunk)) {
                    state.reading = false;
                    if (!state.ended) onEofChunk(stream, state);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (state.ended && !addToFront) {
                        var e = new Error("stream.push() after EOF");
                        stream.emit("error", e);
                    } else if (state.endEmitted && addToFront) {
                        var e = new Error("stream.unshift() after end event");
                        stream.emit("error", e);
                    } else {
                        if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
                        if (!addToFront) state.reading = false;
                        if (state.flowing && state.length === 0 && !state.sync) {
                            stream.emit("data", chunk);
                            stream.read(0);
                        } else {
                            state.length += state.objectMode ? 1 : chunk.length;
                            if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
                            if (state.needReadable) emitReadable(stream);
                        }
                        maybeReadMore(stream, state);
                    }
                } else if (!addToFront) {
                    state.reading = false;
                }
                return needMoreData(state);
            }
            function needMoreData(state) {
                return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.setEncoding = function(enc) {
                if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
                return this;
            };
            var MAX_HWM = 8388608;
            function roundUpToNextPowerOf2(n) {
                if (n >= MAX_HWM) {
                    n = MAX_HWM;
                } else {
                    n--;
                    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                    n++;
                }
                return n;
            }
            function howMuchToRead(n, state) {
                if (state.length === 0 && state.ended) return 0;
                if (state.objectMode) return n === 0 ? 0 : 1;
                if (isNaN(n) || util.isNull(n)) {
                    if (state.flowing && state.buffer.length) return state.buffer[0].length; else return state.length;
                }
                if (n <= 0) return 0;
                if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);
                if (n > state.length) {
                    if (!state.ended) {
                        state.needReadable = true;
                        return 0;
                    } else return state.length;
                }
                return n;
            }
            Readable.prototype.read = function(n) {
                debug("read", n);
                var state = this._readableState;
                var nOrig = n;
                if (!util.isNumber(n) || n > 0) state.emittedReadable = false;
                if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                    debug("read: emitReadable", state.length, state.ended);
                    if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
                    return null;
                }
                n = howMuchToRead(n, state);
                if (n === 0 && state.ended) {
                    if (state.length === 0) endReadable(this);
                    return null;
                }
                var doRead = state.needReadable;
                debug("need readable", doRead);
                if (state.length === 0 || state.length - n < state.highWaterMark) {
                    doRead = true;
                    debug("length less than watermark", doRead);
                }
                if (state.ended || state.reading) {
                    doRead = false;
                    debug("reading or ended", doRead);
                }
                if (doRead) {
                    debug("do read");
                    state.reading = true;
                    state.sync = true;
                    if (state.length === 0) state.needReadable = true;
                    this._read(state.highWaterMark);
                    state.sync = false;
                }
                if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
                var ret;
                if (n > 0) ret = fromList(n, state); else ret = null;
                if (util.isNull(ret)) {
                    state.needReadable = true;
                    n = 0;
                }
                state.length -= n;
                if (state.length === 0 && !state.ended) state.needReadable = true;
                if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
                if (!util.isNull(ret)) this.emit("data", ret);
                return ret;
            };
            function chunkInvalid(state, chunk) {
                var er = null;
                if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
                    er = new TypeError("Invalid non-string/buffer chunk");
                }
                return er;
            }
            function onEofChunk(stream, state) {
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                        state.buffer.push(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                    }
                }
                state.ended = true;
                emitReadable(stream);
            }
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = false;
                if (!state.emittedReadable) {
                    debug("emitReadable", state.flowing);
                    state.emittedReadable = true;
                    if (state.sync) process.nextTick(function() {
                        emitReadable_(stream);
                    }); else emitReadable_(stream);
                }
            }
            function emitReadable_(stream) {
                debug("emit readable");
                stream.emit("readable");
                flow(stream);
            }
            function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(function() {
                        maybeReadMore_(stream, state);
                    });
                }
            }
            function maybeReadMore_(stream, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                    debug("maybeReadMore read 0");
                    stream.read(0);
                    if (len === state.length) break; else len = state.length;
                }
                state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
                this.emit("error", new Error("not implemented"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;

                  case 1:
                    state.pipes = [ state.pipes, dest ];
                    break;

                  default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : cleanup;
                if (state.endEmitted) process.nextTick(endFn); else src.once("end", endFn);
                dest.on("unpipe", onunpipe);
                function onunpipe(readable) {
                    debug("onunpipe");
                    if (readable === src) {
                        cleanup();
                    }
                }
                function onend() {
                    debug("onend");
                    dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on("drain", ondrain);
                function cleanup() {
                    debug("cleanup");
                    dest.removeListener("close", onclose);
                    dest.removeListener("finish", onfinish);
                    dest.removeListener("drain", ondrain);
                    dest.removeListener("error", onerror);
                    dest.removeListener("unpipe", onunpipe);
                    src.removeListener("end", onend);
                    src.removeListener("end", cleanup);
                    src.removeListener("data", ondata);
                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                }
                src.on("data", ondata);
                function ondata(chunk) {
                    debug("ondata");
                    var ret = dest.write(chunk);
                    if (false === ret) {
                        debug("false write response, pause", src._readableState.awaitDrain);
                        src._readableState.awaitDrain++;
                        src.pause();
                    }
                }
                function onerror(er) {
                    debug("onerror", er);
                    unpipe();
                    dest.removeListener("error", onerror);
                    if (EE.listenerCount(dest, "error") === 0) dest.emit("error", er);
                }
                if (!dest._events || !dest._events.error) dest.on("error", onerror); else if (isArray(dest._events.error)) dest._events.error.unshift(onerror); else dest._events.error = [ onerror, dest._events.error ];
                function onclose() {
                    dest.removeListener("finish", onfinish);
                    unpipe();
                }
                dest.once("close", onclose);
                function onfinish() {
                    debug("onfinish");
                    dest.removeListener("close", onclose);
                    unpipe();
                }
                dest.once("finish", onfinish);
                function unpipe() {
                    debug("unpipe");
                    src.unpipe(dest);
                }
                dest.emit("pipe", src);
                if (!state.flowing) {
                    debug("pipe resume");
                    src.resume();
                }
                return dest;
            };
            function pipeOnDrain(src) {
                return function() {
                    var state = src._readableState;
                    debug("pipeOnDrain", state.awaitDrain);
                    if (state.awaitDrain) state.awaitDrain--;
                    if (state.awaitDrain === 0 && EE.listenerCount(src, "data")) {
                        state.flowing = true;
                        flow(src);
                    }
                };
            }
            Readable.prototype.unpipe = function(dest) {
                var state = this._readableState;
                if (state.pipesCount === 0) return this;
                if (state.pipesCount === 1) {
                    if (dest && dest !== state.pipes) return this;
                    if (!dest) dest = state.pipes;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    if (dest) dest.emit("unpipe", this);
                    return this;
                }
                if (!dest) {
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    for (var i = 0; i < len; i++) dests[i].emit("unpipe", this);
                    return this;
                }
                var i = indexOf(state.pipes, dest);
                if (i === -1) return this;
                state.pipes.splice(i, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];
                dest.emit("unpipe", this);
                return this;
            };
            Readable.prototype.on = function(ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                if (ev === "data" && false !== this._readableState.flowing) {
                    this.resume();
                }
                if (ev === "readable" && this.readable) {
                    var state = this._readableState;
                    if (!state.readableListening) {
                        state.readableListening = true;
                        state.emittedReadable = false;
                        state.needReadable = true;
                        if (!state.reading) {
                            var self = this;
                            process.nextTick(function() {
                                debug("readable nexttick read 0");
                                self.read(0);
                            });
                        } else if (state.length) {
                            emitReadable(this, state);
                        }
                    }
                }
                return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.resume = function() {
                var state = this._readableState;
                if (!state.flowing) {
                    debug("resume");
                    state.flowing = true;
                    if (!state.reading) {
                        debug("resume read 0");
                        this.read(0);
                    }
                    resume(this, state);
                }
                return this;
            };
            function resume(stream, state) {
                if (!state.resumeScheduled) {
                    state.resumeScheduled = true;
                    process.nextTick(function() {
                        resume_(stream, state);
                    });
                }
            }
            function resume_(stream, state) {
                state.resumeScheduled = false;
                stream.emit("resume");
                flow(stream);
                if (state.flowing && !state.reading) stream.read(0);
            }
            Readable.prototype.pause = function() {
                debug("call pause flowing=%j", this._readableState.flowing);
                if (false !== this._readableState.flowing) {
                    debug("pause");
                    this._readableState.flowing = false;
                    this.emit("pause");
                }
                return this;
            };
            function flow(stream) {
                var state = stream._readableState;
                debug("flow", state.flowing);
                if (state.flowing) {
                    do {
                        var chunk = stream.read();
                    } while (null !== chunk && state.flowing);
                }
            }
            Readable.prototype.wrap = function(stream) {
                var state = this._readableState;
                var paused = false;
                var self = this;
                stream.on("end", function() {
                    debug("wrapped end");
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length) self.push(chunk);
                    }
                    self.push(null);
                });
                stream.on("data", function(chunk) {
                    debug("wrapped data");
                    if (state.decoder) chunk = state.decoder.write(chunk);
                    if (!chunk || !state.objectMode && !chunk.length) return;
                    var ret = self.push(chunk);
                    if (!ret) {
                        paused = true;
                        stream.pause();
                    }
                });
                for (var i in stream) {
                    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
                        this[i] = function(method) {
                            return function() {
                                return stream[method].apply(stream, arguments);
                            };
                        }(i);
                    }
                }
                var events = [ "error", "close", "destroy", "pause", "resume" ];
                forEach(events, function(ev) {
                    stream.on(ev, self.emit.bind(self, ev));
                });
                self._read = function(n) {
                    debug("wrapped _read", n);
                    if (paused) {
                        paused = false;
                        stream.resume();
                    }
                };
                return self;
            };
            Readable._fromList = fromList;
            function fromList(n, state) {
                var list = state.buffer;
                var length = state.length;
                var stringMode = !!state.decoder;
                var objectMode = !!state.objectMode;
                var ret;
                if (list.length === 0) return null;
                if (length === 0) ret = null; else if (objectMode) ret = list.shift(); else if (!n || n >= length) {
                    if (stringMode) ret = list.join(""); else ret = Buffer.concat(list, length);
                    list.length = 0;
                } else {
                    if (n < list[0].length) {
                        var buf = list[0];
                        ret = buf.slice(0, n);
                        list[0] = buf.slice(n);
                    } else if (n === list[0].length) {
                        ret = list.shift();
                    } else {
                        if (stringMode) ret = ""; else ret = new Buffer(n);
                        var c = 0;
                        for (var i = 0, l = list.length; i < l && c < n; i++) {
                            var buf = list[0];
                            var cpy = Math.min(n - c, buf.length);
                            if (stringMode) ret += buf.slice(0, cpy); else buf.copy(ret, c, 0, cpy);
                            if (cpy < buf.length) list[0] = buf.slice(cpy); else list.shift();
                            c += cpy;
                        }
                    }
                }
                return ret;
            }
            function endReadable(stream) {
                var state = stream._readableState;
                if (state.length > 0) throw new Error("endReadable called on non-empty stream");
                if (!state.endEmitted) {
                    state.ended = true;
                    process.nextTick(function() {
                        if (!state.endEmitted && state.length === 0) {
                            state.endEmitted = true;
                            stream.readable = false;
                            stream.emit("end");
                        }
                    });
                }
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x) return i;
                }
                return -1;
            }
        }).call(this, require("_process"));
    }, {
        "./_stream_duplex": 13,
        _process: 10,
        buffer: 3,
        "core-util-is": 18,
        events: 7,
        inherits: 8,
        isarray: 9,
        stream: 23,
        "string_decoder/": 24,
        util: 2
    } ],
    16: [ function(require, module, exports) {
        module.exports = Transform;
        var Duplex = require("./_stream_duplex");
        var util = require("core-util-is");
        util.inherits = require("inherits");
        util.inherits(Transform, Duplex);
        function TransformState(options, stream) {
            this.afterTransform = function(er, data) {
                return afterTransform(stream, er, data);
            };
            this.needTransform = false;
            this.transforming = false;
            this.writecb = null;
            this.writechunk = null;
        }
        function afterTransform(stream, er, data) {
            var ts = stream._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (!cb) return stream.emit("error", new Error("no writecb in Transform class"));
            ts.writechunk = null;
            ts.writecb = null;
            if (!util.isNullOrUndefined(data)) stream.push(data);
            if (cb) cb(er);
            var rs = stream._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
                stream._read(rs.highWaterMark);
            }
        }
        function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);
            Duplex.call(this, options);
            this._transformState = new TransformState(options, this);
            var stream = this;
            this._readableState.needReadable = true;
            this._readableState.sync = false;
            this.once("prefinish", function() {
                if (util.isFunction(this._flush)) this._flush(function(er) {
                    done(stream, er);
                }); else done(stream);
            });
        }
        Transform.prototype.push = function(chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
            throw new Error("not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
            }
        };
        Transform.prototype._read = function(n) {
            var ts = this._transformState;
            if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
                ts.needTransform = true;
            }
        };
        function done(stream, er) {
            if (er) return stream.emit("error", er);
            var ws = stream._writableState;
            var ts = stream._transformState;
            if (ws.length) throw new Error("calling transform done when ws.length != 0");
            if (ts.transforming) throw new Error("calling transform done when still transforming");
            return stream.push(null);
        }
    }, {
        "./_stream_duplex": 13,
        "core-util-is": 18,
        inherits: 8
    } ],
    17: [ function(require, module, exports) {
        (function(process) {
            module.exports = Writable;
            var Buffer = require("buffer").Buffer;
            Writable.WritableState = WritableState;
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var Stream = require("stream");
            util.inherits(Writable, Stream);
            function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
            }
            function WritableState(options, stream) {
                var Duplex = require("./_stream_duplex");
                options = options || {};
                var hwm = options.highWaterMark;
                var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                this.objectMode = !!options.objectMode;
                if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
                this.highWaterMark = ~~this.highWaterMark;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.length = 0;
                this.writing = false;
                this.corked = 0;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function(er) {
                    onwrite(stream, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.buffer = [];
                this.pendingcb = 0;
                this.prefinished = false;
                this.errorEmitted = false;
            }
            function Writable(options) {
                var Duplex = require("./_stream_duplex");
                if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
                this._writableState = new WritableState(options, this);
                this.writable = true;
                Stream.call(this);
            }
            Writable.prototype.pipe = function() {
                this.emit("error", new Error("Cannot pipe. Not readable."));
            };
            function writeAfterEnd(stream, state, cb) {
                var er = new Error("write after end");
                stream.emit("error", er);
                process.nextTick(function() {
                    cb(er);
                });
            }
            function validChunk(stream, state, chunk, cb) {
                var valid = true;
                if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
                    var er = new TypeError("Invalid non-string/buffer chunk");
                    stream.emit("error", er);
                    process.nextTick(function() {
                        cb(er);
                    });
                    valid = false;
                }
                return valid;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                if (util.isFunction(encoding)) {
                    cb = encoding;
                    encoding = null;
                }
                if (util.isBuffer(chunk)) encoding = "buffer"; else if (!encoding) encoding = state.defaultEncoding;
                if (!util.isFunction(cb)) cb = function() {};
                if (state.ended) writeAfterEnd(this, state, cb); else if (validChunk(this, state, chunk, cb)) {
                    state.pendingcb++;
                    ret = writeOrBuffer(this, state, chunk, encoding, cb);
                }
                return ret;
            };
            Writable.prototype.cork = function() {
                var state = this._writableState;
                state.corked++;
            };
            Writable.prototype.uncork = function() {
                var state = this._writableState;
                if (state.corked) {
                    state.corked--;
                    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
                }
            };
            function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
                    chunk = new Buffer(chunk, encoding);
                }
                return chunk;
            }
            function writeOrBuffer(stream, state, chunk, encoding, cb) {
                chunk = decodeChunk(state, chunk, encoding);
                if (util.isBuffer(chunk)) encoding = "buffer";
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret) state.needDrain = true;
                if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb)); else doWrite(stream, state, false, len, chunk, encoding, cb);
                return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
                if (sync) process.nextTick(function() {
                    state.pendingcb--;
                    cb(er);
                }); else {
                    state.pendingcb--;
                    cb(er);
                }
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
            }
            function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
            }
            function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                onwriteStateUpdate(state);
                if (er) onwriteError(stream, state, sync, er, cb); else {
                    var finished = needFinish(stream, state);
                    if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
                        clearBuffer(stream, state);
                    }
                    if (sync) {
                        process.nextTick(function() {
                            afterWrite(stream, state, finished, cb);
                        });
                    } else {
                        afterWrite(stream, state, finished, cb);
                    }
                }
            }
            function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit("drain");
                }
            }
            function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                if (stream._writev && state.buffer.length > 1) {
                    var cbs = [];
                    for (var c = 0; c < state.buffer.length; c++) cbs.push(state.buffer[c].callback);
                    state.pendingcb++;
                    doWrite(stream, state, true, state.length, state.buffer, "", function(err) {
                        for (var i = 0; i < cbs.length; i++) {
                            state.pendingcb--;
                            cbs[i](err);
                        }
                    });
                    state.buffer = [];
                } else {
                    for (var c = 0; c < state.buffer.length; c++) {
                        var entry = state.buffer[c];
                        var chunk = entry.chunk;
                        var encoding = entry.encoding;
                        var cb = entry.callback;
                        var len = state.objectMode ? 1 : chunk.length;
                        doWrite(stream, state, false, len, chunk, encoding, cb);
                        if (state.writing) {
                            c++;
                            break;
                        }
                    }
                    if (c < state.buffer.length) state.buffer = state.buffer.slice(c); else state.buffer.length = 0;
                }
                state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
                cb(new Error("not implemented"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
                var state = this._writableState;
                if (util.isFunction(chunk)) {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                } else if (util.isFunction(encoding)) {
                    cb = encoding;
                    encoding = null;
                }
                if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding);
                if (state.corked) {
                    state.corked = 1;
                    this.uncork();
                }
                if (!state.ending && !state.finished) endWritable(this, state, cb);
            };
            function needFinish(stream, state) {
                return state.ending && state.length === 0 && !state.finished && !state.writing;
            }
            function prefinish(stream, state) {
                if (!state.prefinished) {
                    state.prefinished = true;
                    stream.emit("prefinish");
                }
            }
            function finishMaybe(stream, state) {
                var need = needFinish(stream, state);
                if (need) {
                    if (state.pendingcb === 0) {
                        prefinish(stream, state);
                        state.finished = true;
                        stream.emit("finish");
                    } else prefinish(stream, state);
                }
                return need;
            }
            function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                    if (state.finished) process.nextTick(cb); else stream.once("finish", cb);
                }
                state.ended = true;
            }
        }).call(this, require("_process"));
    }, {
        "./_stream_duplex": 13,
        _process: 10,
        buffer: 3,
        "core-util-is": 18,
        inherits: 8,
        stream: 23
    } ],
    18: [ function(require, module, exports) {
        (function(Buffer) {
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
                return typeof arg === "boolean";
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
                return typeof arg === "number";
            }
            exports.isNumber = isNumber;
            function isString(arg) {
                return typeof arg === "string";
            }
            exports.isString = isString;
            function isSymbol(arg) {
                return typeof arg === "symbol";
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
                return typeof arg === "object" && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports.isDate = isDate;
            function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
                return typeof arg === "function";
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
            }
            exports.isPrimitive = isPrimitive;
            function isBuffer(arg) {
                return Buffer.isBuffer(arg);
            }
            exports.isBuffer = isBuffer;
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
        }).call(this, require("buffer").Buffer);
    }, {
        buffer: 3
    } ],
    19: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_passthrough.js");
    }, {
        "./lib/_stream_passthrough.js": 14
    } ],
    20: [ function(require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js");
        exports.Stream = require("stream");
        exports.Readable = exports;
        exports.Writable = require("./lib/_stream_writable.js");
        exports.Duplex = require("./lib/_stream_duplex.js");
        exports.Transform = require("./lib/_stream_transform.js");
        exports.PassThrough = require("./lib/_stream_passthrough.js");
    }, {
        "./lib/_stream_duplex.js": 13,
        "./lib/_stream_passthrough.js": 14,
        "./lib/_stream_readable.js": 15,
        "./lib/_stream_transform.js": 16,
        "./lib/_stream_writable.js": 17,
        stream: 23
    } ],
    21: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_transform.js");
    }, {
        "./lib/_stream_transform.js": 16
    } ],
    22: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_writable.js");
    }, {
        "./lib/_stream_writable.js": 17
    } ],
    23: [ function(require, module, exports) {
        module.exports = Stream;
        var EE = require("events").EventEmitter;
        var inherits = require("inherits");
        inherits(Stream, EE);
        Stream.Readable = require("readable-stream/readable.js");
        Stream.Writable = require("readable-stream/writable.js");
        Stream.Duplex = require("readable-stream/duplex.js");
        Stream.Transform = require("readable-stream/transform.js");
        Stream.PassThrough = require("readable-stream/passthrough.js");
        Stream.Stream = Stream;
        function Stream() {
            EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
            var source = this;
            function ondata(chunk) {
                if (dest.writable) {
                    if (false === dest.write(chunk) && source.pause) {
                        source.pause();
                    }
                }
            }
            source.on("data", ondata);
            function ondrain() {
                if (source.readable && source.resume) {
                    source.resume();
                }
            }
            dest.on("drain", ondrain);
            if (!dest._isStdio && (!options || options.end !== false)) {
                source.on("end", onend);
                source.on("close", onclose);
            }
            var didOnEnd = false;
            function onend() {
                if (didOnEnd) return;
                didOnEnd = true;
                dest.end();
            }
            function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;
                if (typeof dest.destroy === "function") dest.destroy();
            }
            function onerror(er) {
                cleanup();
                if (EE.listenerCount(this, "error") === 0) {
                    throw er;
                }
            }
            source.on("error", onerror);
            dest.on("error", onerror);
            function cleanup() {
                source.removeListener("data", ondata);
                dest.removeListener("drain", ondrain);
                source.removeListener("end", onend);
                source.removeListener("close", onclose);
                source.removeListener("error", onerror);
                dest.removeListener("error", onerror);
                source.removeListener("end", cleanup);
                source.removeListener("close", cleanup);
                dest.removeListener("close", cleanup);
            }
            source.on("end", cleanup);
            source.on("close", cleanup);
            dest.on("close", cleanup);
            dest.emit("pipe", source);
            return dest;
        };
    }, {
        events: 7,
        inherits: 8,
        "readable-stream/duplex.js": 12,
        "readable-stream/passthrough.js": 19,
        "readable-stream/readable.js": 20,
        "readable-stream/transform.js": 21,
        "readable-stream/writable.js": 22
    } ],
    24: [ function(require, module, exports) {
        var Buffer = require("buffer").Buffer;
        var isBufferEncoding = Buffer.isEncoding || function(encoding) {
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;

              default:
                return false;
            }
        };
        function assertEncoding(encoding) {
            if (encoding && !isBufferEncoding(encoding)) {
                throw new Error("Unknown encoding: " + encoding);
            }
        }
        var StringDecoder = exports.StringDecoder = function(encoding) {
            this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
            assertEncoding(encoding);
            switch (this.encoding) {
              case "utf8":
                this.surrogateSize = 3;
                break;

              case "ucs2":
              case "utf16le":
                this.surrogateSize = 2;
                this.detectIncompleteChar = utf16DetectIncompleteChar;
                break;

              case "base64":
                this.surrogateSize = 3;
                this.detectIncompleteChar = base64DetectIncompleteChar;
                break;

              default:
                this.write = passThroughWrite;
                return;
            }
            this.charBuffer = new Buffer(6);
            this.charReceived = 0;
            this.charLength = 0;
        };
        StringDecoder.prototype.write = function(buffer) {
            var charStr = "";
            while (this.charLength) {
                var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
                buffer.copy(this.charBuffer, this.charReceived, 0, available);
                this.charReceived += available;
                if (this.charReceived < this.charLength) {
                    return "";
                }
                buffer = buffer.slice(available, buffer.length);
                charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                var charCode = charStr.charCodeAt(charStr.length - 1);
                if (charCode >= 55296 && charCode <= 56319) {
                    this.charLength += this.surrogateSize;
                    charStr = "";
                    continue;
                }
                this.charReceived = this.charLength = 0;
                if (buffer.length === 0) {
                    return charStr;
                }
                break;
            }
            this.detectIncompleteChar(buffer);
            var end = buffer.length;
            if (this.charLength) {
                buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                end -= this.charReceived;
            }
            charStr += buffer.toString(this.encoding, 0, end);
            var end = charStr.length - 1;
            var charCode = charStr.charCodeAt(end);
            if (charCode >= 55296 && charCode <= 56319) {
                var size = this.surrogateSize;
                this.charLength += size;
                this.charReceived += size;
                this.charBuffer.copy(this.charBuffer, size, 0, size);
                buffer.copy(this.charBuffer, 0, 0, size);
                return charStr.substring(0, end);
            }
            return charStr;
        };
        StringDecoder.prototype.detectIncompleteChar = function(buffer) {
            var i = buffer.length >= 3 ? 3 : buffer.length;
            for (;i > 0; i--) {
                var c = buffer[buffer.length - i];
                if (i == 1 && c >> 5 == 6) {
                    this.charLength = 2;
                    break;
                }
                if (i <= 2 && c >> 4 == 14) {
                    this.charLength = 3;
                    break;
                }
                if (i <= 3 && c >> 3 == 30) {
                    this.charLength = 4;
                    break;
                }
            }
            this.charReceived = i;
        };
        StringDecoder.prototype.end = function(buffer) {
            var res = "";
            if (buffer && buffer.length) res = this.write(buffer);
            if (this.charReceived) {
                var cr = this.charReceived;
                var buf = this.charBuffer;
                var enc = this.encoding;
                res += buf.slice(0, cr).toString(enc);
            }
            return res;
        };
        function passThroughWrite(buffer) {
            return buffer.toString(this.encoding);
        }
        function utf16DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 2;
            this.charLength = this.charReceived ? 2 : 0;
        }
        function base64DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 3;
            this.charLength = this.charReceived ? 3 : 0;
        }
    }, {
        buffer: 3
    } ],
    25: [ function(require, module, exports) {
        module.exports = function isBuffer(arg) {
            return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
        };
    }, {} ],
    26: [ function(require, module, exports) {
        (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
                if (!isString(f)) {
                    var objects = [];
                    for (var i = 0; i < arguments.length; i++) {
                        objects.push(inspect(arguments[i]));
                    }
                    return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x) {
                    if (x === "%%") return "%";
                    if (i >= len) return x;
                    switch (x) {
                      case "%s":
                        return String(args[i++]);

                      case "%d":
                        return Number(args[i++]);

                      case "%j":
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return "[Circular]";
                        }

                      default:
                        return x;
                    }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                    if (isNull(x) || !isObject(x)) {
                        str += " " + x;
                    } else {
                        str += " " + inspect(x);
                    }
                }
                return str;
            };
            exports.deprecate = function(fn, msg) {
                if (isUndefined(global.process)) {
                    return function() {
                        return exports.deprecate(fn, msg).apply(this, arguments);
                    };
                }
                if (process.noDeprecation === true) {
                    return fn;
                }
                var warned = false;
                function deprecated() {
                    if (!warned) {
                        if (process.throwDeprecation) {
                            throw new Error(msg);
                        } else if (process.traceDeprecation) {
                            console.trace(msg);
                        } else {
                            console.error(msg);
                        }
                        warned = true;
                    }
                    return fn.apply(this, arguments);
                }
                return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports.debuglog = function(set) {
                if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
                set = set.toUpperCase();
                if (!debugs[set]) {
                    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error("%s %d: %s", set, pid, msg);
                        };
                    } else {
                        debugs[set] = function() {};
                    }
                }
                return debugs[set];
            };
            function inspect(obj, opts) {
                var ctx = {
                    seen: [],
                    stylize: stylizeNoColor
                };
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                    ctx.showHidden = opts;
                } else if (opts) {
                    exports._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;
            inspect.colors = {
                bold: [ 1, 22 ],
                italic: [ 3, 23 ],
                underline: [ 4, 24 ],
                inverse: [ 7, 27 ],
                white: [ 37, 39 ],
                grey: [ 90, 39 ],
                black: [ 30, 39 ],
                blue: [ 34, 39 ],
                cyan: [ 36, 39 ],
                green: [ 32, 39 ],
                magenta: [ 35, 39 ],
                red: [ 31, 39 ],
                yellow: [ 33, 39 ]
            };
            inspect.styles = {
                special: "cyan",
                number: "yellow",
                "boolean": "yellow",
                undefined: "grey",
                "null": "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            };
            function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
                } else {
                    return str;
                }
            }
            function stylizeNoColor(str, styleType) {
                return str;
            }
            function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                    hash[val] = true;
                });
                return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    if (!isString(ret)) {
                        ret = formatValue(ctx, ret, recurseTimes);
                    }
                    return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                    return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                    keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                    return formatError(value);
                }
                if (keys.length === 0) {
                    if (isFunction(value)) {
                        var name = value.name ? ": " + value.name : "";
                        return ctx.stylize("[Function" + name + "]", "special");
                    }
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    }
                    if (isDate(value)) {
                        return ctx.stylize(Date.prototype.toString.call(value), "date");
                    }
                    if (isError(value)) {
                        return formatError(value);
                    }
                }
                var base = "", array = false, braces = [ "{", "}" ];
                if (isArray(value)) {
                    array = true;
                    braces = [ "[", "]" ];
                }
                if (isFunction(value)) {
                    var n = value.name ? ": " + value.name : "";
                    base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                    base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                    base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                    base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                    return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    } else {
                        return ctx.stylize("[Object]", "special");
                    }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                    output = keys.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
                if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return ctx.stylize(simple, "string");
                }
                if (isNumber(value)) return ctx.stylize("" + value, "number");
                if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                if (isNull(value)) return ctx.stylize("null", "null");
            }
            function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                    if (hasOwnProperty(value, String(i))) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                    } else {
                        output.push("");
                    }
                }
                keys.forEach(function(key) {
                    if (!key.match(/^\d+$/)) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                    }
                });
                return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || {
                    value: value[key]
                };
                if (desc.get) {
                    if (desc.set) {
                        str = ctx.stylize("[Getter/Setter]", "special");
                    } else {
                        str = ctx.stylize("[Getter]", "special");
                    }
                } else {
                    if (desc.set) {
                        str = ctx.stylize("[Setter]", "special");
                    }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                    name = "[" + key + "]";
                }
                if (!str) {
                    if (ctx.seen.indexOf(desc.value) < 0) {
                        if (isNull(recurseTimes)) {
                            str = formatValue(ctx, desc.value, null);
                        } else {
                            str = formatValue(ctx, desc.value, recurseTimes - 1);
                        }
                        if (str.indexOf("\n") > -1) {
                            if (array) {
                                str = str.split("\n").map(function(line) {
                                    return "  " + line;
                                }).join("\n").substr(2);
                            } else {
                                str = "\n" + str.split("\n").map(function(line) {
                                    return "   " + line;
                                }).join("\n");
                            }
                        }
                    } else {
                        str = ctx.stylize("[Circular]", "special");
                    }
                }
                if (isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) {
                        return str;
                    }
                    name = JSON.stringify("" + key);
                    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                        name = name.substr(1, name.length - 2);
                        name = ctx.stylize(name, "name");
                    } else {
                        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                        name = ctx.stylize(name, "string");
                    }
                }
                return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                    numLinesEst++;
                    if (cur.indexOf("\n") >= 0) numLinesEst++;
                    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
                return typeof arg === "boolean";
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
                return typeof arg === "number";
            }
            exports.isNumber = isNumber;
            function isString(arg) {
                return typeof arg === "string";
            }
            exports.isString = isString;
            function isSymbol(arg) {
                return typeof arg === "symbol";
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
                return typeof arg === "object" && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports.isDate = isDate;
            function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
                return typeof arg === "function";
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
            }
            exports.isPrimitive = isPrimitive;
            exports.isBuffer = require("./support/isBuffer");
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
            function timestamp() {
                var d = new Date();
                var time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
                return [ d.getDate(), months[d.getMonth()], time ].join(" ");
            }
            exports.log = function() {
                console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
            };
            exports.inherits = require("inherits");
            exports._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                    origin[keys[i]] = add[keys[i]];
                }
                return origin;
            };
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
        }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        "./support/isBuffer": 25,
        _process: 10,
        inherits: 8
    } ],
    27: [ function(require, module, exports) {
        var Parser = require("htmlparser2").Parser;
        var elementStack = [];
        function ItemList(parent) {
            this.parent = parent;
            this.content = "";
            this.spacer = "";
            this.indent = parent ? parent.indent : "";
            this.isFirstItem = true;
        }
        ItemList.prototype.addSpace = function(space) {
            this.spacer += space;
            if (space.indexOf("\n") !== -1) {
                this.indent = /[^\n]*$/.exec(space)[0];
            } else {
                this.indent += space;
            }
        };
        ItemList.prototype.add = function(data, ignoreComma) {
            if (!ignoreComma) {
                if (!this.isFirstItem) {
                    this.content += this.spacer.length ? "," : ", ";
                }
                this.isFirstItem = false;
            }
            this.content += this.spacer;
            this.spacer = "";
            this.content += data;
        };
        module.exports = function(html, cb) {
            var currentItemList = new ItemList(null);
            var parser = new Parser({
                onopentag: function(name, attribs) {
                    currentItemList = new ItemList(currentItemList);
                    elementStack.unshift([ name, attribs ]);
                },
                ontext: function(text) {
                    var lines = text.split("\n");
                    var isFirst = true;
                    lines.forEach(function(line) {
                        var lineMatch = /^(\s*)(.*?)(\s*)$/.exec(line);
                        var preSpace = lineMatch[1], mainText = lineMatch[2], postSpace = lineMatch[3];
                        if (!isFirst) {
                            currentItemList.addSpace("\n");
                        }
                        currentItemList.addSpace(preSpace);
                        if (mainText.length > 0) {
                            currentItemList.add(JSON.stringify(mainText));
                        }
                        isFirst = false;
                    });
                },
                onclosetag: function(tagname) {
                    var element = elementStack.shift();
                    var elementContent = currentItemList.content + currentItemList.spacer;
                    currentItemList = currentItemList.parent;
                    var indent = currentItemList.indent;
                    var attribs = element[1];
                    var id = attribs["id"];
                    var idSuffix = id !== undefined ? "#" + id : "";
                    delete attribs["id"];
                    var classNames = attribs["class"];
                    var classSuffix = (classNames !== undefined ? classNames : "").split(/\s+/g).filter(function(v) {
                        return v.length > 0;
                    }).map(function(cls) {
                        return "." + cls;
                    }).join("");
                    delete attribs["class"];
                    var attrPairs = Object.keys(attribs).map(function(k) {
                        return JSON.stringify(k) + ": " + JSON.stringify(attribs[k]);
                    });
                    var item = "h(" + JSON.stringify(element[0] + idSuffix + classSuffix) + (attrPairs.length ? ", { " + attrPairs.join(",\n" + indent + "    ") + "}" : "") + (elementContent.length ? ", [" + (elementContent[0] === "\n" ? "" : " ") + elementContent + (elementContent.match(/\s$/) ? "" : " ") + "]" : "") + ")";
                    currentItemList.add(item);
                },
                oncomment: function(text) {
                    currentItemList.add("/*" + text + "*/", false);
                },
                onend: function() {
                    cb(null, currentItemList.content);
                }
            }, {
                decodeEntities: true
            });
            parser.write(html);
            parser.end();
        };
    }, {
        htmlparser2: 35
    } ],
    28: [ function(require, module, exports) {
        module.exports = CollectingHandler;
        function CollectingHandler(cbs) {
            this._cbs = cbs || {};
            this.events = [];
        }
        var EVENTS = require("./").EVENTS;
        Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
                name = "on" + name;
                CollectingHandler.prototype[name] = function() {
                    this.events.push([ name ]);
                    if (this._cbs[name]) this._cbs[name]();
                };
            } else if (EVENTS[name] === 1) {
                name = "on" + name;
                CollectingHandler.prototype[name] = function(a) {
                    this.events.push([ name, a ]);
                    if (this._cbs[name]) this._cbs[name](a);
                };
            } else if (EVENTS[name] === 2) {
                name = "on" + name;
                CollectingHandler.prototype[name] = function(a, b) {
                    this.events.push([ name, a, b ]);
                    if (this._cbs[name]) this._cbs[name](a, b);
                };
            } else {
                throw Error("wrong number of arguments");
            }
        });
        CollectingHandler.prototype.onreset = function() {
            this.events = [];
            if (this._cbs.onreset) this._cbs.onreset();
        };
        CollectingHandler.prototype.restart = function() {
            if (this._cbs.onreset) this._cbs.onreset();
            for (var i = 0, len = this.events.length; i < len; i++) {
                if (this._cbs[this.events[i][0]]) {
                    var num = this.events[i].length;
                    if (num === 1) {
                        this._cbs[this.events[i][0]]();
                    } else if (num === 2) {
                        this._cbs[this.events[i][0]](this.events[i][1]);
                    } else {
                        this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
                    }
                }
            }
        };
    }, {
        "./": 35
    } ],
    29: [ function(require, module, exports) {
        var index = require("./index.js"), DomHandler = index.DomHandler, DomUtils = index.DomUtils;
        function FeedHandler(callback, options) {
            this.init(callback, options);
        }
        require("util").inherits(FeedHandler, DomHandler);
        FeedHandler.prototype.init = DomHandler;
        function getElements(what, where) {
            return DomUtils.getElementsByTagName(what, where, true);
        }
        function getOneElement(what, where) {
            return DomUtils.getElementsByTagName(what, where, true, 1)[0];
        }
        function fetch(what, where, recurse) {
            return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
        }
        function addConditionally(obj, prop, what, where, recurse) {
            var tmp = fetch(what, where, recurse);
            if (tmp) obj[prop] = tmp;
        }
        var isValidFeed = function(value) {
            return value === "rss" || value === "feed" || value === "rdf:RDF";
        };
        FeedHandler.prototype.onend = function() {
            var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
            if (feedRoot) {
                if (feedRoot.name === "feed") {
                    childs = feedRoot.children;
                    feed.type = "atom";
                    addConditionally(feed, "id", "id", childs);
                    addConditionally(feed, "title", "title", childs);
                    if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
                    addConditionally(feed, "description", "subtitle", childs);
                    if (tmp = fetch("updated", childs)) feed.updated = new Date(tmp);
                    addConditionally(feed, "author", "email", childs, true);
                    feed.items = getElements("entry", childs).map(function(item) {
                        var entry = {}, tmp;
                        item = item.children;
                        addConditionally(entry, "id", "id", item);
                        addConditionally(entry, "title", "title", item);
                        if ((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
                        if (tmp = fetch("summary", item) || fetch("content", item)) entry.description = tmp;
                        if (tmp = fetch("updated", item)) entry.pubDate = new Date(tmp);
                        return entry;
                    });
                } else {
                    childs = getOneElement("channel", feedRoot.children).children;
                    feed.type = feedRoot.name.substr(0, 3);
                    feed.id = "";
                    addConditionally(feed, "title", "title", childs);
                    addConditionally(feed, "link", "link", childs);
                    addConditionally(feed, "description", "description", childs);
                    if (tmp = fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);
                    addConditionally(feed, "author", "managingEditor", childs, true);
                    feed.items = getElements("item", feedRoot.children).map(function(item) {
                        var entry = {}, tmp;
                        item = item.children;
                        addConditionally(entry, "id", "guid", item);
                        addConditionally(entry, "title", "title", item);
                        addConditionally(entry, "link", "link", item);
                        addConditionally(entry, "description", "description", item);
                        if (tmp = fetch("pubDate", item)) entry.pubDate = new Date(tmp);
                        return entry;
                    });
                }
            }
            this.dom = feed;
            DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
        };
        module.exports = FeedHandler;
    }, {
        "./index.js": 35,
        util: 26
    } ],
    30: [ function(require, module, exports) {
        var Tokenizer = require("./Tokenizer.js");
        var formTags = {
            input: true,
            option: true,
            optgroup: true,
            select: true,
            button: true,
            datalist: true,
            textarea: true
        };
        var openImpliesClose = {
            tr: {
                tr: true,
                th: true,
                td: true
            },
            th: {
                th: true
            },
            td: {
                thead: true,
                th: true,
                td: true
            },
            body: {
                head: true,
                link: true,
                script: true
            },
            li: {
                li: true
            },
            p: {
                p: true
            },
            h1: {
                p: true
            },
            h2: {
                p: true
            },
            h3: {
                p: true
            },
            h4: {
                p: true
            },
            h5: {
                p: true
            },
            h6: {
                p: true
            },
            select: formTags,
            input: formTags,
            output: formTags,
            button: formTags,
            datalist: formTags,
            textarea: formTags,
            option: {
                option: true
            },
            optgroup: {
                optgroup: true
            }
        };
        var voidElements = {
            __proto__: null,
            area: true,
            base: true,
            basefont: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            frame: true,
            hr: true,
            img: true,
            input: true,
            isindex: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true,
            path: true,
            circle: true,
            ellipse: true,
            line: true,
            rect: true,
            use: true,
            stop: true,
            polyline: true,
            polygon: true
        };
        var re_nameEnd = /\s|\//;
        function Parser(cbs, options) {
            this._options = options || {};
            this._cbs = cbs || {};
            this._tagname = "";
            this._attribname = "";
            this._attribvalue = "";
            this._attribs = null;
            this._stack = [];
            this.startIndex = 0;
            this.endIndex = null;
            this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
            this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
            this._tokenizer = new Tokenizer(this._options, this);
            if (this._cbs.onparserinit) this._cbs.onparserinit(this);
        }
        require("util").inherits(Parser, require("events").EventEmitter);
        Parser.prototype._updatePosition = function(initialOffset) {
            if (this.endIndex === null) {
                if (this._tokenizer._sectionStart <= initialOffset) {
                    this.startIndex = 0;
                } else {
                    this.startIndex = this._tokenizer._sectionStart - initialOffset;
                }
            } else this.startIndex = this.endIndex + 1;
            this.endIndex = this._tokenizer.getAbsoluteIndex();
        };
        Parser.prototype.ontext = function(data) {
            this._updatePosition(1);
            this.endIndex--;
            if (this._cbs.ontext) this._cbs.ontext(data);
        };
        Parser.prototype.onopentagname = function(name) {
            if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            this._tagname = name;
            if (!this._options.xmlMode && name in openImpliesClose) {
                for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el)) ;
            }
            if (this._options.xmlMode || !(name in voidElements)) {
                this._stack.push(name);
            }
            if (this._cbs.onopentagname) this._cbs.onopentagname(name);
            if (this._cbs.onopentag) this._attribs = {};
        };
        Parser.prototype.onopentagend = function() {
            this._updatePosition(1);
            if (this._attribs) {
                if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
                this._attribs = null;
            }
            if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
                this._cbs.onclosetag(this._tagname);
            }
            this._tagname = "";
        };
        Parser.prototype.onclosetag = function(name) {
            this._updatePosition(1);
            if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
                var pos = this._stack.lastIndexOf(name);
                if (pos !== -1) {
                    if (this._cbs.onclosetag) {
                        pos = this._stack.length - pos;
                        while (pos--) this._cbs.onclosetag(this._stack.pop());
                    } else this._stack.length = pos;
                } else if (name === "p" && !this._options.xmlMode) {
                    this.onopentagname(name);
                    this._closeCurrentTag();
                }
            } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
                this.onopentagname(name);
                this._closeCurrentTag();
            }
        };
        Parser.prototype.onselfclosingtag = function() {
            if (this._options.xmlMode || this._options.recognizeSelfClosing) {
                this._closeCurrentTag();
            } else {
                this.onopentagend();
            }
        };
        Parser.prototype._closeCurrentTag = function() {
            var name = this._tagname;
            this.onopentagend();
            if (this._stack[this._stack.length - 1] === name) {
                if (this._cbs.onclosetag) {
                    this._cbs.onclosetag(name);
                }
                this._stack.pop();
            }
        };
        Parser.prototype.onattribname = function(name) {
            if (this._lowerCaseAttributeNames) {
                name = name.toLowerCase();
            }
            this._attribname = name;
        };
        Parser.prototype.onattribdata = function(value) {
            this._attribvalue += value;
        };
        Parser.prototype.onattribend = function() {
            if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
            if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
                this._attribs[this._attribname] = this._attribvalue;
            }
            this._attribname = "";
            this._attribvalue = "";
        };
        Parser.prototype._getInstructionName = function(value) {
            var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
            if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            return name;
        };
        Parser.prototype.ondeclaration = function(value) {
            if (this._cbs.onprocessinginstruction) {
                var name = this._getInstructionName(value);
                this._cbs.onprocessinginstruction("!" + name, "!" + value);
            }
        };
        Parser.prototype.onprocessinginstruction = function(value) {
            if (this._cbs.onprocessinginstruction) {
                var name = this._getInstructionName(value);
                this._cbs.onprocessinginstruction("?" + name, "?" + value);
            }
        };
        Parser.prototype.oncomment = function(value) {
            this._updatePosition(4);
            if (this._cbs.oncomment) this._cbs.oncomment(value);
            if (this._cbs.oncommentend) this._cbs.oncommentend();
        };
        Parser.prototype.oncdata = function(value) {
            this._updatePosition(1);
            if (this._options.xmlMode || this._options.recognizeCDATA) {
                if (this._cbs.oncdatastart) this._cbs.oncdatastart();
                if (this._cbs.ontext) this._cbs.ontext(value);
                if (this._cbs.oncdataend) this._cbs.oncdataend();
            } else {
                this.oncomment("[CDATA[" + value + "]]");
            }
        };
        Parser.prototype.onerror = function(err) {
            if (this._cbs.onerror) this._cbs.onerror(err);
        };
        Parser.prototype.onend = function() {
            if (this._cbs.onclosetag) {
                for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i])) ;
            }
            if (this._cbs.onend) this._cbs.onend();
        };
        Parser.prototype.reset = function() {
            if (this._cbs.onreset) this._cbs.onreset();
            this._tokenizer.reset();
            this._tagname = "";
            this._attribname = "";
            this._attribs = null;
            this._stack = [];
            if (this._cbs.onparserinit) this._cbs.onparserinit(this);
        };
        Parser.prototype.parseComplete = function(data) {
            this.reset();
            this.end(data);
        };
        Parser.prototype.write = function(chunk) {
            this._tokenizer.write(chunk);
        };
        Parser.prototype.end = function(chunk) {
            this._tokenizer.end(chunk);
        };
        Parser.prototype.pause = function() {
            this._tokenizer.pause();
        };
        Parser.prototype.resume = function() {
            this._tokenizer.resume();
        };
        Parser.prototype.parseChunk = Parser.prototype.write;
        Parser.prototype.done = Parser.prototype.end;
        module.exports = Parser;
    }, {
        "./Tokenizer.js": 33,
        events: 7,
        util: 26
    } ],
    31: [ function(require, module, exports) {
        module.exports = ProxyHandler;
        function ProxyHandler(cbs) {
            this._cbs = cbs || {};
        }
        var EVENTS = require("./").EVENTS;
        Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
                name = "on" + name;
                ProxyHandler.prototype[name] = function() {
                    if (this._cbs[name]) this._cbs[name]();
                };
            } else if (EVENTS[name] === 1) {
                name = "on" + name;
                ProxyHandler.prototype[name] = function(a) {
                    if (this._cbs[name]) this._cbs[name](a);
                };
            } else if (EVENTS[name] === 2) {
                name = "on" + name;
                ProxyHandler.prototype[name] = function(a, b) {
                    if (this._cbs[name]) this._cbs[name](a, b);
                };
            } else {
                throw Error("wrong number of arguments");
            }
        });
    }, {
        "./": 35
    } ],
    32: [ function(require, module, exports) {
        module.exports = Stream;
        var Parser = require("./WritableStream.js");
        function Stream(options) {
            Parser.call(this, new Cbs(this), options);
        }
        require("util").inherits(Stream, Parser);
        Stream.prototype.readable = true;
        function Cbs(scope) {
            this.scope = scope;
        }
        var EVENTS = require("../").EVENTS;
        Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
                Cbs.prototype["on" + name] = function() {
                    this.scope.emit(name);
                };
            } else if (EVENTS[name] === 1) {
                Cbs.prototype["on" + name] = function(a) {
                    this.scope.emit(name, a);
                };
            } else if (EVENTS[name] === 2) {
                Cbs.prototype["on" + name] = function(a, b) {
                    this.scope.emit(name, a, b);
                };
            } else {
                throw Error("wrong number of arguments!");
            }
        });
    }, {
        "../": 35,
        "./WritableStream.js": 34,
        util: 26
    } ],
    33: [ function(require, module, exports) {
        module.exports = Tokenizer;
        var decodeCodePoint = require("entities/lib/decode_codepoint.js"), entityMap = require("entities/maps/entities.json"), legacyMap = require("entities/maps/legacy.json"), xmlMap = require("entities/maps/xml.json"), i = 0, TEXT = i++, BEFORE_TAG_NAME = i++, IN_TAG_NAME = i++, IN_SELF_CLOSING_TAG = i++, BEFORE_CLOSING_TAG_NAME = i++, IN_CLOSING_TAG_NAME = i++, AFTER_CLOSING_TAG_NAME = i++, BEFORE_ATTRIBUTE_NAME = i++, IN_ATTRIBUTE_NAME = i++, AFTER_ATTRIBUTE_NAME = i++, BEFORE_ATTRIBUTE_VALUE = i++, IN_ATTRIBUTE_VALUE_DQ = i++, IN_ATTRIBUTE_VALUE_SQ = i++, IN_ATTRIBUTE_VALUE_NQ = i++, BEFORE_DECLARATION = i++, IN_DECLARATION = i++, IN_PROCESSING_INSTRUCTION = i++, BEFORE_COMMENT = i++, IN_COMMENT = i++, AFTER_COMMENT_1 = i++, AFTER_COMMENT_2 = i++, BEFORE_CDATA_1 = i++, BEFORE_CDATA_2 = i++, BEFORE_CDATA_3 = i++, BEFORE_CDATA_4 = i++, BEFORE_CDATA_5 = i++, BEFORE_CDATA_6 = i++, IN_CDATA = i++, AFTER_CDATA_1 = i++, AFTER_CDATA_2 = i++, BEFORE_SPECIAL = i++, BEFORE_SPECIAL_END = i++, BEFORE_SCRIPT_1 = i++, BEFORE_SCRIPT_2 = i++, BEFORE_SCRIPT_3 = i++, BEFORE_SCRIPT_4 = i++, BEFORE_SCRIPT_5 = i++, AFTER_SCRIPT_1 = i++, AFTER_SCRIPT_2 = i++, AFTER_SCRIPT_3 = i++, AFTER_SCRIPT_4 = i++, AFTER_SCRIPT_5 = i++, BEFORE_STYLE_1 = i++, BEFORE_STYLE_2 = i++, BEFORE_STYLE_3 = i++, BEFORE_STYLE_4 = i++, AFTER_STYLE_1 = i++, AFTER_STYLE_2 = i++, AFTER_STYLE_3 = i++, AFTER_STYLE_4 = i++, BEFORE_ENTITY = i++, BEFORE_NUMERIC_ENTITY = i++, IN_NAMED_ENTITY = i++, IN_NUMERIC_ENTITY = i++, IN_HEX_ENTITY = i++, j = 0, SPECIAL_NONE = j++, SPECIAL_SCRIPT = j++, SPECIAL_STYLE = j++;
        function whitespace(c) {
            return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
        }
        function characterState(char, SUCCESS) {
            return function(c) {
                if (c === char) this._state = SUCCESS;
            };
        }
        function ifElseState(upper, SUCCESS, FAILURE) {
            var lower = upper.toLowerCase();
            if (upper === lower) {
                return function(c) {
                    if (c === lower) {
                        this._state = SUCCESS;
                    } else {
                        this._state = FAILURE;
                        this._index--;
                    }
                };
            } else {
                return function(c) {
                    if (c === lower || c === upper) {
                        this._state = SUCCESS;
                    } else {
                        this._state = FAILURE;
                        this._index--;
                    }
                };
            }
        }
        function consumeSpecialNameChar(upper, NEXT_STATE) {
            var lower = upper.toLowerCase();
            return function(c) {
                if (c === lower || c === upper) {
                    this._state = NEXT_STATE;
                } else {
                    this._state = IN_TAG_NAME;
                    this._index--;
                }
            };
        }
        function Tokenizer(options, cbs) {
            this._state = TEXT;
            this._buffer = "";
            this._sectionStart = 0;
            this._index = 0;
            this._bufferOffset = 0;
            this._baseState = TEXT;
            this._special = SPECIAL_NONE;
            this._cbs = cbs;
            this._running = true;
            this._ended = false;
            this._xmlMode = !!(options && options.xmlMode);
            this._decodeEntities = !!(options && options.decodeEntities);
        }
        Tokenizer.prototype._stateText = function(c) {
            if (c === "<") {
                if (this._index > this._sectionStart) {
                    this._cbs.ontext(this._getSection());
                }
                this._state = BEFORE_TAG_NAME;
                this._sectionStart = this._index;
            } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
                if (this._index > this._sectionStart) {
                    this._cbs.ontext(this._getSection());
                }
                this._baseState = TEXT;
                this._state = BEFORE_ENTITY;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateBeforeTagName = function(c) {
            if (c === "/") {
                this._state = BEFORE_CLOSING_TAG_NAME;
            } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
                this._state = TEXT;
            } else if (c === "!") {
                this._state = BEFORE_DECLARATION;
                this._sectionStart = this._index + 1;
            } else if (c === "?") {
                this._state = IN_PROCESSING_INSTRUCTION;
                this._sectionStart = this._index + 1;
            } else if (c === "<") {
                this._cbs.ontext(this._getSection());
                this._sectionStart = this._index;
            } else {
                this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateInTagName = function(c) {
            if (c === "/" || c === ">" || whitespace(c)) {
                this._emitToken("onopentagname");
                this._state = BEFORE_ATTRIBUTE_NAME;
                this._index--;
            }
        };
        Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
            if (whitespace(c)) ; else if (c === ">") {
                this._state = TEXT;
            } else if (this._special !== SPECIAL_NONE) {
                if (c === "s" || c === "S") {
                    this._state = BEFORE_SPECIAL_END;
                } else {
                    this._state = TEXT;
                    this._index--;
                }
            } else {
                this._state = IN_CLOSING_TAG_NAME;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateInCloseingTagName = function(c) {
            if (c === ">" || whitespace(c)) {
                this._emitToken("onclosetag");
                this._state = AFTER_CLOSING_TAG_NAME;
                this._index--;
            }
        };
        Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
            if (c === ">") {
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype._stateBeforeAttributeName = function(c) {
            if (c === ">") {
                this._cbs.onopentagend();
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            } else if (c === "/") {
                this._state = IN_SELF_CLOSING_TAG;
            } else if (!whitespace(c)) {
                this._state = IN_ATTRIBUTE_NAME;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateInSelfClosingTag = function(c) {
            if (c === ">") {
                this._cbs.onselfclosingtag();
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            } else if (!whitespace(c)) {
                this._state = BEFORE_ATTRIBUTE_NAME;
                this._index--;
            }
        };
        Tokenizer.prototype._stateInAttributeName = function(c) {
            if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
                this._cbs.onattribname(this._getSection());
                this._sectionStart = -1;
                this._state = AFTER_ATTRIBUTE_NAME;
                this._index--;
            }
        };
        Tokenizer.prototype._stateAfterAttributeName = function(c) {
            if (c === "=") {
                this._state = BEFORE_ATTRIBUTE_VALUE;
            } else if (c === "/" || c === ">") {
                this._cbs.onattribend();
                this._state = BEFORE_ATTRIBUTE_NAME;
                this._index--;
            } else if (!whitespace(c)) {
                this._cbs.onattribend();
                this._state = IN_ATTRIBUTE_NAME;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
            if (c === '"') {
                this._state = IN_ATTRIBUTE_VALUE_DQ;
                this._sectionStart = this._index + 1;
            } else if (c === "'") {
                this._state = IN_ATTRIBUTE_VALUE_SQ;
                this._sectionStart = this._index + 1;
            } else if (!whitespace(c)) {
                this._state = IN_ATTRIBUTE_VALUE_NQ;
                this._sectionStart = this._index;
                this._index--;
            }
        };
        Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
            if (c === '"') {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = BEFORE_ATTRIBUTE_NAME;
            } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = BEFORE_ENTITY;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
            if (c === "'") {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = BEFORE_ATTRIBUTE_NAME;
            } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = BEFORE_ENTITY;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
            if (whitespace(c) || c === ">") {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = BEFORE_ATTRIBUTE_NAME;
                this._index--;
            } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = BEFORE_ENTITY;
                this._sectionStart = this._index;
            }
        };
        Tokenizer.prototype._stateBeforeDeclaration = function(c) {
            this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
        };
        Tokenizer.prototype._stateInDeclaration = function(c) {
            if (c === ">") {
                this._cbs.ondeclaration(this._getSection());
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype._stateInProcessingInstruction = function(c) {
            if (c === ">") {
                this._cbs.onprocessinginstruction(this._getSection());
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype._stateBeforeComment = function(c) {
            if (c === "-") {
                this._state = IN_COMMENT;
                this._sectionStart = this._index + 1;
            } else {
                this._state = IN_DECLARATION;
            }
        };
        Tokenizer.prototype._stateInComment = function(c) {
            if (c === "-") this._state = AFTER_COMMENT_1;
        };
        Tokenizer.prototype._stateAfterComment1 = function(c) {
            if (c === "-") {
                this._state = AFTER_COMMENT_2;
            } else {
                this._state = IN_COMMENT;
            }
        };
        Tokenizer.prototype._stateAfterComment2 = function(c) {
            if (c === ">") {
                this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            } else if (c !== "-") {
                this._state = IN_COMMENT;
            }
        };
        Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
        Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
        Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
        Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
        Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
        Tokenizer.prototype._stateBeforeCdata6 = function(c) {
            if (c === "[") {
                this._state = IN_CDATA;
                this._sectionStart = this._index + 1;
            } else {
                this._state = IN_DECLARATION;
                this._index--;
            }
        };
        Tokenizer.prototype._stateInCdata = function(c) {
            if (c === "]") this._state = AFTER_CDATA_1;
        };
        Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);
        Tokenizer.prototype._stateAfterCdata2 = function(c) {
            if (c === ">") {
                this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
                this._state = TEXT;
                this._sectionStart = this._index + 1;
            } else if (c !== "]") {
                this._state = IN_CDATA;
            }
        };
        Tokenizer.prototype._stateBeforeSpecial = function(c) {
            if (c === "c" || c === "C") {
                this._state = BEFORE_SCRIPT_1;
            } else if (c === "t" || c === "T") {
                this._state = BEFORE_STYLE_1;
            } else {
                this._state = IN_TAG_NAME;
                this._index--;
            }
        };
        Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
            if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
                this._state = AFTER_SCRIPT_1;
            } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
                this._state = AFTER_STYLE_1;
            } else this._state = TEXT;
        };
        Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
        Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
        Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
        Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
        Tokenizer.prototype._stateBeforeScript5 = function(c) {
            if (c === "/" || c === ">" || whitespace(c)) {
                this._special = SPECIAL_SCRIPT;
            }
            this._state = IN_TAG_NAME;
            this._index--;
        };
        Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
        Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
        Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
        Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
        Tokenizer.prototype._stateAfterScript5 = function(c) {
            if (c === ">" || whitespace(c)) {
                this._special = SPECIAL_NONE;
                this._state = IN_CLOSING_TAG_NAME;
                this._sectionStart = this._index - 6;
                this._index--;
            } else this._state = TEXT;
        };
        Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
        Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
        Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
        Tokenizer.prototype._stateBeforeStyle4 = function(c) {
            if (c === "/" || c === ">" || whitespace(c)) {
                this._special = SPECIAL_STYLE;
            }
            this._state = IN_TAG_NAME;
            this._index--;
        };
        Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
        Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
        Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
        Tokenizer.prototype._stateAfterStyle4 = function(c) {
            if (c === ">" || whitespace(c)) {
                this._special = SPECIAL_NONE;
                this._state = IN_CLOSING_TAG_NAME;
                this._sectionStart = this._index - 5;
                this._index--;
            } else this._state = TEXT;
        };
        Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
        Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
        Tokenizer.prototype._parseNamedEntityStrict = function() {
            if (this._sectionStart + 1 < this._index) {
                var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
                if (map.hasOwnProperty(entity)) {
                    this._emitPartial(map[entity]);
                    this._sectionStart = this._index + 1;
                }
            }
        };
        Tokenizer.prototype._parseLegacyEntity = function() {
            var start = this._sectionStart + 1, limit = this._index - start;
            if (limit > 6) limit = 6;
            while (limit >= 2) {
                var entity = this._buffer.substr(start, limit);
                if (legacyMap.hasOwnProperty(entity)) {
                    this._emitPartial(legacyMap[entity]);
                    this._sectionStart += limit + 1;
                    return;
                } else {
                    limit--;
                }
            }
        };
        Tokenizer.prototype._stateInNamedEntity = function(c) {
            if (c === ";") {
                this._parseNamedEntityStrict();
                if (this._sectionStart + 1 < this._index && !this._xmlMode) {
                    this._parseLegacyEntity();
                }
                this._state = this._baseState;
            } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
                if (this._xmlMode) ; else if (this._sectionStart + 1 === this._index) ; else if (this._baseState !== TEXT) {
                    if (c !== "=") {
                        this._parseNamedEntityStrict();
                    }
                } else {
                    this._parseLegacyEntity();
                }
                this._state = this._baseState;
                this._index--;
            }
        };
        Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
            var sectionStart = this._sectionStart + offset;
            if (sectionStart !== this._index) {
                var entity = this._buffer.substring(sectionStart, this._index);
                var parsed = parseInt(entity, base);
                this._emitPartial(decodeCodePoint(parsed));
                this._sectionStart = this._index;
            } else {
                this._sectionStart--;
            }
            this._state = this._baseState;
        };
        Tokenizer.prototype._stateInNumericEntity = function(c) {
            if (c === ";") {
                this._decodeNumericEntity(2, 10);
                this._sectionStart++;
            } else if (c < "0" || c > "9") {
                if (!this._xmlMode) {
                    this._decodeNumericEntity(2, 10);
                } else {
                    this._state = this._baseState;
                }
                this._index--;
            }
        };
        Tokenizer.prototype._stateInHexEntity = function(c) {
            if (c === ";") {
                this._decodeNumericEntity(3, 16);
                this._sectionStart++;
            } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
                if (!this._xmlMode) {
                    this._decodeNumericEntity(3, 16);
                } else {
                    this._state = this._baseState;
                }
                this._index--;
            }
        };
        Tokenizer.prototype._cleanup = function() {
            if (this._sectionStart < 0) {
                this._buffer = "";
                this._index = 0;
                this._bufferOffset += this._index;
            } else if (this._running) {
                if (this._state === TEXT) {
                    if (this._sectionStart !== this._index) {
                        this._cbs.ontext(this._buffer.substr(this._sectionStart));
                    }
                    this._buffer = "";
                    this._index = 0;
                    this._bufferOffset += this._index;
                } else if (this._sectionStart === this._index) {
                    this._buffer = "";
                    this._index = 0;
                    this._bufferOffset += this._index;
                } else {
                    this._buffer = this._buffer.substr(this._sectionStart);
                    this._index -= this._sectionStart;
                    this._bufferOffset += this._sectionStart;
                }
                this._sectionStart = 0;
            }
        };
        Tokenizer.prototype.write = function(chunk) {
            if (this._ended) this._cbs.onerror(Error(".write() after done!"));
            this._buffer += chunk;
            this._parse();
        };
        Tokenizer.prototype._parse = function() {
            while (this._index < this._buffer.length && this._running) {
                var c = this._buffer.charAt(this._index);
                if (this._state === TEXT) {
                    this._stateText(c);
                } else if (this._state === BEFORE_TAG_NAME) {
                    this._stateBeforeTagName(c);
                } else if (this._state === IN_TAG_NAME) {
                    this._stateInTagName(c);
                } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
                    this._stateBeforeCloseingTagName(c);
                } else if (this._state === IN_CLOSING_TAG_NAME) {
                    this._stateInCloseingTagName(c);
                } else if (this._state === AFTER_CLOSING_TAG_NAME) {
                    this._stateAfterCloseingTagName(c);
                } else if (this._state === IN_SELF_CLOSING_TAG) {
                    this._stateInSelfClosingTag(c);
                } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
                    this._stateBeforeAttributeName(c);
                } else if (this._state === IN_ATTRIBUTE_NAME) {
                    this._stateInAttributeName(c);
                } else if (this._state === AFTER_ATTRIBUTE_NAME) {
                    this._stateAfterAttributeName(c);
                } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
                    this._stateBeforeAttributeValue(c);
                } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
                    this._stateInAttributeValueDoubleQuotes(c);
                } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
                    this._stateInAttributeValueSingleQuotes(c);
                } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
                    this._stateInAttributeValueNoQuotes(c);
                } else if (this._state === BEFORE_DECLARATION) {
                    this._stateBeforeDeclaration(c);
                } else if (this._state === IN_DECLARATION) {
                    this._stateInDeclaration(c);
                } else if (this._state === IN_PROCESSING_INSTRUCTION) {
                    this._stateInProcessingInstruction(c);
                } else if (this._state === BEFORE_COMMENT) {
                    this._stateBeforeComment(c);
                } else if (this._state === IN_COMMENT) {
                    this._stateInComment(c);
                } else if (this._state === AFTER_COMMENT_1) {
                    this._stateAfterComment1(c);
                } else if (this._state === AFTER_COMMENT_2) {
                    this._stateAfterComment2(c);
                } else if (this._state === BEFORE_CDATA_1) {
                    this._stateBeforeCdata1(c);
                } else if (this._state === BEFORE_CDATA_2) {
                    this._stateBeforeCdata2(c);
                } else if (this._state === BEFORE_CDATA_3) {
                    this._stateBeforeCdata3(c);
                } else if (this._state === BEFORE_CDATA_4) {
                    this._stateBeforeCdata4(c);
                } else if (this._state === BEFORE_CDATA_5) {
                    this._stateBeforeCdata5(c);
                } else if (this._state === BEFORE_CDATA_6) {
                    this._stateBeforeCdata6(c);
                } else if (this._state === IN_CDATA) {
                    this._stateInCdata(c);
                } else if (this._state === AFTER_CDATA_1) {
                    this._stateAfterCdata1(c);
                } else if (this._state === AFTER_CDATA_2) {
                    this._stateAfterCdata2(c);
                } else if (this._state === BEFORE_SPECIAL) {
                    this._stateBeforeSpecial(c);
                } else if (this._state === BEFORE_SPECIAL_END) {
                    this._stateBeforeSpecialEnd(c);
                } else if (this._state === BEFORE_SCRIPT_1) {
                    this._stateBeforeScript1(c);
                } else if (this._state === BEFORE_SCRIPT_2) {
                    this._stateBeforeScript2(c);
                } else if (this._state === BEFORE_SCRIPT_3) {
                    this._stateBeforeScript3(c);
                } else if (this._state === BEFORE_SCRIPT_4) {
                    this._stateBeforeScript4(c);
                } else if (this._state === BEFORE_SCRIPT_5) {
                    this._stateBeforeScript5(c);
                } else if (this._state === AFTER_SCRIPT_1) {
                    this._stateAfterScript1(c);
                } else if (this._state === AFTER_SCRIPT_2) {
                    this._stateAfterScript2(c);
                } else if (this._state === AFTER_SCRIPT_3) {
                    this._stateAfterScript3(c);
                } else if (this._state === AFTER_SCRIPT_4) {
                    this._stateAfterScript4(c);
                } else if (this._state === AFTER_SCRIPT_5) {
                    this._stateAfterScript5(c);
                } else if (this._state === BEFORE_STYLE_1) {
                    this._stateBeforeStyle1(c);
                } else if (this._state === BEFORE_STYLE_2) {
                    this._stateBeforeStyle2(c);
                } else if (this._state === BEFORE_STYLE_3) {
                    this._stateBeforeStyle3(c);
                } else if (this._state === BEFORE_STYLE_4) {
                    this._stateBeforeStyle4(c);
                } else if (this._state === AFTER_STYLE_1) {
                    this._stateAfterStyle1(c);
                } else if (this._state === AFTER_STYLE_2) {
                    this._stateAfterStyle2(c);
                } else if (this._state === AFTER_STYLE_3) {
                    this._stateAfterStyle3(c);
                } else if (this._state === AFTER_STYLE_4) {
                    this._stateAfterStyle4(c);
                } else if (this._state === BEFORE_ENTITY) {
                    this._stateBeforeEntity(c);
                } else if (this._state === BEFORE_NUMERIC_ENTITY) {
                    this._stateBeforeNumericEntity(c);
                } else if (this._state === IN_NAMED_ENTITY) {
                    this._stateInNamedEntity(c);
                } else if (this._state === IN_NUMERIC_ENTITY) {
                    this._stateInNumericEntity(c);
                } else if (this._state === IN_HEX_ENTITY) {
                    this._stateInHexEntity(c);
                } else {
                    this._cbs.onerror(Error("unknown _state"), this._state);
                }
                this._index++;
            }
            this._cleanup();
        };
        Tokenizer.prototype.pause = function() {
            this._running = false;
        };
        Tokenizer.prototype.resume = function() {
            this._running = true;
            if (this._index < this._buffer.length) {
                this._parse();
            }
            if (this._ended) {
                this._finish();
            }
        };
        Tokenizer.prototype.end = function(chunk) {
            if (this._ended) this._cbs.onerror(Error(".end() after done!"));
            if (chunk) this.write(chunk);
            this._ended = true;
            if (this._running) this._finish();
        };
        Tokenizer.prototype._finish = function() {
            if (this._sectionStart < this._index) {
                this._handleTrailingData();
            }
            this._cbs.onend();
        };
        Tokenizer.prototype._handleTrailingData = function() {
            var data = this._buffer.substr(this._sectionStart);
            if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
                this._cbs.oncdata(data);
            } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
                this._cbs.oncomment(data);
            } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
                this._parseLegacyEntity();
                if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                }
            } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
                this._decodeNumericEntity(2, 10);
                if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                }
            } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
                this._decodeNumericEntity(3, 16);
                if (this._sectionStart < this._index) {
                    this._state = this._baseState;
                    this._handleTrailingData();
                }
            } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
                this._cbs.ontext(data);
            }
        };
        Tokenizer.prototype.reset = function() {
            Tokenizer.call(this, {
                xmlMode: this._xmlMode,
                decodeEntities: this._decodeEntities
            }, this._cbs);
        };
        Tokenizer.prototype.getAbsoluteIndex = function() {
            return this._bufferOffset + this._index;
        };
        Tokenizer.prototype._getSection = function() {
            return this._buffer.substring(this._sectionStart, this._index);
        };
        Tokenizer.prototype._emitToken = function(name) {
            this._cbs[name](this._getSection());
            this._sectionStart = -1;
        };
        Tokenizer.prototype._emitPartial = function(value) {
            if (this._baseState !== TEXT) {
                this._cbs.onattribdata(value);
            } else {
                this._cbs.ontext(value);
            }
        };
    }, {
        "entities/lib/decode_codepoint.js": 57,
        "entities/maps/entities.json": 59,
        "entities/maps/legacy.json": 60,
        "entities/maps/xml.json": 61
    } ],
    34: [ function(require, module, exports) {
        module.exports = Stream;
        var Parser = require("./Parser.js"), WritableStream = require("stream").Writable || require("readable-stream").Writable;
        function Stream(cbs, options) {
            var parser = this._parser = new Parser(cbs, options);
            WritableStream.call(this, {
                decodeStrings: false
            });
            this.once("finish", function() {
                parser.end();
            });
        }
        require("util").inherits(Stream, WritableStream);
        WritableStream.prototype._write = function(chunk, encoding, cb) {
            this._parser.write(chunk);
            cb();
        };
    }, {
        "./Parser.js": 30,
        "readable-stream": 2,
        stream: 23,
        util: 26
    } ],
    35: [ function(require, module, exports) {
        var Parser = require("./Parser.js"), DomHandler = require("domhandler");
        function defineProp(name, value) {
            delete module.exports[name];
            module.exports[name] = value;
            return value;
        }
        module.exports = {
            Parser: Parser,
            Tokenizer: require("./Tokenizer.js"),
            ElementType: require("domelementtype"),
            DomHandler: DomHandler,
            get FeedHandler() {
                return defineProp("FeedHandler", require("./FeedHandler.js"));
            },
            get Stream() {
                return defineProp("Stream", require("./Stream.js"));
            },
            get WritableStream() {
                return defineProp("WritableStream", require("./WritableStream.js"));
            },
            get ProxyHandler() {
                return defineProp("ProxyHandler", require("./ProxyHandler.js"));
            },
            get DomUtils() {
                return defineProp("DomUtils", require("domutils"));
            },
            get CollectingHandler() {
                return defineProp("CollectingHandler", require("./CollectingHandler.js"));
            },
            DefaultHandler: DomHandler,
            get RssHandler() {
                return defineProp("RssHandler", this.FeedHandler);
            },
            parseDOM: function(data, options) {
                var handler = new DomHandler(options);
                new Parser(handler, options).end(data);
                return handler.dom;
            },
            parseFeed: function(feed, options) {
                var handler = new module.exports.FeedHandler(options);
                new Parser(handler, options).end(feed);
                return handler.dom;
            },
            createDomStream: function(cb, options, elementCb) {
                var handler = new DomHandler(cb, options, elementCb);
                return new Parser(handler, options);
            },
            EVENTS: {
                attribute: 2,
                cdatastart: 0,
                cdataend: 0,
                text: 1,
                processinginstruction: 2,
                comment: 1,
                commentend: 0,
                closetag: 1,
                opentag: 2,
                opentagname: 1,
                error: 1,
                end: 0
            }
        };
    }, {
        "./CollectingHandler.js": 28,
        "./FeedHandler.js": 29,
        "./Parser.js": 30,
        "./ProxyHandler.js": 31,
        "./Stream.js": 32,
        "./Tokenizer.js": 33,
        "./WritableStream.js": 34,
        domelementtype: 36,
        domhandler: 37,
        domutils: 40
    } ],
    36: [ function(require, module, exports) {
        module.exports = {
            Text: "text",
            Directive: "directive",
            Comment: "comment",
            Script: "script",
            Style: "style",
            Tag: "tag",
            CDATA: "cdata",
            Doctype: "doctype",
            isTag: function(elem) {
                return elem.type === "tag" || elem.type === "script" || elem.type === "style";
            }
        };
    }, {} ],
    37: [ function(require, module, exports) {
        var ElementType = require("domelementtype");
        var re_whitespace = /\s+/g;
        var NodePrototype = require("./lib/node");
        var ElementPrototype = require("./lib/element");
        function DomHandler(callback, options, elementCB) {
            if (typeof callback === "object") {
                elementCB = options;
                options = callback;
                callback = null;
            } else if (typeof options === "function") {
                elementCB = options;
                options = defaultOpts;
            }
            this._callback = callback;
            this._options = options || defaultOpts;
            this._elementCB = elementCB;
            this.dom = [];
            this._done = false;
            this._tagStack = [];
            this._parser = this._parser || null;
        }
        var defaultOpts = {
            normalizeWhitespace: false,
            withStartIndices: false
        };
        DomHandler.prototype.onparserinit = function(parser) {
            this._parser = parser;
        };
        DomHandler.prototype.onreset = function() {
            DomHandler.call(this, this._callback, this._options, this._elementCB);
        };
        DomHandler.prototype.onend = function() {
            if (this._done) return;
            this._done = true;
            this._parser = null;
            this._handleCallback(null);
        };
        DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(error) {
            if (typeof this._callback === "function") {
                this._callback(error, this.dom);
            } else {
                if (error) throw error;
            }
        };
        DomHandler.prototype.onclosetag = function() {
            var elem = this._tagStack.pop();
            if (this._elementCB) this._elementCB(elem);
        };
        DomHandler.prototype._addDomElement = function(element) {
            var parent = this._tagStack[this._tagStack.length - 1];
            var siblings = parent ? parent.children : this.dom;
            var previousSibling = siblings[siblings.length - 1];
            element.next = null;
            if (this._options.withStartIndices) {
                element.startIndex = this._parser.startIndex;
            }
            if (this._options.withDomLvl1) {
                element.__proto__ = element.type === "tag" ? ElementPrototype : NodePrototype;
            }
            if (previousSibling) {
                element.prev = previousSibling;
                previousSibling.next = element;
            } else {
                element.prev = null;
            }
            siblings.push(element);
            element.parent = parent || null;
        };
        DomHandler.prototype.onopentag = function(name, attribs) {
            var element = {
                type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
                name: name,
                attribs: attribs,
                children: []
            };
            this._addDomElement(element);
            this._tagStack.push(element);
        };
        DomHandler.prototype.ontext = function(data) {
            var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
            var lastTag;
            if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
                if (normalize) {
                    lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
                } else {
                    lastTag.data += data;
                }
            } else {
                if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
                    if (normalize) {
                        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
                    } else {
                        lastTag.data += data;
                    }
                } else {
                    if (normalize) {
                        data = data.replace(re_whitespace, " ");
                    }
                    this._addDomElement({
                        data: data,
                        type: ElementType.Text
                    });
                }
            }
        };
        DomHandler.prototype.oncomment = function(data) {
            var lastTag = this._tagStack[this._tagStack.length - 1];
            if (lastTag && lastTag.type === ElementType.Comment) {
                lastTag.data += data;
                return;
            }
            var element = {
                data: data,
                type: ElementType.Comment
            };
            this._addDomElement(element);
            this._tagStack.push(element);
        };
        DomHandler.prototype.oncdatastart = function() {
            var element = {
                children: [ {
                    data: "",
                    type: ElementType.Text
                } ],
                type: ElementType.CDATA
            };
            this._addDomElement(element);
            this._tagStack.push(element);
        };
        DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
            this._tagStack.pop();
        };
        DomHandler.prototype.onprocessinginstruction = function(name, data) {
            this._addDomElement({
                name: name,
                data: data,
                type: ElementType.Directive
            });
        };
        module.exports = DomHandler;
    }, {
        "./lib/element": 38,
        "./lib/node": 39,
        domelementtype: 36
    } ],
    38: [ function(require, module, exports) {
        var NodePrototype = require("./node");
        var ElementPrototype = module.exports = Object.create(NodePrototype);
        var domLvl1 = {
            tagName: "name"
        };
        Object.keys(domLvl1).forEach(function(key) {
            var shorthand = domLvl1[key];
            Object.defineProperty(ElementPrototype, key, {
                get: function() {
                    return this[shorthand] || null;
                },
                set: function(val) {
                    this[shorthand] = val;
                    return val;
                }
            });
        });
    }, {
        "./node": 39
    } ],
    39: [ function(require, module, exports) {
        var NodePrototype = module.exports = {
            get firstChild() {
                var children = this.children;
                return children && children[0] || null;
            },
            get lastChild() {
                var children = this.children;
                return children && children[children.length - 1] || null;
            },
            get nodeType() {
                return nodeTypes[this.type] || nodeTypes.element;
            }
        };
        var domLvl1 = {
            tagName: "name",
            childNodes: "children",
            parentNode: "parent",
            previousSibling: "prev",
            nextSibling: "next",
            nodeValue: "data"
        };
        var nodeTypes = {
            element: 1,
            text: 3,
            cdata: 4,
            comment: 8
        };
        Object.keys(domLvl1).forEach(function(key) {
            var shorthand = domLvl1[key];
            Object.defineProperty(NodePrototype, key, {
                get: function() {
                    return this[shorthand] || null;
                },
                set: function(val) {
                    this[shorthand] = val;
                    return val;
                }
            });
        });
    }, {} ],
    40: [ function(require, module, exports) {
        var DomUtils = module.exports;
        [ require("./lib/stringify"), require("./lib/traversal"), require("./lib/manipulation"), require("./lib/querying"), require("./lib/legacy"), require("./lib/helpers") ].forEach(function(ext) {
            Object.keys(ext).forEach(function(key) {
                DomUtils[key] = ext[key].bind(DomUtils);
            });
        });
    }, {
        "./lib/helpers": 41,
        "./lib/legacy": 42,
        "./lib/manipulation": 43,
        "./lib/querying": 44,
        "./lib/stringify": 45,
        "./lib/traversal": 46
    } ],
    41: [ function(require, module, exports) {
        exports.removeSubsets = function(nodes) {
            var idx = nodes.length, node, ancestor, replace;
            while (--idx > -1) {
                node = ancestor = nodes[idx];
                nodes[idx] = null;
                replace = true;
                while (ancestor) {
                    if (nodes.indexOf(ancestor) > -1) {
                        replace = false;
                        nodes.splice(idx, 1);
                        break;
                    }
                    ancestor = ancestor.parent;
                }
                if (replace) {
                    nodes[idx] = node;
                }
            }
            return nodes;
        };
        var POSITION = {
            DISCONNECTED: 1,
            PRECEDING: 2,
            FOLLOWING: 4,
            CONTAINS: 8,
            CONTAINED_BY: 16
        };
        var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
            var aParents = [];
            var bParents = [];
            var current, sharedParent, siblings, aSibling, bSibling, idx;
            if (nodeA === nodeB) {
                return 0;
            }
            current = nodeA;
            while (current) {
                aParents.unshift(current);
                current = current.parent;
            }
            current = nodeB;
            while (current) {
                bParents.unshift(current);
                current = current.parent;
            }
            idx = 0;
            while (aParents[idx] === bParents[idx]) {
                idx++;
            }
            if (idx === 0) {
                return POSITION.DISCONNECTED;
            }
            sharedParent = aParents[idx - 1];
            siblings = sharedParent.children;
            aSibling = aParents[idx];
            bSibling = bParents[idx];
            if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
                if (sharedParent === nodeB) {
                    return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
                }
                return POSITION.FOLLOWING;
            } else {
                if (sharedParent === nodeA) {
                    return POSITION.PRECEDING | POSITION.CONTAINS;
                }
                return POSITION.PRECEDING;
            }
        };
        exports.uniqueSort = function(nodes) {
            var idx = nodes.length, node, position;
            nodes = nodes.slice();
            while (--idx > -1) {
                node = nodes[idx];
                position = nodes.indexOf(node);
                if (position > -1 && position < idx) {
                    nodes.splice(idx, 1);
                }
            }
            nodes.sort(function(a, b) {
                var relative = comparePos(a, b);
                if (relative & POSITION.PRECEDING) {
                    return -1;
                } else if (relative & POSITION.FOLLOWING) {
                    return 1;
                }
                return 0;
            });
            return nodes;
        };
    }, {} ],
    42: [ function(require, module, exports) {
        var ElementType = require("domelementtype");
        var isTag = exports.isTag = ElementType.isTag;
        exports.testElement = function(options, element) {
            for (var key in options) {
                if (!options.hasOwnProperty(key)) ; else if (key === "tag_name") {
                    if (!isTag(element) || !options.tag_name(element.name)) {
                        return false;
                    }
                } else if (key === "tag_type") {
                    if (!options.tag_type(element.type)) return false;
                } else if (key === "tag_contains") {
                    if (isTag(element) || !options.tag_contains(element.data)) {
                        return false;
                    }
                } else if (!element.attribs || !options[key](element.attribs[key])) {
                    return false;
                }
            }
            return true;
        };
        var Checks = {
            tag_name: function(name) {
                if (typeof name === "function") {
                    return function(elem) {
                        return isTag(elem) && name(elem.name);
                    };
                } else if (name === "*") {
                    return isTag;
                } else {
                    return function(elem) {
                        return isTag(elem) && elem.name === name;
                    };
                }
            },
            tag_type: function(type) {
                if (typeof type === "function") {
                    return function(elem) {
                        return type(elem.type);
                    };
                } else {
                    return function(elem) {
                        return elem.type === type;
                    };
                }
            },
            tag_contains: function(data) {
                if (typeof data === "function") {
                    return function(elem) {
                        return !isTag(elem) && data(elem.data);
                    };
                } else {
                    return function(elem) {
                        return !isTag(elem) && elem.data === data;
                    };
                }
            }
        };
        function getAttribCheck(attrib, value) {
            if (typeof value === "function") {
                return function(elem) {
                    return elem.attribs && value(elem.attribs[attrib]);
                };
            } else {
                return function(elem) {
                    return elem.attribs && elem.attribs[attrib] === value;
                };
            }
        }
        function combineFuncs(a, b) {
            return function(elem) {
                return a(elem) || b(elem);
            };
        }
        exports.getElements = function(options, element, recurse, limit) {
            var funcs = Object.keys(options).map(function(key) {
                var value = options[key];
                return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
            });
            return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
        };
        exports.getElementById = function(id, element, recurse) {
            if (!Array.isArray(element)) element = [ element ];
            return this.findOne(getAttribCheck("id", id), element, recurse !== false);
        };
        exports.getElementsByTagName = function(name, element, recurse, limit) {
            return this.filter(Checks.tag_name(name), element, recurse, limit);
        };
        exports.getElementsByTagType = function(type, element, recurse, limit) {
            return this.filter(Checks.tag_type(type), element, recurse, limit);
        };
    }, {
        domelementtype: 36
    } ],
    43: [ function(require, module, exports) {
        exports.removeElement = function(elem) {
            if (elem.prev) elem.prev.next = elem.next;
            if (elem.next) elem.next.prev = elem.prev;
            if (elem.parent) {
                var childs = elem.parent.children;
                childs.splice(childs.lastIndexOf(elem), 1);
            }
        };
        exports.replaceElement = function(elem, replacement) {
            var prev = replacement.prev = elem.prev;
            if (prev) {
                prev.next = replacement;
            }
            var next = replacement.next = elem.next;
            if (next) {
                next.prev = replacement;
            }
            var parent = replacement.parent = elem.parent;
            if (parent) {
                var childs = parent.children;
                childs[childs.lastIndexOf(elem)] = replacement;
            }
        };
        exports.appendChild = function(elem, child) {
            child.parent = elem;
            if (elem.children.push(child) !== 1) {
                var sibling = elem.children[elem.children.length - 2];
                sibling.next = child;
                child.prev = sibling;
                child.next = null;
            }
        };
        exports.append = function(elem, next) {
            var parent = elem.parent, currNext = elem.next;
            next.next = currNext;
            next.prev = elem;
            elem.next = next;
            next.parent = parent;
            if (currNext) {
                currNext.prev = next;
                if (parent) {
                    var childs = parent.children;
                    childs.splice(childs.lastIndexOf(currNext), 0, next);
                }
            } else if (parent) {
                parent.children.push(next);
            }
        };
        exports.prepend = function(elem, prev) {
            var parent = elem.parent;
            if (parent) {
                var childs = parent.children;
                childs.splice(childs.lastIndexOf(elem), 0, prev);
            }
            if (elem.prev) {
                elem.prev.next = prev;
            }
            prev.parent = parent;
            prev.prev = elem.prev;
            prev.next = elem;
            elem.prev = prev;
        };
    }, {} ],
    44: [ function(require, module, exports) {
        var isTag = require("domelementtype").isTag;
        module.exports = {
            filter: filter,
            find: find,
            findOneChild: findOneChild,
            findOne: findOne,
            existsOne: existsOne,
            findAll: findAll
        };
        function filter(test, element, recurse, limit) {
            if (!Array.isArray(element)) element = [ element ];
            if (typeof limit !== "number" || !isFinite(limit)) {
                limit = Infinity;
            }
            return find(test, element, recurse !== false, limit);
        }
        function find(test, elems, recurse, limit) {
            var result = [], childs;
            for (var i = 0, j = elems.length; i < j; i++) {
                if (test(elems[i])) {
                    result.push(elems[i]);
                    if (--limit <= 0) break;
                }
                childs = elems[i].children;
                if (recurse && childs && childs.length > 0) {
                    childs = find(test, childs, recurse, limit);
                    result = result.concat(childs);
                    limit -= childs.length;
                    if (limit <= 0) break;
                }
            }
            return result;
        }
        function findOneChild(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) {
                if (test(elems[i])) return elems[i];
            }
            return null;
        }
        function findOne(test, elems) {
            var elem = null;
            for (var i = 0, l = elems.length; i < l && !elem; i++) {
                if (!isTag(elems[i])) {
                    continue;
                } else if (test(elems[i])) {
                    elem = elems[i];
                } else if (elems[i].children.length > 0) {
                    elem = findOne(test, elems[i].children);
                }
            }
            return elem;
        }
        function existsOne(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) {
                if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
                    return true;
                }
            }
            return false;
        }
        function findAll(test, elems) {
            var result = [];
            for (var i = 0, j = elems.length; i < j; i++) {
                if (!isTag(elems[i])) continue;
                if (test(elems[i])) result.push(elems[i]);
                if (elems[i].children.length > 0) {
                    result = result.concat(findAll(test, elems[i].children));
                }
            }
            return result;
        }
    }, {
        domelementtype: 36
    } ],
    45: [ function(require, module, exports) {
        var ElementType = require("domelementtype"), getOuterHTML = require("dom-serializer"), isTag = ElementType.isTag;
        module.exports = {
            getInnerHTML: getInnerHTML,
            getOuterHTML: getOuterHTML,
            getText: getText
        };
        function getInnerHTML(elem, opts) {
            return elem.children ? elem.children.map(function(elem) {
                return getOuterHTML(elem, opts);
            }).join("") : "";
        }
        function getText(elem) {
            if (Array.isArray(elem)) return elem.map(getText).join("");
            if (isTag(elem) || elem.type === ElementType.CDATA) return getText(elem.children);
            if (elem.type === ElementType.Text) return elem.data;
            return "";
        }
    }, {
        "dom-serializer": 47,
        domelementtype: 36
    } ],
    46: [ function(require, module, exports) {
        var getChildren = exports.getChildren = function(elem) {
            return elem.children;
        };
        var getParent = exports.getParent = function(elem) {
            return elem.parent;
        };
        exports.getSiblings = function(elem) {
            var parent = getParent(elem);
            return parent ? getChildren(parent) : [ elem ];
        };
        exports.getAttributeValue = function(elem, name) {
            return elem.attribs && elem.attribs[name];
        };
        exports.hasAttrib = function(elem, name) {
            return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
        };
        exports.getName = function(elem) {
            return elem.name;
        };
    }, {} ],
    47: [ function(require, module, exports) {
        var ElementType = require("domelementtype");
        var entities = require("entities");
        var booleanAttributes = {
            __proto__: null,
            allowfullscreen: true,
            async: true,
            autofocus: true,
            autoplay: true,
            checked: true,
            controls: true,
            "default": true,
            defer: true,
            disabled: true,
            hidden: true,
            ismap: true,
            loop: true,
            multiple: true,
            muted: true,
            open: true,
            readonly: true,
            required: true,
            reversed: true,
            scoped: true,
            seamless: true,
            selected: true,
            typemustmatch: true
        };
        var unencodedElements = {
            __proto__: null,
            style: true,
            script: true,
            xmp: true,
            iframe: true,
            noembed: true,
            noframes: true,
            plaintext: true,
            noscript: true
        };
        function formatAttrs(attributes, opts) {
            if (!attributes) return;
            var output = "", value;
            for (var key in attributes) {
                value = attributes[key];
                if (output) {
                    output += " ";
                }
                if (!value && booleanAttributes[key]) {
                    output += key;
                } else {
                    output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
                }
            }
            return output;
        }
        var singleTag = {
            __proto__: null,
            area: true,
            base: true,
            basefont: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            frame: true,
            hr: true,
            img: true,
            input: true,
            isindex: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        var render = module.exports = function(dom, opts) {
            if (!Array.isArray(dom) && !dom.cheerio) dom = [ dom ];
            opts = opts || {};
            var output = "";
            for (var i = 0; i < dom.length; i++) {
                var elem = dom[i];
                if (elem.type === "root") output += render(elem.children, opts); else if (ElementType.isTag(elem)) output += renderTag(elem, opts); else if (elem.type === ElementType.Directive) output += renderDirective(elem); else if (elem.type === ElementType.Comment) output += renderComment(elem); else if (elem.type === ElementType.CDATA) output += renderCdata(elem); else output += renderText(elem, opts);
            }
            return output;
        };
        function renderTag(elem, opts) {
            if (elem.name === "svg") opts = {
                decodeEntities: opts.decodeEntities,
                xmlMode: true
            };
            var tag = "<" + elem.name, attribs = formatAttrs(elem.attribs, opts);
            if (attribs) {
                tag += " " + attribs;
            }
            if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
                tag += "/>";
            } else {
                tag += ">";
                if (elem.children) {
                    tag += render(elem.children, opts);
                }
                if (!singleTag[elem.name] || opts.xmlMode) {
                    tag += "</" + elem.name + ">";
                }
            }
            return tag;
        }
        function renderDirective(elem) {
            return "<" + elem.data + ">";
        }
        function renderText(elem, opts) {
            var data = elem.data || "";
            if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
                data = entities.encodeXML(data);
            }
            return data;
        }
        function renderCdata(elem) {
            return "<![CDATA[" + elem.children[0].data + "]]>";
        }
        function renderComment(elem) {
            return "<!--" + elem.data + "-->";
        }
    }, {
        domelementtype: 48,
        entities: 49
    } ],
    48: [ function(require, module, exports) {
        module.exports = {
            Text: "text",
            Directive: "directive",
            Comment: "comment",
            Script: "script",
            Style: "style",
            Tag: "tag",
            CDATA: "cdata",
            isTag: function(elem) {
                return elem.type === "tag" || elem.type === "script" || elem.type === "style";
            }
        };
    }, {} ],
    49: [ function(require, module, exports) {
        var encode = require("./lib/encode.js"), decode = require("./lib/decode.js");
        exports.decode = function(data, level) {
            return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
        };
        exports.decodeStrict = function(data, level) {
            return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
        };
        exports.encode = function(data, level) {
            return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
        };
        exports.encodeXML = encode.XML;
        exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML;
        exports.decodeXML = exports.decodeXMLStrict = decode.XML;
        exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML;
        exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict;
        exports.escape = encode.escape;
    }, {
        "./lib/decode.js": 50,
        "./lib/encode.js": 52
    } ],
    50: [ function(require, module, exports) {
        var entityMap = require("../maps/entities.json"), legacyMap = require("../maps/legacy.json"), xmlMap = require("../maps/xml.json"), decodeCodePoint = require("./decode_codepoint.js");
        var decodeXMLStrict = getStrictDecoder(xmlMap), decodeHTMLStrict = getStrictDecoder(entityMap);
        function getStrictDecoder(map) {
            var keys = Object.keys(map).join("|"), replace = getReplacer(map);
            keys += "|#[xX][\\da-fA-F]+|#\\d+";
            var re = new RegExp("&(?:" + keys + ");", "g");
            return function(str) {
                return String(str).replace(re, replace);
            };
        }
        var decodeHTML = function() {
            var legacy = Object.keys(legacyMap).sort(sorter);
            var keys = Object.keys(entityMap).sort(sorter);
            for (var i = 0, j = 0; i < keys.length; i++) {
                if (legacy[j] === keys[i]) {
                    keys[i] += ";?";
                    j++;
                } else {
                    keys[i] += ";";
                }
            }
            var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entityMap);
            function replacer(str) {
                if (str.substr(-1) !== ";") str += ";";
                return replace(str);
            }
            return function(str) {
                return String(str).replace(re, replacer);
            };
        }();
        function sorter(a, b) {
            return a < b ? 1 : -1;
        }
        function getReplacer(map) {
            return function replace(str) {
                if (str.charAt(1) === "#") {
                    if (str.charAt(2) === "X" || str.charAt(2) === "x") {
                        return decodeCodePoint(parseInt(str.substr(3), 16));
                    }
                    return decodeCodePoint(parseInt(str.substr(2), 10));
                }
                return map[str.slice(1, -1)];
            };
        }
        module.exports = {
            XML: decodeXMLStrict,
            HTML: decodeHTML,
            HTMLStrict: decodeHTMLStrict
        };
    }, {
        "../maps/entities.json": 54,
        "../maps/legacy.json": 55,
        "../maps/xml.json": 56,
        "./decode_codepoint.js": 51
    } ],
    51: [ function(require, module, exports) {
        var decodeMap = require("../maps/decode.json");
        module.exports = decodeCodePoint;
        function decodeCodePoint(codePoint) {
            if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
                return "";
            }
            if (codePoint in decodeMap) {
                codePoint = decodeMap[codePoint];
            }
            var output = "";
            if (codePoint > 65535) {
                codePoint -= 65536;
                output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
            }
            output += String.fromCharCode(codePoint);
            return output;
        }
    }, {
        "../maps/decode.json": 53
    } ],
    52: [ function(require, module, exports) {
        var inverseXML = getInverseObj(require("../maps/xml.json")), xmlReplacer = getInverseReplacer(inverseXML);
        exports.XML = getInverse(inverseXML, xmlReplacer);
        var inverseHTML = getInverseObj(require("../maps/entities.json")), htmlReplacer = getInverseReplacer(inverseHTML);
        exports.HTML = getInverse(inverseHTML, htmlReplacer);
        function getInverseObj(obj) {
            return Object.keys(obj).sort().reduce(function(inverse, name) {
                inverse[obj[name]] = "&" + name + ";";
                return inverse;
            }, {});
        }
        function getInverseReplacer(inverse) {
            var single = [], multiple = [];
            Object.keys(inverse).forEach(function(k) {
                if (k.length === 1) {
                    single.push("\\" + k);
                } else {
                    multiple.push(k);
                }
            });
            multiple.unshift("[" + single.join("") + "]");
            return new RegExp(multiple.join("|"), "g");
        }
        var re_nonASCII = /[^\0-\x7F]/g, re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        function singleCharReplacer(c) {
            return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
        }
        function astralReplacer(c) {
            var high = c.charCodeAt(0);
            var low = c.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return "&#x" + codePoint.toString(16).toUpperCase() + ";";
        }
        function getInverse(inverse, re) {
            function func(name) {
                return inverse[name];
            }
            return function(data) {
                return data.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
            };
        }
        var re_xmlChars = getInverseReplacer(inverseXML);
        function escapeXML(data) {
            return data.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
        }
        exports.escape = escapeXML;
    }, {
        "../maps/entities.json": 54,
        "../maps/xml.json": 56
    } ],
    53: [ function(require, module, exports) {
        module.exports = {
            "0": 65533,
            "128": 8364,
            "130": 8218,
            "131": 402,
            "132": 8222,
            "133": 8230,
            "134": 8224,
            "135": 8225,
            "136": 710,
            "137": 8240,
            "138": 352,
            "139": 8249,
            "140": 338,
            "142": 381,
            "145": 8216,
            "146": 8217,
            "147": 8220,
            "148": 8221,
            "149": 8226,
            "150": 8211,
            "151": 8212,
            "152": 732,
            "153": 8482,
            "154": 353,
            "155": 8250,
            "156": 339,
            "158": 382,
            "159": 376
        };
    }, {} ],
    54: [ function(require, module, exports) {
        module.exports = {
            Aacute: "",
            aacute: "",
            Abreve: "",
            abreve: "",
            ac: "",
            acd: "",
            acE: "",
            Acirc: "",
            acirc: "",
            acute: "",
            Acy: "",
            acy: "",
            AElig: "",
            aelig: "",
            af: "",
            Afr: "",
            afr: "",
            Agrave: "",
            agrave: "",
            alefsym: "",
            aleph: "",
            Alpha: "",
            alpha: "",
            Amacr: "",
            amacr: "",
            amalg: "",
            amp: "&",
            AMP: "&",
            andand: "",
            And: "",
            and: "",
            andd: "",
            andslope: "",
            andv: "",
            ang: "",
            ange: "",
            angle: "",
            angmsdaa: "",
            angmsdab: "",
            angmsdac: "",
            angmsdad: "",
            angmsdae: "",
            angmsdaf: "",
            angmsdag: "",
            angmsdah: "",
            angmsd: "",
            angrt: "",
            angrtvb: "",
            angrtvbd: "",
            angsph: "",
            angst: "",
            angzarr: "",
            Aogon: "",
            aogon: "",
            Aopf: "",
            aopf: "",
            apacir: "",
            ap: "",
            apE: "",
            ape: "",
            apid: "",
            apos: "'",
            ApplyFunction: "",
            approx: "",
            approxeq: "",
            Aring: "",
            aring: "",
            Ascr: "",
            ascr: "",
            Assign: "",
            ast: "*",
            asymp: "",
            asympeq: "",
            Atilde: "",
            atilde: "",
            Auml: "",
            auml: "",
            awconint: "",
            awint: "",
            backcong: "",
            backepsilon: "",
            backprime: "",
            backsim: "",
            backsimeq: "",
            Backslash: "",
            Barv: "",
            barvee: "",
            barwed: "",
            Barwed: "",
            barwedge: "",
            bbrk: "",
            bbrktbrk: "",
            bcong: "",
            Bcy: "",
            bcy: "",
            bdquo: "",
            becaus: "",
            because: "",
            Because: "",
            bemptyv: "",
            bepsi: "",
            bernou: "",
            Bernoullis: "",
            Beta: "",
            beta: "",
            beth: "",
            between: "",
            Bfr: "",
            bfr: "",
            bigcap: "",
            bigcirc: "",
            bigcup: "",
            bigodot: "",
            bigoplus: "",
            bigotimes: "",
            bigsqcup: "",
            bigstar: "",
            bigtriangledown: "",
            bigtriangleup: "",
            biguplus: "",
            bigvee: "",
            bigwedge: "",
            bkarow: "",
            blacklozenge: "",
            blacksquare: "",
            blacktriangle: "",
            blacktriangledown: "",
            blacktriangleleft: "",
            blacktriangleright: "",
            blank: "",
            blk12: "",
            blk14: "",
            blk34: "",
            block: "",
            bne: "=",
            bnequiv: "",
            bNot: "",
            bnot: "",
            Bopf: "",
            bopf: "",
            bot: "",
            bottom: "",
            bowtie: "",
            boxbox: "",
            boxdl: "",
            boxdL: "",
            boxDl: "",
            boxDL: "",
            boxdr: "",
            boxdR: "",
            boxDr: "",
            boxDR: "",
            boxh: "",
            boxH: "",
            boxhd: "",
            boxHd: "",
            boxhD: "",
            boxHD: "",
            boxhu: "",
            boxHu: "",
            boxhU: "",
            boxHU: "",
            boxminus: "",
            boxplus: "",
            boxtimes: "",
            boxul: "",
            boxuL: "",
            boxUl: "",
            boxUL: "",
            boxur: "",
            boxuR: "",
            boxUr: "",
            boxUR: "",
            boxv: "",
            boxV: "",
            boxvh: "",
            boxvH: "",
            boxVh: "",
            boxVH: "",
            boxvl: "",
            boxvL: "",
            boxVl: "",
            boxVL: "",
            boxvr: "",
            boxvR: "",
            boxVr: "",
            boxVR: "",
            bprime: "",
            breve: "",
            Breve: "",
            brvbar: "",
            bscr: "",
            Bscr: "",
            bsemi: "",
            bsim: "",
            bsime: "",
            bsolb: "",
            bsol: "\\",
            bsolhsub: "",
            bull: "",
            bullet: "",
            bump: "",
            bumpE: "",
            bumpe: "",
            Bumpeq: "",
            bumpeq: "",
            Cacute: "",
            cacute: "",
            capand: "",
            capbrcup: "",
            capcap: "",
            cap: "",
            Cap: "",
            capcup: "",
            capdot: "",
            CapitalDifferentialD: "",
            caps: "",
            caret: "",
            caron: "",
            Cayleys: "",
            ccaps: "",
            Ccaron: "",
            ccaron: "",
            Ccedil: "",
            ccedil: "",
            Ccirc: "",
            ccirc: "",
            Cconint: "",
            ccups: "",
            ccupssm: "",
            Cdot: "",
            cdot: "",
            cedil: "",
            Cedilla: "",
            cemptyv: "",
            cent: "",
            centerdot: "",
            CenterDot: "",
            cfr: "",
            Cfr: "",
            CHcy: "",
            chcy: "",
            check: "",
            checkmark: "",
            Chi: "",
            chi: "",
            circ: "",
            circeq: "",
            circlearrowleft: "",
            circlearrowright: "",
            circledast: "",
            circledcirc: "",
            circleddash: "",
            CircleDot: "",
            circledR: "",
            circledS: "",
            CircleMinus: "",
            CirclePlus: "",
            CircleTimes: "",
            cir: "",
            cirE: "",
            cire: "",
            cirfnint: "",
            cirmid: "",
            cirscir: "",
            ClockwiseContourIntegral: "",
            CloseCurlyDoubleQuote: "",
            CloseCurlyQuote: "",
            clubs: "",
            clubsuit: "",
            colon: ":",
            Colon: "",
            Colone: "",
            colone: "",
            coloneq: "",
            comma: ",",
            commat: "@",
            comp: "",
            compfn: "",
            complement: "",
            complexes: "",
            cong: "",
            congdot: "",
            Congruent: "",
            conint: "",
            Conint: "",
            ContourIntegral: "",
            copf: "",
            Copf: "",
            coprod: "",
            Coproduct: "",
            copy: "",
            COPY: "",
            copysr: "",
            CounterClockwiseContourIntegral: "",
            crarr: "",
            cross: "",
            Cross: "",
            Cscr: "",
            cscr: "",
            csub: "",
            csube: "",
            csup: "",
            csupe: "",
            ctdot: "",
            cudarrl: "",
            cudarrr: "",
            cuepr: "",
            cuesc: "",
            cularr: "",
            cularrp: "",
            cupbrcap: "",
            cupcap: "",
            CupCap: "",
            cup: "",
            Cup: "",
            cupcup: "",
            cupdot: "",
            cupor: "",
            cups: "",
            curarr: "",
            curarrm: "",
            curlyeqprec: "",
            curlyeqsucc: "",
            curlyvee: "",
            curlywedge: "",
            curren: "",
            curvearrowleft: "",
            curvearrowright: "",
            cuvee: "",
            cuwed: "",
            cwconint: "",
            cwint: "",
            cylcty: "",
            dagger: "",
            Dagger: "",
            daleth: "",
            darr: "",
            Darr: "",
            dArr: "",
            dash: "",
            Dashv: "",
            dashv: "",
            dbkarow: "",
            dblac: "",
            Dcaron: "",
            dcaron: "",
            Dcy: "",
            dcy: "",
            ddagger: "",
            ddarr: "",
            DD: "",
            dd: "",
            DDotrahd: "",
            ddotseq: "",
            deg: "",
            Del: "",
            Delta: "",
            delta: "",
            demptyv: "",
            dfisht: "",
            Dfr: "",
            dfr: "",
            dHar: "",
            dharl: "",
            dharr: "",
            DiacriticalAcute: "",
            DiacriticalDot: "",
            DiacriticalDoubleAcute: "",
            DiacriticalGrave: "`",
            DiacriticalTilde: "",
            diam: "",
            diamond: "",
            Diamond: "",
            diamondsuit: "",
            diams: "",
            die: "",
            DifferentialD: "",
            digamma: "",
            disin: "",
            div: "",
            divide: "",
            divideontimes: "",
            divonx: "",
            DJcy: "",
            djcy: "",
            dlcorn: "",
            dlcrop: "",
            dollar: "$",
            Dopf: "",
            dopf: "",
            Dot: "",
            dot: "",
            DotDot: "",
            doteq: "",
            doteqdot: "",
            DotEqual: "",
            dotminus: "",
            dotplus: "",
            dotsquare: "",
            doublebarwedge: "",
            DoubleContourIntegral: "",
            DoubleDot: "",
            DoubleDownArrow: "",
            DoubleLeftArrow: "",
            DoubleLeftRightArrow: "",
            DoubleLeftTee: "",
            DoubleLongLeftArrow: "",
            DoubleLongLeftRightArrow: "",
            DoubleLongRightArrow: "",
            DoubleRightArrow: "",
            DoubleRightTee: "",
            DoubleUpArrow: "",
            DoubleUpDownArrow: "",
            DoubleVerticalBar: "",
            DownArrowBar: "",
            downarrow: "",
            DownArrow: "",
            Downarrow: "",
            DownArrowUpArrow: "",
            DownBreve: "",
            downdownarrows: "",
            downharpoonleft: "",
            downharpoonright: "",
            DownLeftRightVector: "",
            DownLeftTeeVector: "",
            DownLeftVectorBar: "",
            DownLeftVector: "",
            DownRightTeeVector: "",
            DownRightVectorBar: "",
            DownRightVector: "",
            DownTeeArrow: "",
            DownTee: "",
            drbkarow: "",
            drcorn: "",
            drcrop: "",
            Dscr: "",
            dscr: "",
            DScy: "",
            dscy: "",
            dsol: "",
            Dstrok: "",
            dstrok: "",
            dtdot: "",
            dtri: "",
            dtrif: "",
            duarr: "",
            duhar: "",
            dwangle: "",
            DZcy: "",
            dzcy: "",
            dzigrarr: "",
            Eacute: "",
            eacute: "",
            easter: "",
            Ecaron: "",
            ecaron: "",
            Ecirc: "",
            ecirc: "",
            ecir: "",
            ecolon: "",
            Ecy: "",
            ecy: "",
            eDDot: "",
            Edot: "",
            edot: "",
            eDot: "",
            ee: "",
            efDot: "",
            Efr: "",
            efr: "",
            eg: "",
            Egrave: "",
            egrave: "",
            egs: "",
            egsdot: "",
            el: "",
            Element: "",
            elinters: "",
            ell: "",
            els: "",
            elsdot: "",
            Emacr: "",
            emacr: "",
            empty: "",
            emptyset: "",
            EmptySmallSquare: "",
            emptyv: "",
            EmptyVerySmallSquare: "",
            emsp13: "",
            emsp14: "",
            emsp: "",
            ENG: "",
            eng: "",
            ensp: "",
            Eogon: "",
            eogon: "",
            Eopf: "",
            eopf: "",
            epar: "",
            eparsl: "",
            eplus: "",
            epsi: "",
            Epsilon: "",
            epsilon: "",
            epsiv: "",
            eqcirc: "",
            eqcolon: "",
            eqsim: "",
            eqslantgtr: "",
            eqslantless: "",
            Equal: "",
            equals: "=",
            EqualTilde: "",
            equest: "",
            Equilibrium: "",
            equiv: "",
            equivDD: "",
            eqvparsl: "",
            erarr: "",
            erDot: "",
            escr: "",
            Escr: "",
            esdot: "",
            Esim: "",
            esim: "",
            Eta: "",
            eta: "",
            ETH: "",
            eth: "",
            Euml: "",
            euml: "",
            euro: "",
            excl: "!",
            exist: "",
            Exists: "",
            expectation: "",
            exponentiale: "",
            ExponentialE: "",
            fallingdotseq: "",
            Fcy: "",
            fcy: "",
            female: "",
            ffilig: "",
            fflig: "",
            ffllig: "",
            Ffr: "",
            ffr: "",
            filig: "",
            FilledSmallSquare: "",
            FilledVerySmallSquare: "",
            fjlig: "fj",
            flat: "",
            fllig: "",
            fltns: "",
            fnof: "",
            Fopf: "",
            fopf: "",
            forall: "",
            ForAll: "",
            fork: "",
            forkv: "",
            Fouriertrf: "",
            fpartint: "",
            frac12: "",
            frac13: "",
            frac14: "",
            frac15: "",
            frac16: "",
            frac18: "",
            frac23: "",
            frac25: "",
            frac34: "",
            frac35: "",
            frac38: "",
            frac45: "",
            frac56: "",
            frac58: "",
            frac78: "",
            frasl: "",
            frown: "",
            fscr: "",
            Fscr: "",
            gacute: "",
            Gamma: "",
            gamma: "",
            Gammad: "",
            gammad: "",
            gap: "",
            Gbreve: "",
            gbreve: "",
            Gcedil: "",
            Gcirc: "",
            gcirc: "",
            Gcy: "",
            gcy: "",
            Gdot: "",
            gdot: "",
            ge: "",
            gE: "",
            gEl: "",
            gel: "",
            geq: "",
            geqq: "",
            geqslant: "",
            gescc: "",
            ges: "",
            gesdot: "",
            gesdoto: "",
            gesdotol: "",
            gesl: "",
            gesles: "",
            Gfr: "",
            gfr: "",
            gg: "",
            Gg: "",
            ggg: "",
            gimel: "",
            GJcy: "",
            gjcy: "",
            gla: "",
            gl: "",
            glE: "",
            glj: "",
            gnap: "",
            gnapprox: "",
            gne: "",
            gnE: "",
            gneq: "",
            gneqq: "",
            gnsim: "",
            Gopf: "",
            gopf: "",
            grave: "`",
            GreaterEqual: "",
            GreaterEqualLess: "",
            GreaterFullEqual: "",
            GreaterGreater: "",
            GreaterLess: "",
            GreaterSlantEqual: "",
            GreaterTilde: "",
            Gscr: "",
            gscr: "",
            gsim: "",
            gsime: "",
            gsiml: "",
            gtcc: "",
            gtcir: "",
            gt: ">",
            GT: ">",
            Gt: "",
            gtdot: "",
            gtlPar: "",
            gtquest: "",
            gtrapprox: "",
            gtrarr: "",
            gtrdot: "",
            gtreqless: "",
            gtreqqless: "",
            gtrless: "",
            gtrsim: "",
            gvertneqq: "",
            gvnE: "",
            Hacek: "",
            hairsp: "",
            half: "",
            hamilt: "",
            HARDcy: "",
            hardcy: "",
            harrcir: "",
            harr: "",
            hArr: "",
            harrw: "",
            Hat: "^",
            hbar: "",
            Hcirc: "",
            hcirc: "",
            hearts: "",
            heartsuit: "",
            hellip: "",
            hercon: "",
            hfr: "",
            Hfr: "",
            HilbertSpace: "",
            hksearow: "",
            hkswarow: "",
            hoarr: "",
            homtht: "",
            hookleftarrow: "",
            hookrightarrow: "",
            hopf: "",
            Hopf: "",
            horbar: "",
            HorizontalLine: "",
            hscr: "",
            Hscr: "",
            hslash: "",
            Hstrok: "",
            hstrok: "",
            HumpDownHump: "",
            HumpEqual: "",
            hybull: "",
            hyphen: "",
            Iacute: "",
            iacute: "",
            ic: "",
            Icirc: "",
            icirc: "",
            Icy: "",
            icy: "",
            Idot: "",
            IEcy: "",
            iecy: "",
            iexcl: "",
            iff: "",
            ifr: "",
            Ifr: "",
            Igrave: "",
            igrave: "",
            ii: "",
            iiiint: "",
            iiint: "",
            iinfin: "",
            iiota: "",
            IJlig: "",
            ijlig: "",
            Imacr: "",
            imacr: "",
            image: "",
            ImaginaryI: "",
            imagline: "",
            imagpart: "",
            imath: "",
            Im: "",
            imof: "",
            imped: "",
            Implies: "",
            incare: "",
            "in": "",
            infin: "",
            infintie: "",
            inodot: "",
            intcal: "",
            "int": "",
            Int: "",
            integers: "",
            Integral: "",
            intercal: "",
            Intersection: "",
            intlarhk: "",
            intprod: "",
            InvisibleComma: "",
            InvisibleTimes: "",
            IOcy: "",
            iocy: "",
            Iogon: "",
            iogon: "",
            Iopf: "",
            iopf: "",
            Iota: "",
            iota: "",
            iprod: "",
            iquest: "",
            iscr: "",
            Iscr: "",
            isin: "",
            isindot: "",
            isinE: "",
            isins: "",
            isinsv: "",
            isinv: "",
            it: "",
            Itilde: "",
            itilde: "",
            Iukcy: "",
            iukcy: "",
            Iuml: "",
            iuml: "",
            Jcirc: "",
            jcirc: "",
            Jcy: "",
            jcy: "",
            Jfr: "",
            jfr: "",
            jmath: "",
            Jopf: "",
            jopf: "",
            Jscr: "",
            jscr: "",
            Jsercy: "",
            jsercy: "",
            Jukcy: "",
            jukcy: "",
            Kappa: "",
            kappa: "",
            kappav: "",
            Kcedil: "",
            kcedil: "",
            Kcy: "",
            kcy: "",
            Kfr: "",
            kfr: "",
            kgreen: "",
            KHcy: "",
            khcy: "",
            KJcy: "",
            kjcy: "",
            Kopf: "",
            kopf: "",
            Kscr: "",
            kscr: "",
            lAarr: "",
            Lacute: "",
            lacute: "",
            laemptyv: "",
            lagran: "",
            Lambda: "",
            lambda: "",
            lang: "",
            Lang: "",
            langd: "",
            langle: "",
            lap: "",
            Laplacetrf: "",
            laquo: "",
            larrb: "",
            larrbfs: "",
            larr: "",
            Larr: "",
            lArr: "",
            larrfs: "",
            larrhk: "",
            larrlp: "",
            larrpl: "",
            larrsim: "",
            larrtl: "",
            latail: "",
            lAtail: "",
            lat: "",
            late: "",
            lates: "",
            lbarr: "",
            lBarr: "",
            lbbrk: "",
            lbrace: "{",
            lbrack: "[",
            lbrke: "",
            lbrksld: "",
            lbrkslu: "",
            Lcaron: "",
            lcaron: "",
            Lcedil: "",
            lcedil: "",
            lceil: "",
            lcub: "{",
            Lcy: "",
            lcy: "",
            ldca: "",
            ldquo: "",
            ldquor: "",
            ldrdhar: "",
            ldrushar: "",
            ldsh: "",
            le: "",
            lE: "",
            LeftAngleBracket: "",
            LeftArrowBar: "",
            leftarrow: "",
            LeftArrow: "",
            Leftarrow: "",
            LeftArrowRightArrow: "",
            leftarrowtail: "",
            LeftCeiling: "",
            LeftDoubleBracket: "",
            LeftDownTeeVector: "",
            LeftDownVectorBar: "",
            LeftDownVector: "",
            LeftFloor: "",
            leftharpoondown: "",
            leftharpoonup: "",
            leftleftarrows: "",
            leftrightarrow: "",
            LeftRightArrow: "",
            Leftrightarrow: "",
            leftrightarrows: "",
            leftrightharpoons: "",
            leftrightsquigarrow: "",
            LeftRightVector: "",
            LeftTeeArrow: "",
            LeftTee: "",
            LeftTeeVector: "",
            leftthreetimes: "",
            LeftTriangleBar: "",
            LeftTriangle: "",
            LeftTriangleEqual: "",
            LeftUpDownVector: "",
            LeftUpTeeVector: "",
            LeftUpVectorBar: "",
            LeftUpVector: "",
            LeftVectorBar: "",
            LeftVector: "",
            lEg: "",
            leg: "",
            leq: "",
            leqq: "",
            leqslant: "",
            lescc: "",
            les: "",
            lesdot: "",
            lesdoto: "",
            lesdotor: "",
            lesg: "",
            lesges: "",
            lessapprox: "",
            lessdot: "",
            lesseqgtr: "",
            lesseqqgtr: "",
            LessEqualGreater: "",
            LessFullEqual: "",
            LessGreater: "",
            lessgtr: "",
            LessLess: "",
            lesssim: "",
            LessSlantEqual: "",
            LessTilde: "",
            lfisht: "",
            lfloor: "",
            Lfr: "",
            lfr: "",
            lg: "",
            lgE: "",
            lHar: "",
            lhard: "",
            lharu: "",
            lharul: "",
            lhblk: "",
            LJcy: "",
            ljcy: "",
            llarr: "",
            ll: "",
            Ll: "",
            llcorner: "",
            Lleftarrow: "",
            llhard: "",
            lltri: "",
            Lmidot: "",
            lmidot: "",
            lmoustache: "",
            lmoust: "",
            lnap: "",
            lnapprox: "",
            lne: "",
            lnE: "",
            lneq: "",
            lneqq: "",
            lnsim: "",
            loang: "",
            loarr: "",
            lobrk: "",
            longleftarrow: "",
            LongLeftArrow: "",
            Longleftarrow: "",
            longleftrightarrow: "",
            LongLeftRightArrow: "",
            Longleftrightarrow: "",
            longmapsto: "",
            longrightarrow: "",
            LongRightArrow: "",
            Longrightarrow: "",
            looparrowleft: "",
            looparrowright: "",
            lopar: "",
            Lopf: "",
            lopf: "",
            loplus: "",
            lotimes: "",
            lowast: "",
            lowbar: "_",
            LowerLeftArrow: "",
            LowerRightArrow: "",
            loz: "",
            lozenge: "",
            lozf: "",
            lpar: "(",
            lparlt: "",
            lrarr: "",
            lrcorner: "",
            lrhar: "",
            lrhard: "",
            lrm: "",
            lrtri: "",
            lsaquo: "",
            lscr: "",
            Lscr: "",
            lsh: "",
            Lsh: "",
            lsim: "",
            lsime: "",
            lsimg: "",
            lsqb: "[",
            lsquo: "",
            lsquor: "",
            Lstrok: "",
            lstrok: "",
            ltcc: "",
            ltcir: "",
            lt: "<",
            LT: "<",
            Lt: "",
            ltdot: "",
            lthree: "",
            ltimes: "",
            ltlarr: "",
            ltquest: "",
            ltri: "",
            ltrie: "",
            ltrif: "",
            ltrPar: "",
            lurdshar: "",
            luruhar: "",
            lvertneqq: "",
            lvnE: "",
            macr: "",
            male: "",
            malt: "",
            maltese: "",
            Map: "",
            map: "",
            mapsto: "",
            mapstodown: "",
            mapstoleft: "",
            mapstoup: "",
            marker: "",
            mcomma: "",
            Mcy: "",
            mcy: "",
            mdash: "",
            mDDot: "",
            measuredangle: "",
            MediumSpace: "",
            Mellintrf: "",
            Mfr: "",
            mfr: "",
            mho: "",
            micro: "",
            midast: "*",
            midcir: "",
            mid: "",
            middot: "",
            minusb: "",
            minus: "",
            minusd: "",
            minusdu: "",
            MinusPlus: "",
            mlcp: "",
            mldr: "",
            mnplus: "",
            models: "",
            Mopf: "",
            mopf: "",
            mp: "",
            mscr: "",
            Mscr: "",
            mstpos: "",
            Mu: "",
            mu: "",
            multimap: "",
            mumap: "",
            nabla: "",
            Nacute: "",
            nacute: "",
            nang: "",
            nap: "",
            napE: "",
            napid: "",
            napos: "",
            napprox: "",
            natural: "",
            naturals: "",
            natur: "",
            nbsp: "",
            nbump: "",
            nbumpe: "",
            ncap: "",
            Ncaron: "",
            ncaron: "",
            Ncedil: "",
            ncedil: "",
            ncong: "",
            ncongdot: "",
            ncup: "",
            Ncy: "",
            ncy: "",
            ndash: "",
            nearhk: "",
            nearr: "",
            neArr: "",
            nearrow: "",
            ne: "",
            nedot: "",
            NegativeMediumSpace: "",
            NegativeThickSpace: "",
            NegativeThinSpace: "",
            NegativeVeryThinSpace: "",
            nequiv: "",
            nesear: "",
            nesim: "",
            NestedGreaterGreater: "",
            NestedLessLess: "",
            NewLine: "\n",
            nexist: "",
            nexists: "",
            Nfr: "",
            nfr: "",
            ngE: "",
            nge: "",
            ngeq: "",
            ngeqq: "",
            ngeqslant: "",
            nges: "",
            nGg: "",
            ngsim: "",
            nGt: "",
            ngt: "",
            ngtr: "",
            nGtv: "",
            nharr: "",
            nhArr: "",
            nhpar: "",
            ni: "",
            nis: "",
            nisd: "",
            niv: "",
            NJcy: "",
            njcy: "",
            nlarr: "",
            nlArr: "",
            nldr: "",
            nlE: "",
            nle: "",
            nleftarrow: "",
            nLeftarrow: "",
            nleftrightarrow: "",
            nLeftrightarrow: "",
            nleq: "",
            nleqq: "",
            nleqslant: "",
            nles: "",
            nless: "",
            nLl: "",
            nlsim: "",
            nLt: "",
            nlt: "",
            nltri: "",
            nltrie: "",
            nLtv: "",
            nmid: "",
            NoBreak: "",
            NonBreakingSpace: "",
            nopf: "",
            Nopf: "",
            Not: "",
            not: "",
            NotCongruent: "",
            NotCupCap: "",
            NotDoubleVerticalBar: "",
            NotElement: "",
            NotEqual: "",
            NotEqualTilde: "",
            NotExists: "",
            NotGreater: "",
            NotGreaterEqual: "",
            NotGreaterFullEqual: "",
            NotGreaterGreater: "",
            NotGreaterLess: "",
            NotGreaterSlantEqual: "",
            NotGreaterTilde: "",
            NotHumpDownHump: "",
            NotHumpEqual: "",
            notin: "",
            notindot: "",
            notinE: "",
            notinva: "",
            notinvb: "",
            notinvc: "",
            NotLeftTriangleBar: "",
            NotLeftTriangle: "",
            NotLeftTriangleEqual: "",
            NotLess: "",
            NotLessEqual: "",
            NotLessGreater: "",
            NotLessLess: "",
            NotLessSlantEqual: "",
            NotLessTilde: "",
            NotNestedGreaterGreater: "",
            NotNestedLessLess: "",
            notni: "",
            notniva: "",
            notnivb: "",
            notnivc: "",
            NotPrecedes: "",
            NotPrecedesEqual: "",
            NotPrecedesSlantEqual: "",
            NotReverseElement: "",
            NotRightTriangleBar: "",
            NotRightTriangle: "",
            NotRightTriangleEqual: "",
            NotSquareSubset: "",
            NotSquareSubsetEqual: "",
            NotSquareSuperset: "",
            NotSquareSupersetEqual: "",
            NotSubset: "",
            NotSubsetEqual: "",
            NotSucceeds: "",
            NotSucceedsEqual: "",
            NotSucceedsSlantEqual: "",
            NotSucceedsTilde: "",
            NotSuperset: "",
            NotSupersetEqual: "",
            NotTilde: "",
            NotTildeEqual: "",
            NotTildeFullEqual: "",
            NotTildeTilde: "",
            NotVerticalBar: "",
            nparallel: "",
            npar: "",
            nparsl: "",
            npart: "",
            npolint: "",
            npr: "",
            nprcue: "",
            nprec: "",
            npreceq: "",
            npre: "",
            nrarrc: "",
            nrarr: "",
            nrArr: "",
            nrarrw: "",
            nrightarrow: "",
            nRightarrow: "",
            nrtri: "",
            nrtrie: "",
            nsc: "",
            nsccue: "",
            nsce: "",
            Nscr: "",
            nscr: "",
            nshortmid: "",
            nshortparallel: "",
            nsim: "",
            nsime: "",
            nsimeq: "",
            nsmid: "",
            nspar: "",
            nsqsube: "",
            nsqsupe: "",
            nsub: "",
            nsubE: "",
            nsube: "",
            nsubset: "",
            nsubseteq: "",
            nsubseteqq: "",
            nsucc: "",
            nsucceq: "",
            nsup: "",
            nsupE: "",
            nsupe: "",
            nsupset: "",
            nsupseteq: "",
            nsupseteqq: "",
            ntgl: "",
            Ntilde: "",
            ntilde: "",
            ntlg: "",
            ntriangleleft: "",
            ntrianglelefteq: "",
            ntriangleright: "",
            ntrianglerighteq: "",
            Nu: "",
            nu: "",
            num: "#",
            numero: "",
            numsp: "",
            nvap: "",
            nvdash: "",
            nvDash: "",
            nVdash: "",
            nVDash: "",
            nvge: "",
            nvgt: ">",
            nvHarr: "",
            nvinfin: "",
            nvlArr: "",
            nvle: "",
            nvlt: "<",
            nvltrie: "",
            nvrArr: "",
            nvrtrie: "",
            nvsim: "",
            nwarhk: "",
            nwarr: "",
            nwArr: "",
            nwarrow: "",
            nwnear: "",
            Oacute: "",
            oacute: "",
            oast: "",
            Ocirc: "",
            ocirc: "",
            ocir: "",
            Ocy: "",
            ocy: "",
            odash: "",
            Odblac: "",
            odblac: "",
            odiv: "",
            odot: "",
            odsold: "",
            OElig: "",
            oelig: "",
            ofcir: "",
            Ofr: "",
            ofr: "",
            ogon: "",
            Ograve: "",
            ograve: "",
            ogt: "",
            ohbar: "",
            ohm: "",
            oint: "",
            olarr: "",
            olcir: "",
            olcross: "",
            oline: "",
            olt: "",
            Omacr: "",
            omacr: "",
            Omega: "",
            omega: "",
            Omicron: "",
            omicron: "",
            omid: "",
            ominus: "",
            Oopf: "",
            oopf: "",
            opar: "",
            OpenCurlyDoubleQuote: "",
            OpenCurlyQuote: "",
            operp: "",
            oplus: "",
            orarr: "",
            Or: "",
            or: "",
            ord: "",
            order: "",
            orderof: "",
            ordf: "",
            ordm: "",
            origof: "",
            oror: "",
            orslope: "",
            orv: "",
            oS: "",
            Oscr: "",
            oscr: "",
            Oslash: "",
            oslash: "",
            osol: "",
            Otilde: "",
            otilde: "",
            otimesas: "",
            Otimes: "",
            otimes: "",
            Ouml: "",
            ouml: "",
            ovbar: "",
            OverBar: "",
            OverBrace: "",
            OverBracket: "",
            OverParenthesis: "",
            para: "",
            parallel: "",
            par: "",
            parsim: "",
            parsl: "",
            part: "",
            PartialD: "",
            Pcy: "",
            pcy: "",
            percnt: "%",
            period: ".",
            permil: "",
            perp: "",
            pertenk: "",
            Pfr: "",
            pfr: "",
            Phi: "",
            phi: "",
            phiv: "",
            phmmat: "",
            phone: "",
            Pi: "",
            pi: "",
            pitchfork: "",
            piv: "",
            planck: "",
            planckh: "",
            plankv: "",
            plusacir: "",
            plusb: "",
            pluscir: "",
            plus: "+",
            plusdo: "",
            plusdu: "",
            pluse: "",
            PlusMinus: "",
            plusmn: "",
            plussim: "",
            plustwo: "",
            pm: "",
            Poincareplane: "",
            pointint: "",
            popf: "",
            Popf: "",
            pound: "",
            prap: "",
            Pr: "",
            pr: "",
            prcue: "",
            precapprox: "",
            prec: "",
            preccurlyeq: "",
            Precedes: "",
            PrecedesEqual: "",
            PrecedesSlantEqual: "",
            PrecedesTilde: "",
            preceq: "",
            precnapprox: "",
            precneqq: "",
            precnsim: "",
            pre: "",
            prE: "",
            precsim: "",
            prime: "",
            Prime: "",
            primes: "",
            prnap: "",
            prnE: "",
            prnsim: "",
            prod: "",
            Product: "",
            profalar: "",
            profline: "",
            profsurf: "",
            prop: "",
            Proportional: "",
            Proportion: "",
            propto: "",
            prsim: "",
            prurel: "",
            Pscr: "",
            pscr: "",
            Psi: "",
            psi: "",
            puncsp: "",
            Qfr: "",
            qfr: "",
            qint: "",
            qopf: "",
            Qopf: "",
            qprime: "",
            Qscr: "",
            qscr: "",
            quaternions: "",
            quatint: "",
            quest: "?",
            questeq: "",
            quot: '"',
            QUOT: '"',
            rAarr: "",
            race: "",
            Racute: "",
            racute: "",
            radic: "",
            raemptyv: "",
            rang: "",
            Rang: "",
            rangd: "",
            range: "",
            rangle: "",
            raquo: "",
            rarrap: "",
            rarrb: "",
            rarrbfs: "",
            rarrc: "",
            rarr: "",
            Rarr: "",
            rArr: "",
            rarrfs: "",
            rarrhk: "",
            rarrlp: "",
            rarrpl: "",
            rarrsim: "",
            Rarrtl: "",
            rarrtl: "",
            rarrw: "",
            ratail: "",
            rAtail: "",
            ratio: "",
            rationals: "",
            rbarr: "",
            rBarr: "",
            RBarr: "",
            rbbrk: "",
            rbrace: "}",
            rbrack: "]",
            rbrke: "",
            rbrksld: "",
            rbrkslu: "",
            Rcaron: "",
            rcaron: "",
            Rcedil: "",
            rcedil: "",
            rceil: "",
            rcub: "}",
            Rcy: "",
            rcy: "",
            rdca: "",
            rdldhar: "",
            rdquo: "",
            rdquor: "",
            rdsh: "",
            real: "",
            realine: "",
            realpart: "",
            reals: "",
            Re: "",
            rect: "",
            reg: "",
            REG: "",
            ReverseElement: "",
            ReverseEquilibrium: "",
            ReverseUpEquilibrium: "",
            rfisht: "",
            rfloor: "",
            rfr: "",
            Rfr: "",
            rHar: "",
            rhard: "",
            rharu: "",
            rharul: "",
            Rho: "",
            rho: "",
            rhov: "",
            RightAngleBracket: "",
            RightArrowBar: "",
            rightarrow: "",
            RightArrow: "",
            Rightarrow: "",
            RightArrowLeftArrow: "",
            rightarrowtail: "",
            RightCeiling: "",
            RightDoubleBracket: "",
            RightDownTeeVector: "",
            RightDownVectorBar: "",
            RightDownVector: "",
            RightFloor: "",
            rightharpoondown: "",
            rightharpoonup: "",
            rightleftarrows: "",
            rightleftharpoons: "",
            rightrightarrows: "",
            rightsquigarrow: "",
            RightTeeArrow: "",
            RightTee: "",
            RightTeeVector: "",
            rightthreetimes: "",
            RightTriangleBar: "",
            RightTriangle: "",
            RightTriangleEqual: "",
            RightUpDownVector: "",
            RightUpTeeVector: "",
            RightUpVectorBar: "",
            RightUpVector: "",
            RightVectorBar: "",
            RightVector: "",
            ring: "",
            risingdotseq: "",
            rlarr: "",
            rlhar: "",
            rlm: "",
            rmoustache: "",
            rmoust: "",
            rnmid: "",
            roang: "",
            roarr: "",
            robrk: "",
            ropar: "",
            ropf: "",
            Ropf: "",
            roplus: "",
            rotimes: "",
            RoundImplies: "",
            rpar: ")",
            rpargt: "",
            rppolint: "",
            rrarr: "",
            Rrightarrow: "",
            rsaquo: "",
            rscr: "",
            Rscr: "",
            rsh: "",
            Rsh: "",
            rsqb: "]",
            rsquo: "",
            rsquor: "",
            rthree: "",
            rtimes: "",
            rtri: "",
            rtrie: "",
            rtrif: "",
            rtriltri: "",
            RuleDelayed: "",
            ruluhar: "",
            rx: "",
            Sacute: "",
            sacute: "",
            sbquo: "",
            scap: "",
            Scaron: "",
            scaron: "",
            Sc: "",
            sc: "",
            sccue: "",
            sce: "",
            scE: "",
            Scedil: "",
            scedil: "",
            Scirc: "",
            scirc: "",
            scnap: "",
            scnE: "",
            scnsim: "",
            scpolint: "",
            scsim: "",
            Scy: "",
            scy: "",
            sdotb: "",
            sdot: "",
            sdote: "",
            searhk: "",
            searr: "",
            seArr: "",
            searrow: "",
            sect: "",
            semi: ";",
            seswar: "",
            setminus: "",
            setmn: "",
            sext: "",
            Sfr: "",
            sfr: "",
            sfrown: "",
            sharp: "",
            SHCHcy: "",
            shchcy: "",
            SHcy: "",
            shcy: "",
            ShortDownArrow: "",
            ShortLeftArrow: "",
            shortmid: "",
            shortparallel: "",
            ShortRightArrow: "",
            ShortUpArrow: "",
            shy: "",
            Sigma: "",
            sigma: "",
            sigmaf: "",
            sigmav: "",
            sim: "",
            simdot: "",
            sime: "",
            simeq: "",
            simg: "",
            simgE: "",
            siml: "",
            simlE: "",
            simne: "",
            simplus: "",
            simrarr: "",
            slarr: "",
            SmallCircle: "",
            smallsetminus: "",
            smashp: "",
            smeparsl: "",
            smid: "",
            smile: "",
            smt: "",
            smte: "",
            smtes: "",
            SOFTcy: "",
            softcy: "",
            solbar: "",
            solb: "",
            sol: "/",
            Sopf: "",
            sopf: "",
            spades: "",
            spadesuit: "",
            spar: "",
            sqcap: "",
            sqcaps: "",
            sqcup: "",
            sqcups: "",
            Sqrt: "",
            sqsub: "",
            sqsube: "",
            sqsubset: "",
            sqsubseteq: "",
            sqsup: "",
            sqsupe: "",
            sqsupset: "",
            sqsupseteq: "",
            square: "",
            Square: "",
            SquareIntersection: "",
            SquareSubset: "",
            SquareSubsetEqual: "",
            SquareSuperset: "",
            SquareSupersetEqual: "",
            SquareUnion: "",
            squarf: "",
            squ: "",
            squf: "",
            srarr: "",
            Sscr: "",
            sscr: "",
            ssetmn: "",
            ssmile: "",
            sstarf: "",
            Star: "",
            star: "",
            starf: "",
            straightepsilon: "",
            straightphi: "",
            strns: "",
            sub: "",
            Sub: "",
            subdot: "",
            subE: "",
            sube: "",
            subedot: "",
            submult: "",
            subnE: "",
            subne: "",
            subplus: "",
            subrarr: "",
            subset: "",
            Subset: "",
            subseteq: "",
            subseteqq: "",
            SubsetEqual: "",
            subsetneq: "",
            subsetneqq: "",
            subsim: "",
            subsub: "",
            subsup: "",
            succapprox: "",
            succ: "",
            succcurlyeq: "",
            Succeeds: "",
            SucceedsEqual: "",
            SucceedsSlantEqual: "",
            SucceedsTilde: "",
            succeq: "",
            succnapprox: "",
            succneqq: "",
            succnsim: "",
            succsim: "",
            SuchThat: "",
            sum: "",
            Sum: "",
            sung: "",
            sup1: "",
            sup2: "",
            sup3: "",
            sup: "",
            Sup: "",
            supdot: "",
            supdsub: "",
            supE: "",
            supe: "",
            supedot: "",
            Superset: "",
            SupersetEqual: "",
            suphsol: "",
            suphsub: "",
            suplarr: "",
            supmult: "",
            supnE: "",
            supne: "",
            supplus: "",
            supset: "",
            Supset: "",
            supseteq: "",
            supseteqq: "",
            supsetneq: "",
            supsetneqq: "",
            supsim: "",
            supsub: "",
            supsup: "",
            swarhk: "",
            swarr: "",
            swArr: "",
            swarrow: "",
            swnwar: "",
            szlig: "",
            Tab: "	",
            target: "",
            Tau: "",
            tau: "",
            tbrk: "",
            Tcaron: "",
            tcaron: "",
            Tcedil: "",
            tcedil: "",
            Tcy: "",
            tcy: "",
            tdot: "",
            telrec: "",
            Tfr: "",
            tfr: "",
            there4: "",
            therefore: "",
            Therefore: "",
            Theta: "",
            theta: "",
            thetasym: "",
            thetav: "",
            thickapprox: "",
            thicksim: "",
            ThickSpace: "",
            ThinSpace: "",
            thinsp: "",
            thkap: "",
            thksim: "",
            THORN: "",
            thorn: "",
            tilde: "",
            Tilde: "",
            TildeEqual: "",
            TildeFullEqual: "",
            TildeTilde: "",
            timesbar: "",
            timesb: "",
            times: "",
            timesd: "",
            tint: "",
            toea: "",
            topbot: "",
            topcir: "",
            top: "",
            Topf: "",
            topf: "",
            topfork: "",
            tosa: "",
            tprime: "",
            trade: "",
            TRADE: "",
            triangle: "",
            triangledown: "",
            triangleleft: "",
            trianglelefteq: "",
            triangleq: "",
            triangleright: "",
            trianglerighteq: "",
            tridot: "",
            trie: "",
            triminus: "",
            TripleDot: "",
            triplus: "",
            trisb: "",
            tritime: "",
            trpezium: "",
            Tscr: "",
            tscr: "",
            TScy: "",
            tscy: "",
            TSHcy: "",
            tshcy: "",
            Tstrok: "",
            tstrok: "",
            twixt: "",
            twoheadleftarrow: "",
            twoheadrightarrow: "",
            Uacute: "",
            uacute: "",
            uarr: "",
            Uarr: "",
            uArr: "",
            Uarrocir: "",
            Ubrcy: "",
            ubrcy: "",
            Ubreve: "",
            ubreve: "",
            Ucirc: "",
            ucirc: "",
            Ucy: "",
            ucy: "",
            udarr: "",
            Udblac: "",
            udblac: "",
            udhar: "",
            ufisht: "",
            Ufr: "",
            ufr: "",
            Ugrave: "",
            ugrave: "",
            uHar: "",
            uharl: "",
            uharr: "",
            uhblk: "",
            ulcorn: "",
            ulcorner: "",
            ulcrop: "",
            ultri: "",
            Umacr: "",
            umacr: "",
            uml: "",
            UnderBar: "_",
            UnderBrace: "",
            UnderBracket: "",
            UnderParenthesis: "",
            Union: "",
            UnionPlus: "",
            Uogon: "",
            uogon: "",
            Uopf: "",
            uopf: "",
            UpArrowBar: "",
            uparrow: "",
            UpArrow: "",
            Uparrow: "",
            UpArrowDownArrow: "",
            updownarrow: "",
            UpDownArrow: "",
            Updownarrow: "",
            UpEquilibrium: "",
            upharpoonleft: "",
            upharpoonright: "",
            uplus: "",
            UpperLeftArrow: "",
            UpperRightArrow: "",
            upsi: "",
            Upsi: "",
            upsih: "",
            Upsilon: "",
            upsilon: "",
            UpTeeArrow: "",
            UpTee: "",
            upuparrows: "",
            urcorn: "",
            urcorner: "",
            urcrop: "",
            Uring: "",
            uring: "",
            urtri: "",
            Uscr: "",
            uscr: "",
            utdot: "",
            Utilde: "",
            utilde: "",
            utri: "",
            utrif: "",
            uuarr: "",
            Uuml: "",
            uuml: "",
            uwangle: "",
            vangrt: "",
            varepsilon: "",
            varkappa: "",
            varnothing: "",
            varphi: "",
            varpi: "",
            varpropto: "",
            varr: "",
            vArr: "",
            varrho: "",
            varsigma: "",
            varsubsetneq: "",
            varsubsetneqq: "",
            varsupsetneq: "",
            varsupsetneqq: "",
            vartheta: "",
            vartriangleleft: "",
            vartriangleright: "",
            vBar: "",
            Vbar: "",
            vBarv: "",
            Vcy: "",
            vcy: "",
            vdash: "",
            vDash: "",
            Vdash: "",
            VDash: "",
            Vdashl: "",
            veebar: "",
            vee: "",
            Vee: "",
            veeeq: "",
            vellip: "",
            verbar: "|",
            Verbar: "",
            vert: "|",
            Vert: "",
            VerticalBar: "",
            VerticalLine: "|",
            VerticalSeparator: "",
            VerticalTilde: "",
            VeryThinSpace: "",
            Vfr: "",
            vfr: "",
            vltri: "",
            vnsub: "",
            vnsup: "",
            Vopf: "",
            vopf: "",
            vprop: "",
            vrtri: "",
            Vscr: "",
            vscr: "",
            vsubnE: "",
            vsubne: "",
            vsupnE: "",
            vsupne: "",
            Vvdash: "",
            vzigzag: "",
            Wcirc: "",
            wcirc: "",
            wedbar: "",
            wedge: "",
            Wedge: "",
            wedgeq: "",
            weierp: "",
            Wfr: "",
            wfr: "",
            Wopf: "",
            wopf: "",
            wp: "",
            wr: "",
            wreath: "",
            Wscr: "",
            wscr: "",
            xcap: "",
            xcirc: "",
            xcup: "",
            xdtri: "",
            Xfr: "",
            xfr: "",
            xharr: "",
            xhArr: "",
            Xi: "",
            xi: "",
            xlarr: "",
            xlArr: "",
            xmap: "",
            xnis: "",
            xodot: "",
            Xopf: "",
            xopf: "",
            xoplus: "",
            xotime: "",
            xrarr: "",
            xrArr: "",
            Xscr: "",
            xscr: "",
            xsqcup: "",
            xuplus: "",
            xutri: "",
            xvee: "",
            xwedge: "",
            Yacute: "",
            yacute: "",
            YAcy: "",
            yacy: "",
            Ycirc: "",
            ycirc: "",
            Ycy: "",
            ycy: "",
            yen: "",
            Yfr: "",
            yfr: "",
            YIcy: "",
            yicy: "",
            Yopf: "",
            yopf: "",
            Yscr: "",
            yscr: "",
            YUcy: "",
            yucy: "",
            yuml: "",
            Yuml: "",
            Zacute: "",
            zacute: "",
            Zcaron: "",
            zcaron: "",
            Zcy: "",
            zcy: "",
            Zdot: "",
            zdot: "",
            zeetrf: "",
            ZeroWidthSpace: "",
            Zeta: "",
            zeta: "",
            zfr: "",
            Zfr: "",
            ZHcy: "",
            zhcy: "",
            zigrarr: "",
            zopf: "",
            Zopf: "",
            Zscr: "",
            zscr: "",
            zwj: "",
            zwnj: ""
        };
    }, {} ],
    55: [ function(require, module, exports) {
        module.exports = {
            Aacute: "",
            aacute: "",
            Acirc: "",
            acirc: "",
            acute: "",
            AElig: "",
            aelig: "",
            Agrave: "",
            agrave: "",
            amp: "&",
            AMP: "&",
            Aring: "",
            aring: "",
            Atilde: "",
            atilde: "",
            Auml: "",
            auml: "",
            brvbar: "",
            Ccedil: "",
            ccedil: "",
            cedil: "",
            cent: "",
            copy: "",
            COPY: "",
            curren: "",
            deg: "",
            divide: "",
            Eacute: "",
            eacute: "",
            Ecirc: "",
            ecirc: "",
            Egrave: "",
            egrave: "",
            ETH: "",
            eth: "",
            Euml: "",
            euml: "",
            frac12: "",
            frac14: "",
            frac34: "",
            gt: ">",
            GT: ">",
            Iacute: "",
            iacute: "",
            Icirc: "",
            icirc: "",
            iexcl: "",
            Igrave: "",
            igrave: "",
            iquest: "",
            Iuml: "",
            iuml: "",
            laquo: "",
            lt: "<",
            LT: "<",
            macr: "",
            micro: "",
            middot: "",
            nbsp: "",
            not: "",
            Ntilde: "",
            ntilde: "",
            Oacute: "",
            oacute: "",
            Ocirc: "",
            ocirc: "",
            Ograve: "",
            ograve: "",
            ordf: "",
            ordm: "",
            Oslash: "",
            oslash: "",
            Otilde: "",
            otilde: "",
            Ouml: "",
            ouml: "",
            para: "",
            plusmn: "",
            pound: "",
            quot: '"',
            QUOT: '"',
            raquo: "",
            reg: "",
            REG: "",
            sect: "",
            shy: "",
            sup1: "",
            sup2: "",
            sup3: "",
            szlig: "",
            THORN: "",
            thorn: "",
            times: "",
            Uacute: "",
            uacute: "",
            Ucirc: "",
            ucirc: "",
            Ugrave: "",
            ugrave: "",
            uml: "",
            Uuml: "",
            uuml: "",
            Yacute: "",
            yacute: "",
            yen: "",
            yuml: ""
        };
    }, {} ],
    56: [ function(require, module, exports) {
        module.exports = {
            amp: "&",
            apos: "'",
            gt: ">",
            lt: "<",
            quot: '"'
        };
    }, {} ],
    57: [ function(require, module, exports) {
        arguments[4][51][0].apply(exports, arguments);
    }, {
        "../maps/decode.json": 58,
        dup: 51
    } ],
    58: [ function(require, module, exports) {
        arguments[4][53][0].apply(exports, arguments);
    }, {
        dup: 53
    } ],
    59: [ function(require, module, exports) {
        arguments[4][54][0].apply(exports, arguments);
    }, {
        dup: 54
    } ],
    60: [ function(require, module, exports) {
        arguments[4][55][0].apply(exports, arguments);
    }, {
        dup: 55
    } ],
    61: [ function(require, module, exports) {
        arguments[4][56][0].apply(exports, arguments);
    }, {
        dup: 56
    } ],
    62: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./lib/");
    }, {
        "./lib/": 72
    } ],
    63: [ function(require, module, exports) {
        "use strict";
        module.exports = require("entities/maps/entities.json");
    }, {
        "entities/maps/entities.json": 113
    } ],
    64: [ function(require, module, exports) {
        "use strict";
        module.exports = [ "address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "head", "header", "hr", "html", "legend", "li", "link", "main", "menu", "menuitem", "meta", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "pre", "section", "source", "title", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul" ];
    }, {} ],
    65: [ function(require, module, exports) {
        "use strict";
        var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
        var unquoted = "[^\"'=<>`\\x00-\\x20]+";
        var single_quoted = "'[^']*'";
        var double_quoted = '"[^"]*"';
        var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
        var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
        var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
        var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
        var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
        var processing = "<[?].*?[?]>";
        var declaration = "<![A-Z]+\\s+[^>]*>";
        var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
        var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
        var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
        module.exports.HTML_TAG_RE = HTML_TAG_RE;
        module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
    }, {} ],
    66: [ function(require, module, exports) {
        "use strict";
        module.exports = [ "coap", "doi", "javascript", "aaa", "aaas", "about", "acap", "cap", "cid", "crid", "data", "dav", "dict", "dns", "file", "ftp", "geo", "go", "gopher", "h323", "http", "https", "iax", "icap", "im", "imap", "info", "ipp", "iris", "iris.beep", "iris.xpc", "iris.xpcs", "iris.lwz", "ldap", "mailto", "mid", "msrp", "msrps", "mtqp", "mupdate", "news", "nfs", "ni", "nih", "nntp", "opaquelocktoken", "pop", "pres", "rtsp", "service", "session", "shttp", "sieve", "sip", "sips", "sms", "snmp", "soap.beep", "soap.beeps", "tag", "tel", "telnet", "tftp", "thismessage", "tn3270", "tip", "tv", "urn", "vemmi", "ws", "wss", "xcon", "xcon-userid", "xmlrpc.beep", "xmlrpc.beeps", "xmpp", "z39.50r", "z39.50s", "adiumxtra", "afp", "afs", "aim", "apt", "attachment", "aw", "beshare", "bitcoin", "bolo", "callto", "chrome", "chrome-extension", "com-eventbrite-attendee", "content", "cvs", "dlna-playsingle", "dlna-playcontainer", "dtn", "dvb", "ed2k", "facetime", "feed", "finger", "fish", "gg", "git", "gizmoproject", "gtalk", "hcp", "icon", "ipn", "irc", "irc6", "ircs", "itms", "jar", "jms", "keyparc", "lastfm", "ldaps", "magnet", "maps", "market", "message", "mms", "ms-help", "msnim", "mumble", "mvn", "notes", "oid", "palm", "paparazzi", "platform", "proxy", "psyc", "query", "res", "resource", "rmi", "rsync", "rtmp", "secondlife", "sftp", "sgn", "skype", "smb", "soldat", "spotify", "ssh", "steam", "svn", "teamspeak", "things", "udp", "unreal", "ut2004", "ventrilo", "view-source", "webcal", "wtai", "wyciwyg", "xfire", "xri", "ymsgr" ];
    }, {} ],
    67: [ function(require, module, exports) {
        "use strict";
        function _class(obj) {
            return Object.prototype.toString.call(obj);
        }
        function isString(obj) {
            return _class(obj) === "[object String]";
        }
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        function has(object, key) {
            return _hasOwnProperty.call(object, key);
        }
        function assign(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            sources.forEach(function(source) {
                if (!source) {
                    return;
                }
                if (typeof source !== "object") {
                    throw new TypeError(source + "must be object");
                }
                Object.keys(source).forEach(function(key) {
                    obj[key] = source[key];
                });
            });
            return obj;
        }
        function arrayReplaceAt(src, pos, newElements) {
            return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
        }
        function isValidEntityCode(c) {
            if (c >= 55296 && c <= 57343) {
                return false;
            }
            if (c >= 64976 && c <= 65007) {
                return false;
            }
            if ((c & 65535) === 65535 || (c & 65535) === 65534) {
                return false;
            }
            if (c >= 0 && c <= 8) {
                return false;
            }
            if (c === 11) {
                return false;
            }
            if (c >= 14 && c <= 31) {
                return false;
            }
            if (c >= 127 && c <= 159) {
                return false;
            }
            if (c > 1114111) {
                return false;
            }
            return true;
        }
        function fromCodePoint(c) {
            if (c > 65535) {
                c -= 65536;
                var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
                return String.fromCharCode(surrogate1, surrogate2);
            }
            return String.fromCharCode(c);
        }
        var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
        var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
        var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
        var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
        var entities = require("./entities");
        function replaceEntityPattern(match, name) {
            var code = 0;
            if (has(entities, name)) {
                return entities[name];
            }
            if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
                code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
                if (isValidEntityCode(code)) {
                    return fromCodePoint(code);
                }
            }
            return match;
        }
        function unescapeMd(str) {
            if (str.indexOf("\\") < 0) {
                return str;
            }
            return str.replace(UNESCAPE_MD_RE, "$1");
        }
        function unescapeAll(str) {
            if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
                return str;
            }
            return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
                if (escaped) {
                    return escaped;
                }
                return replaceEntityPattern(match, entity);
            });
        }
        var HTML_ESCAPE_TEST_RE = /[&<>"]/;
        var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
        var HTML_REPLACEMENTS = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;"
        };
        function replaceUnsafeChar(ch) {
            return HTML_REPLACEMENTS[ch];
        }
        function escapeHtml(str) {
            if (HTML_ESCAPE_TEST_RE.test(str)) {
                return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
            }
            return str;
        }
        var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
        function escapeRE(str) {
            return str.replace(REGEXP_ESCAPE_RE, "\\$&");
        }
        function isWhiteSpace(code) {
            if (code >= 8192 && code <= 8202) {
                return true;
            }
            switch (code) {
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 32:
              case 160:
              case 5760:
              case 8239:
              case 8287:
              case 12288:
                return true;
            }
            return false;
        }
        var UNICODE_PUNCT_RE = require("uc.micro/categories/P/regex");
        function isPunctChar(char) {
            return UNICODE_PUNCT_RE.test(char);
        }
        function isMdAsciiPunct(ch) {
            switch (ch) {
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 47:
              case 58:
              case 59:
              case 60:
              case 61:
              case 62:
              case 63:
              case 64:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 123:
              case 124:
              case 125:
              case 126:
                return true;

              default:
                return false;
            }
        }
        function normalizeReference(str) {
            return str.trim().replace(/\s+/g, " ").toUpperCase();
        }
        exports.lib = {};
        exports.lib.mdurl = require("mdurl");
        exports.lib.ucmicro = require("uc.micro");
        exports.assign = assign;
        exports.isString = isString;
        exports.has = has;
        exports.unescapeMd = unescapeMd;
        exports.unescapeAll = unescapeAll;
        exports.isValidEntityCode = isValidEntityCode;
        exports.fromCodePoint = fromCodePoint;
        exports.escapeHtml = escapeHtml;
        exports.arrayReplaceAt = arrayReplaceAt;
        exports.isWhiteSpace = isWhiteSpace;
        exports.isMdAsciiPunct = isMdAsciiPunct;
        exports.isPunctChar = isPunctChar;
        exports.escapeRE = escapeRE;
        exports.normalizeReference = normalizeReference;
    }, {
        "./entities": 63,
        mdurl: 119,
        "uc.micro": 125,
        "uc.micro/categories/P/regex": 123
    } ],
    68: [ function(require, module, exports) {
        "use strict";
        exports.parseLinkLabel = require("./parse_link_label");
        exports.parseLinkDestination = require("./parse_link_destination");
        exports.parseLinkTitle = require("./parse_link_title");
    }, {
        "./parse_link_destination": 69,
        "./parse_link_label": 70,
        "./parse_link_title": 71
    } ],
    69: [ function(require, module, exports) {
        "use strict";
        var unescapeAll = require("../common/utils").unescapeAll;
        module.exports = function parseLinkDestination(str, pos, max) {
            var code, level, lines = 0, start = pos, result = {
                ok: false,
                pos: 0,
                lines: 0,
                str: ""
            };
            if (str.charCodeAt(pos) === 60) {
                pos++;
                while (pos < max) {
                    code = str.charCodeAt(pos);
                    if (code === 10) {
                        return result;
                    }
                    if (code === 62) {
                        result.pos = pos + 1;
                        result.str = unescapeAll(str.slice(start + 1, pos));
                        result.ok = true;
                        return result;
                    }
                    if (code === 92 && pos + 1 < max) {
                        pos += 2;
                        continue;
                    }
                    pos++;
                }
                return result;
            }
            level = 0;
            while (pos < max) {
                code = str.charCodeAt(pos);
                if (code === 32) {
                    break;
                }
                if (code < 32 || code === 127) {
                    break;
                }
                if (code === 92 && pos + 1 < max) {
                    pos += 2;
                    continue;
                }
                if (code === 40) {
                    level++;
                    if (level > 1) {
                        break;
                    }
                }
                if (code === 41) {
                    level--;
                    if (level < 0) {
                        break;
                    }
                }
                pos++;
            }
            if (start === pos) {
                return result;
            }
            result.str = unescapeAll(str.slice(start, pos));
            result.lines = lines;
            result.pos = pos;
            result.ok = true;
            return result;
        };
    }, {
        "../common/utils": 67
    } ],
    70: [ function(require, module, exports) {
        "use strict";
        module.exports = function parseLinkLabel(state, start, disableNested) {
            var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
            state.pos = start + 1;
            level = 1;
            while (state.pos < max) {
                marker = state.src.charCodeAt(state.pos);
                if (marker === 93) {
                    level--;
                    if (level === 0) {
                        found = true;
                        break;
                    }
                }
                prevPos = state.pos;
                state.md.inline.skipToken(state);
                if (marker === 91) {
                    if (prevPos === state.pos - 1) {
                        level++;
                    } else if (disableNested) {
                        state.pos = oldPos;
                        return -1;
                    }
                }
            }
            if (found) {
                labelEnd = state.pos;
            }
            state.pos = oldPos;
            return labelEnd;
        };
    }, {} ],
    71: [ function(require, module, exports) {
        "use strict";
        var unescapeAll = require("../common/utils").unescapeAll;
        module.exports = function parseLinkTitle(str, pos, max) {
            var code, marker, lines = 0, start = pos, result = {
                ok: false,
                pos: 0,
                lines: 0,
                str: ""
            };
            if (pos >= max) {
                return result;
            }
            marker = str.charCodeAt(pos);
            if (marker !== 34 && marker !== 39 && marker !== 40) {
                return result;
            }
            pos++;
            if (marker === 40) {
                marker = 41;
            }
            while (pos < max) {
                code = str.charCodeAt(pos);
                if (code === marker) {
                    result.pos = pos + 1;
                    result.lines = lines;
                    result.str = unescapeAll(str.slice(start + 1, pos));
                    result.ok = true;
                    return result;
                } else if (code === 10) {
                    lines++;
                } else if (code === 92 && pos + 1 < max) {
                    pos++;
                    if (str.charCodeAt(pos) === 10) {
                        lines++;
                    }
                }
                pos++;
            }
            return result;
        };
    }, {
        "../common/utils": 67
    } ],
    72: [ function(require, module, exports) {
        "use strict";
        var utils = require("./common/utils");
        var helpers = require("./helpers");
        var Renderer = require("./renderer");
        var ParserCore = require("./parser_core");
        var ParserBlock = require("./parser_block");
        var ParserInline = require("./parser_inline");
        var LinkifyIt = require("linkify-it");
        var mdurl = require("mdurl");
        var punycode = require("punycode");
        var config = {
            "default": require("./presets/default"),
            zero: require("./presets/zero"),
            commonmark: require("./presets/commonmark")
        };
        var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
        var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
        function validateLink(url) {
            var str = url.trim().toLowerCase();
            return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
        }
        var RECODE_HOSTNAME_FOR = [ "http:", "https:", "mailto:" ];
        function normalizeLink(url) {
            var parsed = mdurl.parse(url, true);
            if (parsed.hostname) {
                if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
                    try {
                        parsed.hostname = punycode.toASCII(parsed.hostname);
                    } catch (er) {}
                }
            }
            return mdurl.encode(mdurl.format(parsed));
        }
        function normalizeLinkText(url) {
            var parsed = mdurl.parse(url, true);
            if (parsed.hostname) {
                if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
                    try {
                        parsed.hostname = punycode.toUnicode(parsed.hostname);
                    } catch (er) {}
                }
            }
            return mdurl.decode(mdurl.format(parsed));
        }
        function MarkdownIt(presetName, options) {
            if (!(this instanceof MarkdownIt)) {
                return new MarkdownIt(presetName, options);
            }
            if (!options) {
                if (!utils.isString(presetName)) {
                    options = presetName || {};
                    presetName = "default";
                }
            }
            this.inline = new ParserInline();
            this.block = new ParserBlock();
            this.core = new ParserCore();
            this.renderer = new Renderer();
            this.linkify = new LinkifyIt();
            this.validateLink = validateLink;
            this.normalizeLink = normalizeLink;
            this.normalizeLinkText = normalizeLinkText;
            this.utils = utils;
            this.helpers = helpers;
            this.options = {};
            this.configure(presetName);
            if (options) {
                this.set(options);
            }
        }
        MarkdownIt.prototype.set = function(options) {
            utils.assign(this.options, options);
            return this;
        };
        MarkdownIt.prototype.configure = function(presets) {
            var self = this, presetName;
            if (utils.isString(presets)) {
                presetName = presets;
                presets = config[presetName];
                if (!presets) {
                    throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
                }
            }
            if (!presets) {
                throw new Error("Wrong `markdown-it` preset, can't be empty");
            }
            if (presets.options) {
                self.set(presets.options);
            }
            if (presets.components) {
                Object.keys(presets.components).forEach(function(name) {
                    if (presets.components[name].rules) {
                        self[name].ruler.enableOnly(presets.components[name].rules);
                    }
                });
            }
            return this;
        };
        MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
            var result = [];
            if (!Array.isArray(list)) {
                list = [ list ];
            }
            [ "core", "block", "inline" ].forEach(function(chain) {
                result = result.concat(this[chain].ruler.enable(list, true));
            }, this);
            var missed = list.filter(function(name) {
                return result.indexOf(name) < 0;
            });
            if (missed.length && !ignoreInvalid) {
                throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
            }
            return this;
        };
        MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
            var result = [];
            if (!Array.isArray(list)) {
                list = [ list ];
            }
            [ "core", "block", "inline" ].forEach(function(chain) {
                result = result.concat(this[chain].ruler.disable(list, true));
            }, this);
            var missed = list.filter(function(name) {
                return result.indexOf(name) < 0;
            });
            if (missed.length && !ignoreInvalid) {
                throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
            }
            return this;
        };
        MarkdownIt.prototype.use = function(plugin) {
            var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
            plugin.apply(plugin, args);
            return this;
        };
        MarkdownIt.prototype.parse = function(src, env) {
            var state = new this.core.State(src, this, env);
            this.core.process(state);
            return state.tokens;
        };
        MarkdownIt.prototype.render = function(src, env) {
            env = env || {};
            return this.renderer.render(this.parse(src, env), this.options, env);
        };
        MarkdownIt.prototype.parseInline = function(src, env) {
            var state = new this.core.State(src, this, env);
            state.inlineMode = true;
            this.core.process(state);
            return state.tokens;
        };
        MarkdownIt.prototype.renderInline = function(src, env) {
            env = env || {};
            return this.renderer.render(this.parseInline(src, env), this.options, env);
        };
        module.exports = MarkdownIt;
    }, {
        "./common/utils": 67,
        "./helpers": 68,
        "./parser_block": 73,
        "./parser_core": 74,
        "./parser_inline": 75,
        "./presets/commonmark": 76,
        "./presets/default": 77,
        "./presets/zero": 78,
        "./renderer": 79,
        "linkify-it": 114,
        mdurl: 119,
        punycode: 11
    } ],
    73: [ function(require, module, exports) {
        "use strict";
        var Ruler = require("./ruler");
        var _rules = [ [ "code", require("./rules_block/code") ], [ "fence", require("./rules_block/fence"), [ "paragraph", "reference", "blockquote", "list" ] ], [ "blockquote", require("./rules_block/blockquote"), [ "paragraph", "reference", "list" ] ], [ "hr", require("./rules_block/hr"), [ "paragraph", "reference", "blockquote", "list" ] ], [ "list", require("./rules_block/list"), [ "paragraph", "reference", "blockquote" ] ], [ "reference", require("./rules_block/reference") ], [ "heading", require("./rules_block/heading"), [ "paragraph", "reference", "blockquote" ] ], [ "lheading", require("./rules_block/lheading") ], [ "html_block", require("./rules_block/html_block"), [ "paragraph", "reference", "blockquote" ] ], [ "table", require("./rules_block/table"), [ "paragraph", "reference" ] ], [ "paragraph", require("./rules_block/paragraph") ] ];
        function ParserBlock() {
            this.ruler = new Ruler();
            for (var i = 0; i < _rules.length; i++) {
                this.ruler.push(_rules[i][0], _rules[i][1], {
                    alt: (_rules[i][2] || []).slice()
                });
            }
        }
        ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
            var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
            while (line < endLine) {
                state.line = line = state.skipEmptyLines(line);
                if (line >= endLine) {
                    break;
                }
                if (state.tShift[line] < state.blkIndent) {
                    break;
                }
                if (state.level >= maxNesting) {
                    state.line = endLine;
                    break;
                }
                for (i = 0; i < len; i++) {
                    ok = rules[i](state, line, endLine, false);
                    if (ok) {
                        break;
                    }
                }
                state.tight = !hasEmptyLines;
                if (state.isEmpty(state.line - 1)) {
                    hasEmptyLines = true;
                }
                line = state.line;
                if (line < endLine && state.isEmpty(line)) {
                    hasEmptyLines = true;
                    line++;
                    if (line < endLine && state.parentType === "list" && state.isEmpty(line)) {
                        break;
                    }
                    state.line = line;
                }
            }
        };
        ParserBlock.prototype.parse = function(src, md, env, outTokens) {
            var state;
            if (!src) {
                return [];
            }
            state = new this.State(src, md, env, outTokens);
            this.tokenize(state, state.line, state.lineMax);
        };
        ParserBlock.prototype.State = require("./rules_block/state_block");
        module.exports = ParserBlock;
    }, {
        "./ruler": 80,
        "./rules_block/blockquote": 81,
        "./rules_block/code": 82,
        "./rules_block/fence": 83,
        "./rules_block/heading": 84,
        "./rules_block/hr": 85,
        "./rules_block/html_block": 86,
        "./rules_block/lheading": 87,
        "./rules_block/list": 88,
        "./rules_block/paragraph": 89,
        "./rules_block/reference": 90,
        "./rules_block/state_block": 91,
        "./rules_block/table": 92
    } ],
    74: [ function(require, module, exports) {
        "use strict";
        var Ruler = require("./ruler");
        var _rules = [ [ "normalize", require("./rules_core/normalize") ], [ "block", require("./rules_core/block") ], [ "inline", require("./rules_core/inline") ], [ "linkify", require("./rules_core/linkify") ], [ "replacements", require("./rules_core/replacements") ], [ "smartquotes", require("./rules_core/smartquotes") ] ];
        function Core() {
            this.ruler = new Ruler();
            for (var i = 0; i < _rules.length; i++) {
                this.ruler.push(_rules[i][0], _rules[i][1]);
            }
        }
        Core.prototype.process = function(state) {
            var i, l, rules;
            rules = this.ruler.getRules("");
            for (i = 0, l = rules.length; i < l; i++) {
                rules[i](state);
            }
        };
        Core.prototype.State = require("./rules_core/state_core");
        module.exports = Core;
    }, {
        "./ruler": 80,
        "./rules_core/block": 93,
        "./rules_core/inline": 94,
        "./rules_core/linkify": 95,
        "./rules_core/normalize": 96,
        "./rules_core/replacements": 97,
        "./rules_core/smartquotes": 98,
        "./rules_core/state_core": 99
    } ],
    75: [ function(require, module, exports) {
        "use strict";
        var Ruler = require("./ruler");
        var _rules = [ [ "text", require("./rules_inline/text") ], [ "newline", require("./rules_inline/newline") ], [ "escape", require("./rules_inline/escape") ], [ "backticks", require("./rules_inline/backticks") ], [ "strikethrough", require("./rules_inline/strikethrough") ], [ "emphasis", require("./rules_inline/emphasis") ], [ "link", require("./rules_inline/link") ], [ "image", require("./rules_inline/image") ], [ "autolink", require("./rules_inline/autolink") ], [ "html_inline", require("./rules_inline/html_inline") ], [ "entity", require("./rules_inline/entity") ] ];
        function ParserInline() {
            this.ruler = new Ruler();
            for (var i = 0; i < _rules.length; i++) {
                this.ruler.push(_rules[i][0], _rules[i][1]);
            }
        }
        ParserInline.prototype.skipToken = function(state) {
            var i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
            if (typeof cache[pos] !== "undefined") {
                state.pos = cache[pos];
                return;
            }
            if (state.level < maxNesting) {
                for (i = 0; i < len; i++) {
                    if (rules[i](state, true)) {
                        cache[pos] = state.pos;
                        return;
                    }
                }
            }
            state.pos++;
            cache[pos] = state.pos;
        };
        ParserInline.prototype.tokenize = function(state) {
            var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
            while (state.pos < end) {
                if (state.level < maxNesting) {
                    for (i = 0; i < len; i++) {
                        ok = rules[i](state, false);
                        if (ok) {
                            break;
                        }
                    }
                }
                if (ok) {
                    if (state.pos >= end) {
                        break;
                    }
                    continue;
                }
                state.pending += state.src[state.pos++];
            }
            if (state.pending) {
                state.pushPending();
            }
        };
        ParserInline.prototype.parse = function(str, md, env, outTokens) {
            var state = new this.State(str, md, env, outTokens);
            this.tokenize(state);
        };
        ParserInline.prototype.State = require("./rules_inline/state_inline");
        module.exports = ParserInline;
    }, {
        "./ruler": 80,
        "./rules_inline/autolink": 100,
        "./rules_inline/backticks": 101,
        "./rules_inline/emphasis": 102,
        "./rules_inline/entity": 103,
        "./rules_inline/escape": 104,
        "./rules_inline/html_inline": 105,
        "./rules_inline/image": 106,
        "./rules_inline/link": 107,
        "./rules_inline/newline": 108,
        "./rules_inline/state_inline": 109,
        "./rules_inline/strikethrough": 110,
        "./rules_inline/text": 111
    } ],
    76: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            options: {
                html: true,
                xhtmlOut: true,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: [ "normalize", "block", "inline" ]
                },
                block: {
                    rules: [ "blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph" ]
                },
                inline: {
                    rules: [ "autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text" ]
                }
            }
        };
    }, {} ],
    77: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            options: {
                html: false,
                xhtmlOut: false,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {},
                block: {},
                inline: {}
            }
        };
    }, {} ],
    78: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            options: {
                html: false,
                xhtmlOut: false,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: [ "normalize", "block", "inline" ]
                },
                block: {
                    rules: [ "paragraph" ]
                },
                inline: {
                    rules: [ "text" ]
                }
            }
        };
    }, {} ],
    79: [ function(require, module, exports) {
        "use strict";
        var assign = require("./common/utils").assign;
        var unescapeAll = require("./common/utils").unescapeAll;
        var escapeHtml = require("./common/utils").escapeHtml;
        var default_rules = {};
        default_rules.code_inline = function(tokens, idx) {
            return "<code>" + escapeHtml(tokens[idx].content) + "</code>";
        };
        default_rules.code_block = function(tokens, idx) {
            return "<pre><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
        };
        default_rules.fence = function(tokens, idx, options, env, self) {
            var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", highlighted;
            if (info) {
                langName = info.split(/\s+/g)[0];
                token.attrPush([ "class", options.langPrefix + langName ]);
            }
            if (options.highlight) {
                highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
            } else {
                highlighted = escapeHtml(token.content);
            }
            return "<pre><code" + self.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
        };
        default_rules.image = function(tokens, idx, options, env, self) {
            var token = tokens[idx];
            token.attrs[token.attrIndex("alt")][1] = self.renderInlineAsText(token.children, options, env);
            return self.renderToken(tokens, idx, options);
        };
        default_rules.hardbreak = function(tokens, idx, options) {
            return options.xhtmlOut ? "<br />\n" : "<br>\n";
        };
        default_rules.softbreak = function(tokens, idx, options) {
            return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
        };
        default_rules.text = function(tokens, idx) {
            return escapeHtml(tokens[idx].content);
        };
        default_rules.html_block = function(tokens, idx) {
            return tokens[idx].content;
        };
        default_rules.html_inline = function(tokens, idx) {
            return tokens[idx].content;
        };
        function Renderer() {
            this.rules = assign({}, default_rules);
        }
        Renderer.prototype.renderAttrs = function renderAttrs(token) {
            var i, l, result;
            if (!token.attrs) {
                return "";
            }
            result = "";
            for (i = 0, l = token.attrs.length; i < l; i++) {
                result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
            }
            return result;
        };
        Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
            var nextToken, result = "", needLf = false, token = tokens[idx];
            if (token.hidden) {
                return "";
            }
            if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
                result += "\n";
            }
            result += (token.nesting === -1 ? "</" : "<") + token.tag;
            result += this.renderAttrs(token);
            if (token.nesting === 0 && options.xhtmlOut) {
                result += " /";
            }
            if (token.block) {
                needLf = true;
                if (token.nesting === 1) {
                    if (idx + 1 < tokens.length) {
                        nextToken = tokens[idx + 1];
                        if (nextToken.type === "inline" || nextToken.hidden) {
                            needLf = false;
                        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
                            needLf = false;
                        }
                    }
                }
            }
            result += needLf ? ">\n" : ">";
            return result;
        };
        Renderer.prototype.renderInline = function(tokens, options, env) {
            var type, result = "", rules = this.rules;
            for (var i = 0, len = tokens.length; i < len; i++) {
                type = tokens[i].type;
                if (typeof rules[type] !== "undefined") {
                    result += rules[type](tokens, i, options, env, this);
                } else {
                    result += this.renderToken(tokens, i, options);
                }
            }
            return result;
        };
        Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
            var result = "", rules = this.rules;
            for (var i = 0, len = tokens.length; i < len; i++) {
                if (tokens[i].type === "text") {
                    result += rules.text(tokens, i, options, env, this);
                } else if (tokens[i].type === "image") {
                    result += this.renderInlineAsText(tokens[i].children, options, env);
                }
            }
            return result;
        };
        Renderer.prototype.render = function(tokens, options, env) {
            var i, len, type, result = "", rules = this.rules;
            for (i = 0, len = tokens.length; i < len; i++) {
                type = tokens[i].type;
                if (type === "inline") {
                    result += this.renderInline(tokens[i].children, options, env);
                } else if (typeof rules[type] !== "undefined") {
                    result += rules[tokens[i].type](tokens, i, options, env, this);
                } else {
                    result += this.renderToken(tokens, i, options, env);
                }
            }
            return result;
        };
        module.exports = Renderer;
    }, {
        "./common/utils": 67
    } ],
    80: [ function(require, module, exports) {
        "use strict";
        function Ruler() {
            this.__rules__ = [];
            this.__cache__ = null;
        }
        Ruler.prototype.__find__ = function(name) {
            for (var i = 0; i < this.__rules__.length; i++) {
                if (this.__rules__[i].name === name) {
                    return i;
                }
            }
            return -1;
        };
        Ruler.prototype.__compile__ = function() {
            var self = this;
            var chains = [ "" ];
            self.__rules__.forEach(function(rule) {
                if (!rule.enabled) {
                    return;
                }
                rule.alt.forEach(function(altName) {
                    if (chains.indexOf(altName) < 0) {
                        chains.push(altName);
                    }
                });
            });
            self.__cache__ = {};
            chains.forEach(function(chain) {
                self.__cache__[chain] = [];
                self.__rules__.forEach(function(rule) {
                    if (!rule.enabled) {
                        return;
                    }
                    if (chain && rule.alt.indexOf(chain) < 0) {
                        return;
                    }
                    self.__cache__[chain].push(rule.fn);
                });
            });
        };
        Ruler.prototype.at = function(name, fn, options) {
            var index = this.__find__(name);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + name);
            }
            this.__rules__[index].fn = fn;
            this.__rules__[index].alt = opt.alt || [];
            this.__cache__ = null;
        };
        Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
            var index = this.__find__(beforeName);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + beforeName);
            }
            this.__rules__.splice(index, 0, {
                name: ruleName,
                enabled: true,
                fn: fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.after = function(afterName, ruleName, fn, options) {
            var index = this.__find__(afterName);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + afterName);
            }
            this.__rules__.splice(index + 1, 0, {
                name: ruleName,
                enabled: true,
                fn: fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.push = function(ruleName, fn, options) {
            var opt = options || {};
            this.__rules__.push({
                name: ruleName,
                enabled: true,
                fn: fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.enable = function(list, ignoreInvalid) {
            if (!Array.isArray(list)) {
                list = [ list ];
            }
            var result = [];
            list.forEach(function(name) {
                var idx = this.__find__(name);
                if (idx < 0) {
                    if (ignoreInvalid) {
                        return;
                    }
                    throw new Error("Rules manager: invalid rule name " + name);
                }
                this.__rules__[idx].enabled = true;
                result.push(name);
            }, this);
            this.__cache__ = null;
            return result;
        };
        Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
            if (!Array.isArray(list)) {
                list = [ list ];
            }
            this.__rules__.forEach(function(rule) {
                rule.enabled = false;
            });
            this.enable(list, ignoreInvalid);
        };
        Ruler.prototype.disable = function(list, ignoreInvalid) {
            if (!Array.isArray(list)) {
                list = [ list ];
            }
            var result = [];
            list.forEach(function(name) {
                var idx = this.__find__(name);
                if (idx < 0) {
                    if (ignoreInvalid) {
                        return;
                    }
                    throw new Error("Rules manager: invalid rule name " + name);
                }
                this.__rules__[idx].enabled = false;
                result.push(name);
            }, this);
            this.__cache__ = null;
            return result;
        };
        Ruler.prototype.getRules = function(chainName) {
            if (this.__cache__ === null) {
                this.__compile__();
            }
            return this.__cache__[chainName] || [];
        };
        module.exports = Ruler;
    }, {} ],
    81: [ function(require, module, exports) {
        "use strict";
        module.exports = function blockquote(state, startLine, endLine, silent) {
            var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines, terminatorRules, token, i, l, terminate, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
            if (state.src.charCodeAt(pos++) !== 62) {
                return false;
            }
            if (silent) {
                return true;
            }
            if (state.src.charCodeAt(pos) === 32) {
                pos++;
            }
            oldIndent = state.blkIndent;
            state.blkIndent = 0;
            oldBMarks = [ state.bMarks[startLine] ];
            state.bMarks[startLine] = pos;
            pos = pos < max ? state.skipSpaces(pos) : pos;
            lastLineEmpty = pos >= max;
            oldTShift = [ state.tShift[startLine] ];
            state.tShift[startLine] = pos - state.bMarks[startLine];
            terminatorRules = state.md.block.ruler.getRules("blockquote");
            for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
                if (state.tShift[nextLine] < oldIndent) {
                    break;
                }
                pos = state.bMarks[nextLine] + state.tShift[nextLine];
                max = state.eMarks[nextLine];
                if (pos >= max) {
                    break;
                }
                if (state.src.charCodeAt(pos++) === 62) {
                    if (state.src.charCodeAt(pos) === 32) {
                        pos++;
                    }
                    oldBMarks.push(state.bMarks[nextLine]);
                    state.bMarks[nextLine] = pos;
                    pos = pos < max ? state.skipSpaces(pos) : pos;
                    lastLineEmpty = pos >= max;
                    oldTShift.push(state.tShift[nextLine]);
                    state.tShift[nextLine] = pos - state.bMarks[nextLine];
                    continue;
                }
                if (lastLineEmpty) {
                    break;
                }
                terminate = false;
                for (i = 0, l = terminatorRules.length; i < l; i++) {
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
                oldBMarks.push(state.bMarks[nextLine]);
                oldTShift.push(state.tShift[nextLine]);
                state.tShift[nextLine] = -1;
            }
            oldParentType = state.parentType;
            state.parentType = "blockquote";
            token = state.push("blockquote_open", "blockquote", 1);
            token.markup = ">";
            token.map = lines = [ startLine, 0 ];
            state.md.block.tokenize(state, startLine, nextLine);
            token = state.push("blockquote_close", "blockquote", -1);
            token.markup = ">";
            state.parentType = oldParentType;
            lines[1] = state.line;
            for (i = 0; i < oldTShift.length; i++) {
                state.bMarks[i + startLine] = oldBMarks[i];
                state.tShift[i + startLine] = oldTShift[i];
            }
            state.blkIndent = oldIndent;
            return true;
        };
    }, {} ],
    82: [ function(require, module, exports) {
        "use strict";
        module.exports = function code(state, startLine, endLine) {
            var nextLine, last, token;
            if (state.tShift[startLine] - state.blkIndent < 4) {
                return false;
            }
            last = nextLine = startLine + 1;
            while (nextLine < endLine) {
                if (state.isEmpty(nextLine)) {
                    nextLine++;
                    continue;
                }
                if (state.tShift[nextLine] - state.blkIndent >= 4) {
                    nextLine++;
                    last = nextLine;
                    continue;
                }
                break;
            }
            state.line = nextLine;
            token = state.push("code_block", "code", 0);
            token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
            token.map = [ startLine, state.line ];
            return true;
        };
    }, {} ],
    83: [ function(require, module, exports) {
        "use strict";
        module.exports = function fence(state, startLine, endLine, silent) {
            var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
            if (pos + 3 > max) {
                return false;
            }
            marker = state.src.charCodeAt(pos);
            if (marker !== 126 && marker !== 96) {
                return false;
            }
            mem = pos;
            pos = state.skipChars(pos, marker);
            len = pos - mem;
            if (len < 3) {
                return false;
            }
            markup = state.src.slice(mem, pos);
            params = state.src.slice(pos, max);
            if (params.indexOf("`") >= 0) {
                return false;
            }
            if (silent) {
                return true;
            }
            nextLine = startLine;
            for (;;) {
                nextLine++;
                if (nextLine >= endLine) {
                    break;
                }
                pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
                max = state.eMarks[nextLine];
                if (pos < max && state.tShift[nextLine] < state.blkIndent) {
                    break;
                }
                if (state.src.charCodeAt(pos) !== marker) {
                    continue;
                }
                if (state.tShift[nextLine] - state.blkIndent >= 4) {
                    continue;
                }
                pos = state.skipChars(pos, marker);
                if (pos - mem < len) {
                    continue;
                }
                pos = state.skipSpaces(pos);
                if (pos < max) {
                    continue;
                }
                haveEndMarker = true;
                break;
            }
            len = state.tShift[startLine];
            state.line = nextLine + (haveEndMarker ? 1 : 0);
            token = state.push("fence", "code", 0);
            token.info = params;
            token.content = state.getLines(startLine + 1, nextLine, len, true);
            token.markup = markup;
            token.map = [ startLine, state.line ];
            return true;
        };
    }, {} ],
    84: [ function(require, module, exports) {
        "use strict";
        module.exports = function heading(state, startLine, endLine, silent) {
            var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
            ch = state.src.charCodeAt(pos);
            if (ch !== 35 || pos >= max) {
                return false;
            }
            level = 1;
            ch = state.src.charCodeAt(++pos);
            while (ch === 35 && pos < max && level <= 6) {
                level++;
                ch = state.src.charCodeAt(++pos);
            }
            if (level > 6 || pos < max && ch !== 32) {
                return false;
            }
            if (silent) {
                return true;
            }
            max = state.skipCharsBack(max, 32, pos);
            tmp = state.skipCharsBack(max, 35, pos);
            if (tmp > pos && state.src.charCodeAt(tmp - 1) === 32) {
                max = tmp;
            }
            state.line = startLine + 1;
            token = state.push("heading_open", "h" + String(level), 1);
            token.markup = "########".slice(0, level);
            token.map = [ startLine, state.line ];
            token = state.push("inline", "", 0);
            token.content = state.src.slice(pos, max).trim();
            token.map = [ startLine, state.line ];
            token.children = [];
            token = state.push("heading_close", "h" + String(level), -1);
            token.markup = "########".slice(0, level);
            return true;
        };
    }, {} ],
    85: [ function(require, module, exports) {
        "use strict";
        module.exports = function hr(state, startLine, endLine, silent) {
            var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
            marker = state.src.charCodeAt(pos++);
            if (marker !== 42 && marker !== 45 && marker !== 95) {
                return false;
            }
            cnt = 1;
            while (pos < max) {
                ch = state.src.charCodeAt(pos++);
                if (ch !== marker && ch !== 32) {
                    return false;
                }
                if (ch === marker) {
                    cnt++;
                }
            }
            if (cnt < 3) {
                return false;
            }
            if (silent) {
                return true;
            }
            state.line = startLine + 1;
            token = state.push("hr", "hr", 0);
            token.map = [ startLine, state.line ];
            token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
            return true;
        };
    }, {} ],
    86: [ function(require, module, exports) {
        "use strict";
        var block_names = require("../common/html_blocks");
        var HTML_OPEN_CLOSE_TAG_RE = require("../common/html_re").HTML_OPEN_CLOSE_TAG_RE;
        var HTML_SEQUENCES = [ [ /^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true ], [ /^<!--/, /-->/, true ], [ /^<\?/, /\?>/, true ], [ /^<![A-Z]/, />/, true ], [ /^<!\[CDATA\[/, /\]\]>/, true ], [ new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true ], [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false ] ];
        module.exports = function html_block(state, startLine, endLine, silent) {
            var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
            if (!state.md.options.html) {
                return false;
            }
            if (state.src.charCodeAt(pos) !== 60) {
                return false;
            }
            lineText = state.src.slice(pos, max);
            for (i = 0; i < HTML_SEQUENCES.length; i++) {
                if (HTML_SEQUENCES[i][0].test(lineText)) {
                    break;
                }
            }
            if (i === HTML_SEQUENCES.length) {
                return false;
            }
            if (silent) {
                return HTML_SEQUENCES[i][2];
            }
            nextLine = startLine + 1;
            if (!HTML_SEQUENCES[i][1].test(lineText)) {
                for (;nextLine < endLine; nextLine++) {
                    if (state.tShift[nextLine] < state.blkIndent) {
                        break;
                    }
                    pos = state.bMarks[nextLine] + state.tShift[nextLine];
                    max = state.eMarks[nextLine];
                    lineText = state.src.slice(pos, max);
                    if (HTML_SEQUENCES[i][1].test(lineText)) {
                        if (lineText.length !== 0) {
                            nextLine++;
                        }
                        break;
                    }
                }
            }
            state.line = nextLine;
            token = state.push("html_block", "", 0);
            token.map = [ startLine, nextLine ];
            token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
            return true;
        };
    }, {
        "../common/html_blocks": 64,
        "../common/html_re": 65
    } ],
    87: [ function(require, module, exports) {
        "use strict";
        module.exports = function lheading(state, startLine, endLine) {
            var marker, pos, max, token, level, next = startLine + 1;
            if (next >= endLine) {
                return false;
            }
            if (state.tShift[next] < state.blkIndent) {
                return false;
            }
            if (state.tShift[next] - state.blkIndent > 3) {
                return false;
            }
            pos = state.bMarks[next] + state.tShift[next];
            max = state.eMarks[next];
            if (pos >= max) {
                return false;
            }
            marker = state.src.charCodeAt(pos);
            if (marker !== 45 && marker !== 61) {
                return false;
            }
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);
            if (pos < max) {
                return false;
            }
            pos = state.bMarks[startLine] + state.tShift[startLine];
            state.line = next + 1;
            level = marker === 61 ? 1 : 2;
            token = state.push("heading_open", "h" + String(level), 1);
            token.markup = String.fromCharCode(marker);
            token.map = [ startLine, state.line ];
            token = state.push("inline", "", 0);
            token.content = state.src.slice(pos, state.eMarks[startLine]).trim();
            token.map = [ startLine, state.line - 1 ];
            token.children = [];
            token = state.push("heading_close", "h" + String(level), -1);
            token.markup = String.fromCharCode(marker);
            return true;
        };
    }, {} ],
    88: [ function(require, module, exports) {
        "use strict";
        function skipBulletListMarker(state, startLine) {
            var marker, pos, max;
            pos = state.bMarks[startLine] + state.tShift[startLine];
            max = state.eMarks[startLine];
            marker = state.src.charCodeAt(pos++);
            if (marker !== 42 && marker !== 45 && marker !== 43) {
                return -1;
            }
            if (pos < max && state.src.charCodeAt(pos) !== 32) {
                return -1;
            }
            return pos;
        }
        function skipOrderedListMarker(state, startLine) {
            var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
            if (pos + 1 >= max) {
                return -1;
            }
            ch = state.src.charCodeAt(pos++);
            if (ch < 48 || ch > 57) {
                return -1;
            }
            for (;;) {
                if (pos >= max) {
                    return -1;
                }
                ch = state.src.charCodeAt(pos++);
                if (ch >= 48 && ch <= 57) {
                    if (pos - start >= 10) {
                        return -1;
                    }
                    continue;
                }
                if (ch === 41 || ch === 46) {
                    break;
                }
                return -1;
            }
            if (pos < max && state.src.charCodeAt(pos) !== 32) {
                return -1;
            }
            return pos;
        }
        function markTightParagraphs(state, idx) {
            var i, l, level = state.level + 2;
            for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
                if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
                    state.tokens[i + 2].hidden = true;
                    state.tokens[i].hidden = true;
                    i += 2;
                }
            }
        }
        module.exports = function list(state, startLine, endLine, silent) {
            var nextLine, indent, oldTShift, oldIndent, oldTight, oldParentType, start, posAfterMarker, max, indentAfterMarker, markerValue, markerCharCode, isOrdered, contentStart, listTokIdx, prevEmptyEnd, listLines, itemLines, tight = true, terminatorRules, token, i, l, terminate;
            if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
                isOrdered = true;
            } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
                isOrdered = false;
            } else {
                return false;
            }
            markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
            if (silent) {
                return true;
            }
            listTokIdx = state.tokens.length;
            if (isOrdered) {
                start = state.bMarks[startLine] + state.tShift[startLine];
                markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
                token = state.push("ordered_list_open", "ol", 1);
                if (markerValue !== 1) {
                    token.attrs = [ [ "start", markerValue ] ];
                }
            } else {
                token = state.push("bullet_list_open", "ul", 1);
            }
            token.map = listLines = [ startLine, 0 ];
            token.markup = String.fromCharCode(markerCharCode);
            nextLine = startLine;
            prevEmptyEnd = false;
            terminatorRules = state.md.block.ruler.getRules("list");
            while (nextLine < endLine) {
                contentStart = state.skipSpaces(posAfterMarker);
                max = state.eMarks[nextLine];
                if (contentStart >= max) {
                    indentAfterMarker = 1;
                } else {
                    indentAfterMarker = contentStart - posAfterMarker;
                }
                if (indentAfterMarker > 4) {
                    indentAfterMarker = 1;
                }
                indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker;
                token = state.push("list_item_open", "li", 1);
                token.markup = String.fromCharCode(markerCharCode);
                token.map = itemLines = [ startLine, 0 ];
                oldIndent = state.blkIndent;
                oldTight = state.tight;
                oldTShift = state.tShift[startLine];
                oldParentType = state.parentType;
                state.tShift[startLine] = contentStart - state.bMarks[startLine];
                state.blkIndent = indent;
                state.tight = true;
                state.parentType = "list";
                state.md.block.tokenize(state, startLine, endLine, true);
                if (!state.tight || prevEmptyEnd) {
                    tight = false;
                }
                prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
                state.blkIndent = oldIndent;
                state.tShift[startLine] = oldTShift;
                state.tight = oldTight;
                state.parentType = oldParentType;
                token = state.push("list_item_close", "li", -1);
                token.markup = String.fromCharCode(markerCharCode);
                nextLine = startLine = state.line;
                itemLines[1] = nextLine;
                contentStart = state.bMarks[startLine];
                if (nextLine >= endLine) {
                    break;
                }
                if (state.isEmpty(nextLine)) {
                    break;
                }
                if (state.tShift[nextLine] < state.blkIndent) {
                    break;
                }
                terminate = false;
                for (i = 0, l = terminatorRules.length; i < l; i++) {
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
                if (isOrdered) {
                    posAfterMarker = skipOrderedListMarker(state, nextLine);
                    if (posAfterMarker < 0) {
                        break;
                    }
                } else {
                    posAfterMarker = skipBulletListMarker(state, nextLine);
                    if (posAfterMarker < 0) {
                        break;
                    }
                }
                if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
                    break;
                }
            }
            if (isOrdered) {
                token = state.push("ordered_list_close", "ol", -1);
            } else {
                token = state.push("bullet_list_close", "ul", -1);
            }
            token.markup = String.fromCharCode(markerCharCode);
            listLines[1] = nextLine;
            state.line = nextLine;
            if (tight) {
                markTightParagraphs(state, listTokIdx);
            }
            return true;
        };
    }, {} ],
    89: [ function(require, module, exports) {
        "use strict";
        module.exports = function paragraph(state, startLine) {
            var content, terminate, i, l, token, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
            for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
                if (state.tShift[nextLine] - state.blkIndent > 3) {
                    continue;
                }
                if (state.tShift[nextLine] < 0) {
                    continue;
                }
                terminate = false;
                for (i = 0, l = terminatorRules.length; i < l; i++) {
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
            }
            content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
            state.line = nextLine;
            token = state.push("paragraph_open", "p", 1);
            token.map = [ startLine, state.line ];
            token = state.push("inline", "", 0);
            token.content = content;
            token.map = [ startLine, state.line ];
            token.children = [];
            token = state.push("paragraph_close", "p", -1);
            return true;
        };
    }, {} ],
    90: [ function(require, module, exports) {
        "use strict";
        var parseLinkDestination = require("../helpers/parse_link_destination");
        var parseLinkTitle = require("../helpers/parse_link_title");
        var normalizeReference = require("../common/utils").normalizeReference;
        module.exports = function reference(state, startLine, _endLine, silent) {
            var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
            if (state.src.charCodeAt(pos) !== 91) {
                return false;
            }
            while (++pos < max) {
                if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
                    if (pos + 1 === max) {
                        return false;
                    }
                    if (state.src.charCodeAt(pos + 1) !== 58) {
                        return false;
                    }
                    break;
                }
            }
            endLine = state.lineMax;
            terminatorRules = state.md.block.ruler.getRules("reference");
            for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
                if (state.tShift[nextLine] - state.blkIndent > 3) {
                    continue;
                }
                if (state.tShift[nextLine] < 0) {
                    continue;
                }
                terminate = false;
                for (i = 0, l = terminatorRules.length; i < l; i++) {
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
            }
            str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
            max = str.length;
            for (pos = 1; pos < max; pos++) {
                ch = str.charCodeAt(pos);
                if (ch === 91) {
                    return false;
                } else if (ch === 93) {
                    labelEnd = pos;
                    break;
                } else if (ch === 10) {
                    lines++;
                } else if (ch === 92) {
                    pos++;
                    if (pos < max && str.charCodeAt(pos) === 10) {
                        lines++;
                    }
                }
            }
            if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
                return false;
            }
            for (pos = labelEnd + 2; pos < max; pos++) {
                ch = str.charCodeAt(pos);
                if (ch === 10) {
                    lines++;
                } else if (ch === 32) {} else {
                    break;
                }
            }
            res = parseLinkDestination(str, pos, max);
            if (!res.ok) {
                return false;
            }
            href = state.md.normalizeLink(res.str);
            if (!state.md.validateLink(href)) {
                return false;
            }
            pos = res.pos;
            lines += res.lines;
            destEndPos = pos;
            destEndLineNo = lines;
            start = pos;
            for (;pos < max; pos++) {
                ch = str.charCodeAt(pos);
                if (ch === 10) {
                    lines++;
                } else if (ch === 32) {} else {
                    break;
                }
            }
            res = parseLinkTitle(str, pos, max);
            if (pos < max && start !== pos && res.ok) {
                title = res.str;
                pos = res.pos;
                lines += res.lines;
            } else {
                title = "";
                pos = destEndPos;
                lines = destEndLineNo;
            }
            while (pos < max && str.charCodeAt(pos) === 32) {
                pos++;
            }
            if (pos < max && str.charCodeAt(pos) !== 10) {
                if (title) {
                    title = "";
                    pos = destEndPos;
                    lines = destEndLineNo;
                    while (pos < max && str.charCodeAt(pos) === 32) {
                        pos++;
                    }
                }
            }
            if (pos < max && str.charCodeAt(pos) !== 10) {
                return false;
            }
            label = normalizeReference(str.slice(1, labelEnd));
            if (!label) {
                return false;
            }
            if (silent) {
                return true;
            }
            if (typeof state.env.references === "undefined") {
                state.env.references = {};
            }
            if (typeof state.env.references[label] === "undefined") {
                state.env.references[label] = {
                    title: title,
                    href: href
                };
            }
            state.line = startLine + lines + 1;
            return true;
        };
    }, {
        "../common/utils": 67,
        "../helpers/parse_link_destination": 69,
        "../helpers/parse_link_title": 71
    } ],
    91: [ function(require, module, exports) {
        "use strict";
        var Token = require("../token");
        function StateBlock(src, md, env, tokens) {
            var ch, s, start, pos, len, indent, indent_found;
            this.src = src;
            this.md = md;
            this.env = env;
            this.tokens = tokens;
            this.bMarks = [];
            this.eMarks = [];
            this.tShift = [];
            this.blkIndent = 0;
            this.line = 0;
            this.lineMax = 0;
            this.tight = false;
            this.parentType = "root";
            this.ddIndent = -1;
            this.level = 0;
            this.result = "";
            s = this.src;
            indent = 0;
            indent_found = false;
            for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
                ch = s.charCodeAt(pos);
                if (!indent_found) {
                    if (ch === 32) {
                        indent++;
                        continue;
                    } else {
                        indent_found = true;
                    }
                }
                if (ch === 10 || pos === len - 1) {
                    if (ch !== 10) {
                        pos++;
                    }
                    this.bMarks.push(start);
                    this.eMarks.push(pos);
                    this.tShift.push(indent);
                    indent_found = false;
                    indent = 0;
                    start = pos + 1;
                }
            }
            this.bMarks.push(s.length);
            this.eMarks.push(s.length);
            this.tShift.push(0);
            this.lineMax = this.bMarks.length - 1;
        }
        StateBlock.prototype.push = function(type, tag, nesting) {
            var token = new Token(type, tag, nesting);
            token.block = true;
            if (nesting < 0) {
                this.level--;
            }
            token.level = this.level;
            if (nesting > 0) {
                this.level++;
            }
            this.tokens.push(token);
            return token;
        };
        StateBlock.prototype.isEmpty = function isEmpty(line) {
            return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
        };
        StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
            for (var max = this.lineMax; from < max; from++) {
                if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
                    break;
                }
            }
            return from;
        };
        StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
            for (var max = this.src.length; pos < max; pos++) {
                if (this.src.charCodeAt(pos) !== 32) {
                    break;
                }
            }
            return pos;
        };
        StateBlock.prototype.skipChars = function skipChars(pos, code) {
            for (var max = this.src.length; pos < max; pos++) {
                if (this.src.charCodeAt(pos) !== code) {
                    break;
                }
            }
            return pos;
        };
        StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
            if (pos <= min) {
                return pos;
            }
            while (pos > min) {
                if (code !== this.src.charCodeAt(--pos)) {
                    return pos + 1;
                }
            }
            return pos;
        };
        StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
            var i, first, last, queue, shift, line = begin;
            if (begin >= end) {
                return "";
            }
            if (line + 1 === end) {
                first = this.bMarks[line] + Math.min(this.tShift[line], indent);
                last = this.eMarks[end - 1] + (keepLastLF ? 1 : 0);
                return this.src.slice(first, last);
            }
            queue = new Array(end - begin);
            for (i = 0; line < end; line++, i++) {
                shift = this.tShift[line];
                if (shift > indent) {
                    shift = indent;
                }
                if (shift < 0) {
                    shift = 0;
                }
                first = this.bMarks[line] + shift;
                if (line + 1 < end || keepLastLF) {
                    last = this.eMarks[line] + 1;
                } else {
                    last = this.eMarks[line];
                }
                queue[i] = this.src.slice(first, last);
            }
            return queue.join("");
        };
        StateBlock.prototype.Token = Token;
        module.exports = StateBlock;
    }, {
        "../token": 112
    } ],
    92: [ function(require, module, exports) {
        "use strict";
        function getLine(state, line) {
            var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];
            return state.src.substr(pos, max - pos);
        }
        function escapedSplit(str) {
            var result = [], pos = 0, max = str.length, ch, escapes = 0, lastPos = 0, backTicked = false, lastBackTick = 0;
            ch = str.charCodeAt(pos);
            while (pos < max) {
                if (ch === 96 && escapes % 2 === 0) {
                    backTicked = !backTicked;
                    lastBackTick = pos;
                } else if (ch === 124 && escapes % 2 === 0 && !backTicked) {
                    result.push(str.substring(lastPos, pos));
                    lastPos = pos + 1;
                } else if (ch === 92) {
                    escapes++;
                } else {
                    escapes = 0;
                }
                pos++;
                if (pos === max && backTicked) {
                    backTicked = false;
                    pos = lastBackTick + 1;
                }
                ch = str.charCodeAt(pos);
            }
            result.push(str.substring(lastPos));
            return result;
        }
        module.exports = function table(state, startLine, endLine, silent) {
            var ch, lineText, pos, i, nextLine, rows, token, aligns, t, tableLines, tbodyLines;
            if (startLine + 2 > endLine) {
                return false;
            }
            nextLine = startLine + 1;
            if (state.tShift[nextLine] < state.blkIndent) {
                return false;
            }
            pos = state.bMarks[nextLine] + state.tShift[nextLine];
            if (pos >= state.eMarks[nextLine]) {
                return false;
            }
            ch = state.src.charCodeAt(pos);
            if (ch !== 124 && ch !== 45 && ch !== 58) {
                return false;
            }
            lineText = getLine(state, startLine + 1);
            if (!/^[-:| ]+$/.test(lineText)) {
                return false;
            }
            rows = lineText.split("|");
            if (rows.length < 2) {
                return false;
            }
            aligns = [];
            for (i = 0; i < rows.length; i++) {
                t = rows[i].trim();
                if (!t) {
                    if (i === 0 || i === rows.length - 1) {
                        continue;
                    } else {
                        return false;
                    }
                }
                if (!/^:?-+:?$/.test(t)) {
                    return false;
                }
                if (t.charCodeAt(t.length - 1) === 58) {
                    aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
                } else if (t.charCodeAt(0) === 58) {
                    aligns.push("left");
                } else {
                    aligns.push("");
                }
            }
            lineText = getLine(state, startLine).trim();
            if (lineText.indexOf("|") === -1) {
                return false;
            }
            rows = escapedSplit(lineText.replace(/^\||\|$/g, ""));
            if (aligns.length !== rows.length) {
                return false;
            }
            if (silent) {
                return true;
            }
            token = state.push("table_open", "table", 1);
            token.map = tableLines = [ startLine, 0 ];
            token = state.push("thead_open", "thead", 1);
            token.map = [ startLine, startLine + 1 ];
            token = state.push("tr_open", "tr", 1);
            token.map = [ startLine, startLine + 1 ];
            for (i = 0; i < rows.length; i++) {
                token = state.push("th_open", "th", 1);
                token.map = [ startLine, startLine + 1 ];
                if (aligns[i]) {
                    token.attrs = [ [ "style", "text-align:" + aligns[i] ] ];
                }
                token = state.push("inline", "", 0);
                token.content = rows[i].trim();
                token.map = [ startLine, startLine + 1 ];
                token.children = [];
                token = state.push("th_close", "th", -1);
            }
            token = state.push("tr_close", "tr", -1);
            token = state.push("thead_close", "thead", -1);
            token = state.push("tbody_open", "tbody", 1);
            token.map = tbodyLines = [ startLine + 2, 0 ];
            for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
                if (state.tShift[nextLine] < state.blkIndent) {
                    break;
                }
                lineText = getLine(state, nextLine).trim();
                if (lineText.indexOf("|") === -1) {
                    break;
                }
                rows = escapedSplit(lineText.replace(/^\||\|$/g, ""));
                rows.length = aligns.length;
                token = state.push("tr_open", "tr", 1);
                for (i = 0; i < rows.length; i++) {
                    token = state.push("td_open", "td", 1);
                    if (aligns[i]) {
                        token.attrs = [ [ "style", "text-align:" + aligns[i] ] ];
                    }
                    token = state.push("inline", "", 0);
                    token.content = rows[i] ? rows[i].trim() : "";
                    token.children = [];
                    token = state.push("td_close", "td", -1);
                }
                token = state.push("tr_close", "tr", -1);
            }
            token = state.push("tbody_close", "tbody", -1);
            token = state.push("table_close", "table", -1);
            tableLines[1] = tbodyLines[1] = nextLine;
            state.line = nextLine;
            return true;
        };
    }, {} ],
    93: [ function(require, module, exports) {
        "use strict";
        module.exports = function block(state) {
            var token;
            if (state.inlineMode) {
                token = new state.Token("inline", "", 0);
                token.content = state.src;
                token.map = [ 0, 1 ];
                token.children = [];
                state.tokens.push(token);
            } else {
                state.md.block.parse(state.src, state.md, state.env, state.tokens);
            }
        };
    }, {} ],
    94: [ function(require, module, exports) {
        "use strict";
        module.exports = function inline(state) {
            var tokens = state.tokens, tok, i, l;
            for (i = 0, l = tokens.length; i < l; i++) {
                tok = tokens[i];
                if (tok.type === "inline") {
                    state.md.inline.parse(tok.content, state.md, state.env, tok.children);
                }
            }
        };
    }, {} ],
    95: [ function(require, module, exports) {
        "use strict";
        var arrayReplaceAt = require("../common/utils").arrayReplaceAt;
        function isLinkOpen(str) {
            return /^<a[>\s]/i.test(str);
        }
        function isLinkClose(str) {
            return /^<\/a\s*>/i.test(str);
        }
        module.exports = function linkify(state) {
            var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
            if (!state.md.options.linkify) {
                return;
            }
            for (j = 0, l = blockTokens.length; j < l; j++) {
                if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
                    continue;
                }
                tokens = blockTokens[j].children;
                htmlLinkLevel = 0;
                for (i = tokens.length - 1; i >= 0; i--) {
                    currentToken = tokens[i];
                    if (currentToken.type === "link_close") {
                        i--;
                        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
                            i--;
                        }
                        continue;
                    }
                    if (currentToken.type === "html_inline") {
                        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
                            htmlLinkLevel--;
                        }
                        if (isLinkClose(currentToken.content)) {
                            htmlLinkLevel++;
                        }
                    }
                    if (htmlLinkLevel > 0) {
                        continue;
                    }
                    if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
                        text = currentToken.content;
                        links = state.md.linkify.match(text);
                        nodes = [];
                        level = currentToken.level;
                        lastPos = 0;
                        for (ln = 0; ln < links.length; ln++) {
                            url = links[ln].url;
                            fullUrl = state.md.normalizeLink(url);
                            if (!state.md.validateLink(fullUrl)) {
                                continue;
                            }
                            urlText = links[ln].text;
                            if (!links[ln].schema) {
                                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
                            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
                            } else {
                                urlText = state.md.normalizeLinkText(urlText);
                            }
                            pos = links[ln].index;
                            if (pos > lastPos) {
                                token = new state.Token("text", "", 0);
                                token.content = text.slice(lastPos, pos);
                                token.level = level;
                                nodes.push(token);
                            }
                            token = new state.Token("link_open", "a", 1);
                            token.attrs = [ [ "href", fullUrl ] ];
                            token.level = level++;
                            token.markup = "linkify";
                            token.info = "auto";
                            nodes.push(token);
                            token = new state.Token("text", "", 0);
                            token.content = urlText;
                            token.level = level;
                            nodes.push(token);
                            token = new state.Token("link_close", "a", -1);
                            token.level = --level;
                            token.markup = "linkify";
                            token.info = "auto";
                            nodes.push(token);
                            lastPos = links[ln].lastIndex;
                        }
                        if (lastPos < text.length) {
                            token = new state.Token("text", "", 0);
                            token.content = text.slice(lastPos);
                            token.level = level;
                            nodes.push(token);
                        }
                        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
                    }
                }
            }
        };
    }, {
        "../common/utils": 67
    } ],
    96: [ function(require, module, exports) {
        "use strict";
        var TABS_SCAN_RE = /[\n\t]/g;
        var NEWLINES_RE = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
        var NULL_RE = /\u0000/g;
        module.exports = function inline(state) {
            var str, lineStart, lastTabPos;
            str = state.src.replace(NEWLINES_RE, "\n");
            str = str.replace(NULL_RE, "");
            if (str.indexOf("	") >= 0) {
                lineStart = 0;
                lastTabPos = 0;
                str = str.replace(TABS_SCAN_RE, function(match, offset) {
                    var result;
                    if (str.charCodeAt(offset) === 10) {
                        lineStart = offset + 1;
                        lastTabPos = 0;
                        return match;
                    }
                    result = "    ".slice((offset - lineStart - lastTabPos) % 4);
                    lastTabPos = offset - lineStart + 1;
                    return result;
                });
            }
            state.src = str;
        };
    }, {} ],
    97: [ function(require, module, exports) {
        "use strict";
        var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
        var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
        var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/gi;
        var SCOPED_ABBR = {
            c: "",
            r: "",
            p: "",
            tm: ""
        };
        function replaceFn(match, name) {
            return SCOPED_ABBR[name.toLowerCase()];
        }
        function replace_scoped(inlineTokens) {
            var i, token;
            for (i = inlineTokens.length - 1; i >= 0; i--) {
                token = inlineTokens[i];
                if (token.type === "text") {
                    token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
                }
            }
        }
        function replace_rare(inlineTokens) {
            var i, token;
            for (i = inlineTokens.length - 1; i >= 0; i--) {
                token = inlineTokens[i];
                if (token.type === "text") {
                    if (RARE_RE.test(token.content)) {
                        token.content = token.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---([^-]|$)/gm, "$1$2").replace(/(^|\s)--(\s|$)/gm, "$1$2").replace(/(^|[^-\s])--([^-\s]|$)/gm, "$1$2");
                    }
                }
            }
        }
        module.exports = function replace(state) {
            var blkIdx;
            if (!state.md.options.typographer) {
                return;
            }
            for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
                if (state.tokens[blkIdx].type !== "inline") {
                    continue;
                }
                if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
                    replace_scoped(state.tokens[blkIdx].children);
                }
                if (RARE_RE.test(state.tokens[blkIdx].content)) {
                    replace_rare(state.tokens[blkIdx].children);
                }
            }
        };
    }, {} ],
    98: [ function(require, module, exports) {
        "use strict";
        var isWhiteSpace = require("../common/utils").isWhiteSpace;
        var isPunctChar = require("../common/utils").isPunctChar;
        var isMdAsciiPunct = require("../common/utils").isMdAsciiPunct;
        var QUOTE_TEST_RE = /['"]/;
        var QUOTE_RE = /['"]/g;
        var APOSTROPHE = "";
        function replaceAt(str, index, ch) {
            return str.substr(0, index) + ch + str.substr(index + 1);
        }
        function process_inlines(tokens, state) {
            var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
            stack = [];
            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                thisLevel = tokens[i].level;
                for (j = stack.length - 1; j >= 0; j--) {
                    if (stack[j].level <= thisLevel) {
                        break;
                    }
                }
                stack.length = j + 1;
                if (token.type !== "text") {
                    continue;
                }
                text = token.content;
                pos = 0;
                max = text.length;
                OUTER: while (pos < max) {
                    QUOTE_RE.lastIndex = pos;
                    t = QUOTE_RE.exec(text);
                    if (!t) {
                        break;
                    }
                    canOpen = canClose = true;
                    pos = t.index + 1;
                    isSingle = t[0] === "'";
                    lastChar = t.index - 1 >= 0 ? text.charCodeAt(t.index - 1) : 32;
                    nextChar = pos < max ? text.charCodeAt(pos) : 32;
                    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
                    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
                    isLastWhiteSpace = isWhiteSpace(lastChar);
                    isNextWhiteSpace = isWhiteSpace(nextChar);
                    if (isNextWhiteSpace) {
                        canOpen = false;
                    } else if (isNextPunctChar) {
                        if (!(isLastWhiteSpace || isLastPunctChar)) {
                            canOpen = false;
                        }
                    }
                    if (isLastWhiteSpace) {
                        canClose = false;
                    } else if (isLastPunctChar) {
                        if (!(isNextWhiteSpace || isNextPunctChar)) {
                            canClose = false;
                        }
                    }
                    if (nextChar === 34 && t[0] === '"') {
                        if (lastChar >= 48 && lastChar <= 57) {
                            canClose = canOpen = false;
                        }
                    }
                    if (canOpen && canClose) {
                        canOpen = false;
                        canClose = isNextPunctChar;
                    }
                    if (!canOpen && !canClose) {
                        if (isSingle) {
                            token.content = replaceAt(token.content, t.index, APOSTROPHE);
                        }
                        continue;
                    }
                    if (canClose) {
                        for (j = stack.length - 1; j >= 0; j--) {
                            item = stack[j];
                            if (stack[j].level < thisLevel) {
                                break;
                            }
                            if (item.single === isSingle && stack[j].level === thisLevel) {
                                item = stack[j];
                                if (isSingle) {
                                    openQuote = state.md.options.quotes[2];
                                    closeQuote = state.md.options.quotes[3];
                                } else {
                                    openQuote = state.md.options.quotes[0];
                                    closeQuote = state.md.options.quotes[1];
                                }
                                token.content = replaceAt(token.content, t.index, closeQuote);
                                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                                pos += closeQuote.length - 1;
                                if (item.token === i) {
                                    pos += openQuote.length - 1;
                                }
                                text = token.content;
                                max = text.length;
                                stack.length = j;
                                continue OUTER;
                            }
                        }
                    }
                    if (canOpen) {
                        stack.push({
                            token: i,
                            pos: t.index,
                            single: isSingle,
                            level: thisLevel
                        });
                    } else if (canClose && isSingle) {
                        token.content = replaceAt(token.content, t.index, APOSTROPHE);
                    }
                }
            }
        }
        module.exports = function smartquotes(state) {
            var blkIdx;
            if (!state.md.options.typographer) {
                return;
            }
            for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
                if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
                    continue;
                }
                process_inlines(state.tokens[blkIdx].children, state);
            }
        };
    }, {
        "../common/utils": 67
    } ],
    99: [ function(require, module, exports) {
        "use strict";
        var Token = require("../token");
        function StateCore(src, md, env) {
            this.src = src;
            this.env = env;
            this.tokens = [];
            this.inlineMode = false;
            this.md = md;
        }
        StateCore.prototype.Token = Token;
        module.exports = StateCore;
    }, {
        "../token": 112
    } ],
    100: [ function(require, module, exports) {
        "use strict";
        var url_schemas = require("../common/url_schemas");
        var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
        var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;
        module.exports = function autolink(state, silent) {
            var tail, linkMatch, emailMatch, url, fullUrl, token, pos = state.pos;
            if (state.src.charCodeAt(pos) !== 60) {
                return false;
            }
            tail = state.src.slice(pos);
            if (tail.indexOf(">") < 0) {
                return false;
            }
            if (AUTOLINK_RE.test(tail)) {
                linkMatch = tail.match(AUTOLINK_RE);
                if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {
                    return false;
                }
                url = linkMatch[0].slice(1, -1);
                fullUrl = state.md.normalizeLink(url);
                if (!state.md.validateLink(fullUrl)) {
                    return false;
                }
                if (!silent) {
                    token = state.push("link_open", "a", 1);
                    token.attrs = [ [ "href", fullUrl ] ];
                    token = state.push("text", "", 0);
                    token.content = state.md.normalizeLinkText(url);
                    token = state.push("link_close", "a", -1);
                }
                state.pos += linkMatch[0].length;
                return true;
            }
            if (EMAIL_RE.test(tail)) {
                emailMatch = tail.match(EMAIL_RE);
                url = emailMatch[0].slice(1, -1);
                fullUrl = state.md.normalizeLink("mailto:" + url);
                if (!state.md.validateLink(fullUrl)) {
                    return false;
                }
                if (!silent) {
                    token = state.push("link_open", "a", 1);
                    token.attrs = [ [ "href", fullUrl ] ];
                    token.markup = "autolink";
                    token.info = "auto";
                    token = state.push("text", "", 0);
                    token.content = state.md.normalizeLinkText(url);
                    token = state.push("link_close", "a", -1);
                    token.markup = "autolink";
                    token.info = "auto";
                }
                state.pos += emailMatch[0].length;
                return true;
            }
            return false;
        };
    }, {
        "../common/url_schemas": 66
    } ],
    101: [ function(require, module, exports) {
        "use strict";
        module.exports = function backtick(state, silent) {
            var start, max, marker, matchStart, matchEnd, token, pos = state.pos, ch = state.src.charCodeAt(pos);
            if (ch !== 96) {
                return false;
            }
            start = pos;
            pos++;
            max = state.posMax;
            while (pos < max && state.src.charCodeAt(pos) === 96) {
                pos++;
            }
            marker = state.src.slice(start, pos);
            matchStart = matchEnd = pos;
            while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
                matchEnd = matchStart + 1;
                while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
                    matchEnd++;
                }
                if (matchEnd - matchStart === marker.length) {
                    if (!silent) {
                        token = state.push("code_inline", "code", 0);
                        token.markup = marker;
                        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, " ").trim();
                    }
                    state.pos = matchEnd;
                    return true;
                }
            }
            if (!silent) {
                state.pending += marker;
            }
            state.pos += marker.length;
            return true;
        };
    }, {} ],
    102: [ function(require, module, exports) {
        "use strict";
        var isWhiteSpace = require("../common/utils").isWhiteSpace;
        var isPunctChar = require("../common/utils").isPunctChar;
        var isMdAsciiPunct = require("../common/utils").isMdAsciiPunct;
        function scanDelims(state, start) {
            var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = state.posMax, marker = state.src.charCodeAt(start);
            lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 32;
            while (pos < max && state.src.charCodeAt(pos) === marker) {
                pos++;
            }
            count = pos - start;
            nextChar = pos < max ? state.src.charCodeAt(pos) : 32;
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
                left_flanking = false;
            } else if (isNextPunctChar) {
                if (!(isLastWhiteSpace || isLastPunctChar)) {
                    left_flanking = false;
                }
            }
            if (isLastWhiteSpace) {
                right_flanking = false;
            } else if (isLastPunctChar) {
                if (!(isNextWhiteSpace || isNextPunctChar)) {
                    right_flanking = false;
                }
            }
            if (marker === 95) {
                can_open = left_flanking && (!right_flanking || isLastPunctChar);
                can_close = right_flanking && (!left_flanking || isNextPunctChar);
            } else {
                can_open = left_flanking;
                can_close = right_flanking;
            }
            return {
                can_open: can_open,
                can_close: can_close,
                delims: count
            };
        }
        module.exports = function emphasis(state, silent) {
            var startCount, count, found, oldCount, newCount, stack, res, token, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);
            if (marker !== 95 && marker !== 42) {
                return false;
            }
            if (silent) {
                return false;
            }
            res = scanDelims(state, start);
            startCount = res.delims;
            if (!res.can_open) {
                state.pos += startCount;
                state.pending += state.src.slice(start, state.pos);
                return true;
            }
            state.pos = start + startCount;
            stack = [ startCount ];
            while (state.pos < max) {
                if (state.src.charCodeAt(state.pos) === marker) {
                    res = scanDelims(state, state.pos);
                    count = res.delims;
                    if (res.can_close) {
                        oldCount = stack.pop();
                        newCount = count;
                        while (oldCount !== newCount) {
                            if (newCount < oldCount) {
                                stack.push(oldCount - newCount);
                                break;
                            }
                            newCount -= oldCount;
                            if (stack.length === 0) {
                                break;
                            }
                            state.pos += oldCount;
                            oldCount = stack.pop();
                        }
                        if (stack.length === 0) {
                            startCount = oldCount;
                            found = true;
                            break;
                        }
                        state.pos += count;
                        continue;
                    }
                    if (res.can_open) {
                        stack.push(count);
                    }
                    state.pos += count;
                    continue;
                }
                state.md.inline.skipToken(state);
            }
            if (!found) {
                state.pos = start;
                return false;
            }
            state.posMax = state.pos;
            state.pos = start + startCount;
            for (count = startCount; count > 1; count -= 2) {
                token = state.push("strong_open", "strong", 1);
                token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);
            }
            if (count % 2) {
                token = state.push("em_open", "em", 1);
                token.markup = String.fromCharCode(marker);
            }
            state.md.inline.tokenize(state);
            if (count % 2) {
                token = state.push("em_close", "em", -1);
                token.markup = String.fromCharCode(marker);
            }
            for (count = startCount; count > 1; count -= 2) {
                token = state.push("strong_close", "strong", -1);
                token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);
            }
            state.pos = state.posMax + startCount;
            state.posMax = max;
            return true;
        };
    }, {
        "../common/utils": 67
    } ],
    103: [ function(require, module, exports) {
        "use strict";
        var entities = require("../common/entities");
        var has = require("../common/utils").has;
        var isValidEntityCode = require("../common/utils").isValidEntityCode;
        var fromCodePoint = require("../common/utils").fromCodePoint;
        var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
        var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
        module.exports = function entity(state, silent) {
            var ch, code, match, pos = state.pos, max = state.posMax;
            if (state.src.charCodeAt(pos) !== 38) {
                return false;
            }
            if (pos + 1 < max) {
                ch = state.src.charCodeAt(pos + 1);
                if (ch === 35) {
                    match = state.src.slice(pos).match(DIGITAL_RE);
                    if (match) {
                        if (!silent) {
                            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
                            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
                        }
                        state.pos += match[0].length;
                        return true;
                    }
                } else {
                    match = state.src.slice(pos).match(NAMED_RE);
                    if (match) {
                        if (has(entities, match[1])) {
                            if (!silent) {
                                state.pending += entities[match[1]];
                            }
                            state.pos += match[0].length;
                            return true;
                        }
                    }
                }
            }
            if (!silent) {
                state.pending += "&";
            }
            state.pos++;
            return true;
        };
    }, {
        "../common/entities": 63,
        "../common/utils": 67
    } ],
    104: [ function(require, module, exports) {
        "use strict";
        var ESCAPED = [];
        for (var i = 0; i < 256; i++) {
            ESCAPED.push(0);
        }
        "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
            ESCAPED[ch.charCodeAt(0)] = 1;
        });
        module.exports = function escape(state, silent) {
            var ch, pos = state.pos, max = state.posMax;
            if (state.src.charCodeAt(pos) !== 92) {
                return false;
            }
            pos++;
            if (pos < max) {
                ch = state.src.charCodeAt(pos);
                if (ch < 256 && ESCAPED[ch] !== 0) {
                    if (!silent) {
                        state.pending += state.src[pos];
                    }
                    state.pos += 2;
                    return true;
                }
                if (ch === 10) {
                    if (!silent) {
                        state.push("hardbreak", "br", 0);
                    }
                    pos++;
                    while (pos < max && state.src.charCodeAt(pos) === 32) {
                        pos++;
                    }
                    state.pos = pos;
                    return true;
                }
            }
            if (!silent) {
                state.pending += "\\";
            }
            state.pos++;
            return true;
        };
    }, {} ],
    105: [ function(require, module, exports) {
        "use strict";
        var HTML_TAG_RE = require("../common/html_re").HTML_TAG_RE;
        function isLetter(ch) {
            var lc = ch | 32;
            return lc >= 97 && lc <= 122;
        }
        module.exports = function html_inline(state, silent) {
            var ch, match, max, token, pos = state.pos;
            if (!state.md.options.html) {
                return false;
            }
            max = state.posMax;
            if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
                return false;
            }
            ch = state.src.charCodeAt(pos + 1);
            if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
                return false;
            }
            match = state.src.slice(pos).match(HTML_TAG_RE);
            if (!match) {
                return false;
            }
            if (!silent) {
                token = state.push("html_inline", "", 0);
                token.content = state.src.slice(pos, pos + match[0].length);
            }
            state.pos += match[0].length;
            return true;
        };
    }, {
        "../common/html_re": 65
    } ],
    106: [ function(require, module, exports) {
        "use strict";
        var parseLinkLabel = require("../helpers/parse_link_label");
        var parseLinkDestination = require("../helpers/parse_link_destination");
        var parseLinkTitle = require("../helpers/parse_link_title");
        var normalizeReference = require("../common/utils").normalizeReference;
        module.exports = function image(state, silent) {
            var attrs, code, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
            if (state.src.charCodeAt(state.pos) !== 33) {
                return false;
            }
            if (state.src.charCodeAt(state.pos + 1) !== 91) {
                return false;
            }
            labelStart = state.pos + 2;
            labelEnd = parseLinkLabel(state, state.pos + 1, false);
            if (labelEnd < 0) {
                return false;
            }
            pos = labelEnd + 1;
            if (pos < max && state.src.charCodeAt(pos) === 40) {
                pos++;
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                if (pos >= max) {
                    return false;
                }
                start = pos;
                res = parseLinkDestination(state.src, pos, state.posMax);
                if (res.ok) {
                    href = state.md.normalizeLink(res.str);
                    if (state.md.validateLink(href)) {
                        pos = res.pos;
                    } else {
                        href = "";
                    }
                }
                start = pos;
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                res = parseLinkTitle(state.src, pos, state.posMax);
                if (pos < max && start !== pos && res.ok) {
                    title = res.str;
                    pos = res.pos;
                    for (;pos < max; pos++) {
                        code = state.src.charCodeAt(pos);
                        if (code !== 32 && code !== 10) {
                            break;
                        }
                    }
                } else {
                    title = "";
                }
                if (pos >= max || state.src.charCodeAt(pos) !== 41) {
                    state.pos = oldPos;
                    return false;
                }
                pos++;
            } else {
                if (typeof state.env.references === "undefined") {
                    return false;
                }
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                if (pos < max && state.src.charCodeAt(pos) === 91) {
                    start = pos + 1;
                    pos = parseLinkLabel(state, pos);
                    if (pos >= 0) {
                        label = state.src.slice(start, pos++);
                    } else {
                        pos = labelEnd + 1;
                    }
                } else {
                    pos = labelEnd + 1;
                }
                if (!label) {
                    label = state.src.slice(labelStart, labelEnd);
                }
                ref = state.env.references[normalizeReference(label)];
                if (!ref) {
                    state.pos = oldPos;
                    return false;
                }
                href = ref.href;
                title = ref.title;
            }
            if (!silent) {
                state.pos = labelStart;
                state.posMax = labelEnd;
                var newState = new state.md.inline.State(state.src.slice(labelStart, labelEnd), state.md, state.env, tokens = []);
                newState.md.inline.tokenize(newState);
                token = state.push("image", "img", 0);
                token.attrs = attrs = [ [ "src", href ], [ "alt", "" ] ];
                token.children = tokens;
                if (title) {
                    attrs.push([ "title", title ]);
                }
            }
            state.pos = pos;
            state.posMax = max;
            return true;
        };
    }, {
        "../common/utils": 67,
        "../helpers/parse_link_destination": 69,
        "../helpers/parse_link_label": 70,
        "../helpers/parse_link_title": 71
    } ],
    107: [ function(require, module, exports) {
        "use strict";
        var parseLinkLabel = require("../helpers/parse_link_label");
        var parseLinkDestination = require("../helpers/parse_link_destination");
        var parseLinkTitle = require("../helpers/parse_link_title");
        var normalizeReference = require("../common/utils").normalizeReference;
        module.exports = function link(state, silent) {
            var attrs, code, label, labelEnd, labelStart, pos, res, ref, title, token, href = "", oldPos = state.pos, max = state.posMax, start = state.pos;
            if (state.src.charCodeAt(state.pos) !== 91) {
                return false;
            }
            labelStart = state.pos + 1;
            labelEnd = parseLinkLabel(state, state.pos, true);
            if (labelEnd < 0) {
                return false;
            }
            pos = labelEnd + 1;
            if (pos < max && state.src.charCodeAt(pos) === 40) {
                pos++;
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                if (pos >= max) {
                    return false;
                }
                start = pos;
                res = parseLinkDestination(state.src, pos, state.posMax);
                if (res.ok) {
                    href = state.md.normalizeLink(res.str);
                    if (state.md.validateLink(href)) {
                        pos = res.pos;
                    } else {
                        href = "";
                    }
                }
                start = pos;
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                res = parseLinkTitle(state.src, pos, state.posMax);
                if (pos < max && start !== pos && res.ok) {
                    title = res.str;
                    pos = res.pos;
                    for (;pos < max; pos++) {
                        code = state.src.charCodeAt(pos);
                        if (code !== 32 && code !== 10) {
                            break;
                        }
                    }
                } else {
                    title = "";
                }
                if (pos >= max || state.src.charCodeAt(pos) !== 41) {
                    state.pos = oldPos;
                    return false;
                }
                pos++;
            } else {
                if (typeof state.env.references === "undefined") {
                    return false;
                }
                for (;pos < max; pos++) {
                    code = state.src.charCodeAt(pos);
                    if (code !== 32 && code !== 10) {
                        break;
                    }
                }
                if (pos < max && state.src.charCodeAt(pos) === 91) {
                    start = pos + 1;
                    pos = parseLinkLabel(state, pos);
                    if (pos >= 0) {
                        label = state.src.slice(start, pos++);
                    } else {
                        pos = labelEnd + 1;
                    }
                } else {
                    pos = labelEnd + 1;
                }
                if (!label) {
                    label = state.src.slice(labelStart, labelEnd);
                }
                ref = state.env.references[normalizeReference(label)];
                if (!ref) {
                    state.pos = oldPos;
                    return false;
                }
                href = ref.href;
                title = ref.title;
            }
            if (!silent) {
                state.pos = labelStart;
                state.posMax = labelEnd;
                token = state.push("link_open", "a", 1);
                token.attrs = attrs = [ [ "href", href ] ];
                if (title) {
                    attrs.push([ "title", title ]);
                }
                state.md.inline.tokenize(state);
                token = state.push("link_close", "a", -1);
            }
            state.pos = pos;
            state.posMax = max;
            return true;
        };
    }, {
        "../common/utils": 67,
        "../helpers/parse_link_destination": 69,
        "../helpers/parse_link_label": 70,
        "../helpers/parse_link_title": 71
    } ],
    108: [ function(require, module, exports) {
        "use strict";
        module.exports = function newline(state, silent) {
            var pmax, max, pos = state.pos;
            if (state.src.charCodeAt(pos) !== 10) {
                return false;
            }
            pmax = state.pending.length - 1;
            max = state.posMax;
            if (!silent) {
                if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
                    if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
                        state.pending = state.pending.replace(/ +$/, "");
                        state.push("hardbreak", "br", 0);
                    } else {
                        state.pending = state.pending.slice(0, -1);
                        state.push("softbreak", "br", 0);
                    }
                } else {
                    state.push("softbreak", "br", 0);
                }
            }
            pos++;
            while (pos < max && state.src.charCodeAt(pos) === 32) {
                pos++;
            }
            state.pos = pos;
            return true;
        };
    }, {} ],
    109: [ function(require, module, exports) {
        "use strict";
        var Token = require("../token");
        function StateInline(src, md, env, outTokens) {
            this.src = src;
            this.env = env;
            this.md = md;
            this.tokens = outTokens;
            this.pos = 0;
            this.posMax = this.src.length;
            this.level = 0;
            this.pending = "";
            this.pendingLevel = 0;
            this.cache = {};
        }
        StateInline.prototype.pushPending = function() {
            var token = new Token("text", "", 0);
            token.content = this.pending;
            token.level = this.pendingLevel;
            this.tokens.push(token);
            this.pending = "";
            return token;
        };
        StateInline.prototype.push = function(type, tag, nesting) {
            if (this.pending) {
                this.pushPending();
            }
            var token = new Token(type, tag, nesting);
            if (nesting < 0) {
                this.level--;
            }
            token.level = this.level;
            if (nesting > 0) {
                this.level++;
            }
            this.pendingLevel = this.level;
            this.tokens.push(token);
            return token;
        };
        StateInline.prototype.Token = Token;
        module.exports = StateInline;
    }, {
        "../token": 112
    } ],
    110: [ function(require, module, exports) {
        "use strict";
        var isWhiteSpace = require("../common/utils").isWhiteSpace;
        var isPunctChar = require("../common/utils").isPunctChar;
        var isMdAsciiPunct = require("../common/utils").isMdAsciiPunct;
        function scanDelims(state, start) {
            var pos = start, lastChar, nextChar, count, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, can_open = true, can_close = true, max = state.posMax, marker = state.src.charCodeAt(start);
            lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 32;
            while (pos < max && state.src.charCodeAt(pos) === marker) {
                pos++;
            }
            if (pos >= max) {
                can_open = false;
            }
            count = pos - start;
            nextChar = pos < max ? state.src.charCodeAt(pos) : 32;
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
                can_open = false;
            } else if (isNextPunctChar) {
                if (!(isLastWhiteSpace || isLastPunctChar)) {
                    can_open = false;
                }
            }
            if (isLastWhiteSpace) {
                can_close = false;
            } else if (isLastPunctChar) {
                if (!(isNextWhiteSpace || isNextPunctChar)) {
                    can_close = false;
                }
            }
            return {
                can_open: can_open,
                can_close: can_close,
                delims: count
            };
        }
        module.exports = function strikethrough(state, silent) {
            var startCount, count, tagCount, found, stack, res, token, max = state.posMax, start = state.pos, marker = state.src.charCodeAt(start);
            if (marker !== 126) {
                return false;
            }
            if (silent) {
                return false;
            }
            res = scanDelims(state, start);
            startCount = res.delims;
            if (!res.can_open) {
                state.pos += startCount;
                state.pending += state.src.slice(start, state.pos);
                return true;
            }
            stack = Math.floor(startCount / 2);
            if (stack <= 0) {
                return false;
            }
            state.pos = start + startCount;
            while (state.pos < max) {
                if (state.src.charCodeAt(state.pos) === marker) {
                    res = scanDelims(state, state.pos);
                    count = res.delims;
                    tagCount = Math.floor(count / 2);
                    if (res.can_close) {
                        if (tagCount >= stack) {
                            state.pos += count - 2;
                            found = true;
                            break;
                        }
                        stack -= tagCount;
                        state.pos += count;
                        continue;
                    }
                    if (res.can_open) {
                        stack += tagCount;
                    }
                    state.pos += count;
                    continue;
                }
                state.md.inline.skipToken(state);
            }
            if (!found) {
                state.pos = start;
                return false;
            }
            state.posMax = state.pos;
            state.pos = start + 2;
            token = state.push("s_open", "s", 1);
            token.markup = "~~";
            state.md.inline.tokenize(state);
            token = state.push("s_close", "s", -1);
            token.markup = "~~";
            state.pos = state.posMax + 2;
            state.posMax = max;
            return true;
        };
    }, {
        "../common/utils": 67
    } ],
    111: [ function(require, module, exports) {
        "use strict";
        function isTerminatorChar(ch) {
            switch (ch) {
              case 10:
              case 33:
              case 35:
              case 36:
              case 37:
              case 38:
              case 42:
              case 43:
              case 45:
              case 58:
              case 60:
              case 61:
              case 62:
              case 64:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 123:
              case 125:
              case 126:
                return true;

              default:
                return false;
            }
        }
        module.exports = function text(state, silent) {
            var pos = state.pos;
            while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
                pos++;
            }
            if (pos === state.pos) {
                return false;
            }
            if (!silent) {
                state.pending += state.src.slice(state.pos, pos);
            }
            state.pos = pos;
            return true;
        };
    }, {} ],
    112: [ function(require, module, exports) {
        "use strict";
        function Token(type, tag, nesting) {
            this.type = type;
            this.tag = tag;
            this.attrs = null;
            this.map = null;
            this.nesting = nesting;
            this.level = 0;
            this.children = null;
            this.content = "";
            this.markup = "";
            this.info = "";
            this.meta = null;
            this.block = false;
            this.hidden = false;
        }
        Token.prototype.attrIndex = function attrIndex(name) {
            var attrs, i, len;
            if (!this.attrs) {
                return -1;
            }
            attrs = this.attrs;
            for (i = 0, len = attrs.length; i < len; i++) {
                if (attrs[i][0] === name) {
                    return i;
                }
            }
            return -1;
        };
        Token.prototype.attrPush = function attrPush(attrData) {
            if (this.attrs) {
                this.attrs.push(attrData);
            } else {
                this.attrs = [ attrData ];
            }
        };
        module.exports = Token;
    }, {} ],
    113: [ function(require, module, exports) {
        arguments[4][54][0].apply(exports, arguments);
    }, {
        dup: 54
    } ],
    114: [ function(require, module, exports) {
        "use strict";
        function assign(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            sources.forEach(function(source) {
                if (!source) {
                    return;
                }
                Object.keys(source).forEach(function(key) {
                    obj[key] = source[key];
                });
            });
            return obj;
        }
        function _class(obj) {
            return Object.prototype.toString.call(obj);
        }
        function isString(obj) {
            return _class(obj) === "[object String]";
        }
        function isObject(obj) {
            return _class(obj) === "[object Object]";
        }
        function isRegExp(obj) {
            return _class(obj) === "[object RegExp]";
        }
        function isFunction(obj) {
            return _class(obj) === "[object Function]";
        }
        function escapeRE(str) {
            return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
        }
        var defaultOptions = {
            fuzzyLink: true,
            fuzzyEmail: true,
            fuzzyIP: false
        };
        function isOptionsObj(obj) {
            return Object.keys(obj || {}).reduce(function(acc, k) {
                return acc || defaultOptions.hasOwnProperty(k);
            }, false);
        }
        var defaultSchemas = {
            "http:": {
                validate: function(text, pos, self) {
                    var tail = text.slice(pos);
                    if (!self.re.http) {
                        self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
                    }
                    if (self.re.http.test(tail)) {
                        return tail.match(self.re.http)[0].length;
                    }
                    return 0;
                }
            },
            "https:": "http:",
            "ftp:": "http:",
            "//": {
                validate: function(text, pos, self) {
                    var tail = text.slice(pos);
                    if (!self.re.no_http) {
                        self.re.no_http = new RegExp("^" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
                    }
                    if (self.re.no_http.test(tail)) {
                        if (pos >= 3 && text[pos - 3] === ":") {
                            return 0;
                        }
                        return tail.match(self.re.no_http)[0].length;
                    }
                    return 0;
                }
            },
            "mailto:": {
                validate: function(text, pos, self) {
                    var tail = text.slice(pos);
                    if (!self.re.mailto) {
                        self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
                    }
                    if (self.re.mailto.test(tail)) {
                        return tail.match(self.re.mailto)[0].length;
                    }
                    return 0;
                }
            }
        };
        var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
        var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
        function resetScanCache(self) {
            self.__index__ = -1;
            self.__text_cache__ = "";
        }
        function createValidator(re) {
            return function(text, pos) {
                var tail = text.slice(pos);
                if (re.test(tail)) {
                    return tail.match(re)[0].length;
                }
                return 0;
            };
        }
        function createNormalizer() {
            return function(match, self) {
                self.normalize(match);
            };
        }
        function compile(self) {
            var re = self.re = assign({}, require("./lib/re"));
            var tlds = self.__tlds__.slice();
            if (!self.__tlds_replaced__) {
                tlds.push(tlds_2ch_src_re);
            }
            tlds.push(re.src_xn);
            re.src_tlds = tlds.join("|");
            function untpl(tpl) {
                return tpl.replace("%TLDS%", re.src_tlds);
            }
            re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
            re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
            re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
            re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
            var aliases = [];
            self.__compiled__ = {};
            function schemaError(name, val) {
                throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
            }
            Object.keys(self.__schemas__).forEach(function(name) {
                var val = self.__schemas__[name];
                if (val === null) {
                    return;
                }
                var compiled = {
                    validate: null,
                    link: null
                };
                self.__compiled__[name] = compiled;
                if (isObject(val)) {
                    if (isRegExp(val.validate)) {
                        compiled.validate = createValidator(val.validate);
                    } else if (isFunction(val.validate)) {
                        compiled.validate = val.validate;
                    } else {
                        schemaError(name, val);
                    }
                    if (isFunction(val.normalize)) {
                        compiled.normalize = val.normalize;
                    } else if (!val.normalize) {
                        compiled.normalize = createNormalizer();
                    } else {
                        schemaError(name, val);
                    }
                    return;
                }
                if (isString(val)) {
                    aliases.push(name);
                    return;
                }
                schemaError(name, val);
            });
            aliases.forEach(function(alias) {
                if (!self.__compiled__[self.__schemas__[alias]]) {
                    return;
                }
                self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
                self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
            });
            self.__compiled__[""] = {
                validate: null,
                normalize: createNormalizer()
            };
            var slist = Object.keys(self.__compiled__).filter(function(name) {
                return name.length > 0 && self.__compiled__[name];
            }).map(escapeRE).join("|");
            self.re.schema_test = RegExp("(^|(?!_)(?:>|" + re.src_ZPCc + "))(" + slist + ")", "i");
            self.re.schema_search = RegExp("(^|(?!_)(?:>|" + re.src_ZPCc + "))(" + slist + ")", "ig");
            self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|" + "(" + self.re.host_fuzzy_test.source + ")|" + "@", "i");
            resetScanCache(self);
        }
        function Match(self, shift) {
            var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);
            this.schema = self.__schema__.toLowerCase();
            this.index = start + shift;
            this.lastIndex = end + shift;
            this.raw = text;
            this.text = text;
            this.url = text;
        }
        function createMatch(self, shift) {
            var match = new Match(self, shift);
            self.__compiled__[match.schema].normalize(match, self);
            return match;
        }
        function LinkifyIt(schemas, options) {
            if (!(this instanceof LinkifyIt)) {
                return new LinkifyIt(schemas, options);
            }
            if (!options) {
                if (isOptionsObj(schemas)) {
                    options = schemas;
                    schemas = {};
                }
            }
            this.__opts__ = assign({}, defaultOptions, options);
            this.__index__ = -1;
            this.__last_index__ = -1;
            this.__schema__ = "";
            this.__text_cache__ = "";
            this.__schemas__ = assign({}, defaultSchemas, schemas);
            this.__compiled__ = {};
            this.__tlds__ = tlds_default;
            this.__tlds_replaced__ = false;
            this.re = {};
            compile(this);
        }
        LinkifyIt.prototype.add = function add(schema, definition) {
            this.__schemas__[schema] = definition;
            compile(this);
            return this;
        };
        LinkifyIt.prototype.set = function set(options) {
            this.__opts__ = assign(this.__opts__, options);
            return this;
        };
        LinkifyIt.prototype.test = function test(text) {
            this.__text_cache__ = text;
            this.__index__ = -1;
            if (!text.length) {
                return false;
            }
            var m, ml, me, len, shift, next, re, tld_pos, at_pos;
            if (this.re.schema_test.test(text)) {
                re = this.re.schema_search;
                re.lastIndex = 0;
                while ((m = re.exec(text)) !== null) {
                    len = this.testSchemaAt(text, m[2], re.lastIndex);
                    if (len) {
                        this.__schema__ = m[2];
                        this.__index__ = m.index + m[1].length;
                        this.__last_index__ = m.index + m[0].length + len;
                        break;
                    }
                }
            }
            if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
                tld_pos = text.search(this.re.host_fuzzy_test);
                if (tld_pos >= 0) {
                    if (this.__index__ < 0 || tld_pos < this.__index__) {
                        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
                            shift = ml.index + ml[1].length;
                            if (this.__index__ < 0 || shift < this.__index__) {
                                this.__schema__ = "";
                                this.__index__ = shift;
                                this.__last_index__ = ml.index + ml[0].length;
                            }
                        }
                    }
                }
            }
            if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
                at_pos = text.indexOf("@");
                if (at_pos >= 0) {
                    if ((me = text.match(this.re.email_fuzzy)) !== null) {
                        shift = me.index + me[1].length;
                        next = me.index + me[0].length;
                        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
                            this.__schema__ = "mailto:";
                            this.__index__ = shift;
                            this.__last_index__ = next;
                        }
                    }
                }
            }
            return this.__index__ >= 0;
        };
        LinkifyIt.prototype.pretest = function pretest(text) {
            return this.re.pretest.test(text);
        };
        LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
            if (!this.__compiled__[schema.toLowerCase()]) {
                return 0;
            }
            return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
        };
        LinkifyIt.prototype.match = function match(text) {
            var shift = 0, result = [];
            if (this.__index__ >= 0 && this.__text_cache__ === text) {
                result.push(createMatch(this, shift));
                shift = this.__last_index__;
            }
            var tail = shift ? text.slice(shift) : text;
            while (this.test(tail)) {
                result.push(createMatch(this, shift));
                tail = tail.slice(this.__last_index__);
                shift += this.__last_index__;
            }
            if (result.length) {
                return result;
            }
            return null;
        };
        LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
            list = Array.isArray(list) ? list : [ list ];
            if (!keepOld) {
                this.__tlds__ = list.slice();
                this.__tlds_replaced__ = true;
                compile(this);
                return this;
            }
            this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
                return el !== arr[idx - 1];
            }).reverse();
            compile(this);
            return this;
        };
        LinkifyIt.prototype.normalize = function normalize(match) {
            if (!match.schema) {
                match.url = "http://" + match.url;
            }
            if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
                match.url = "mailto:" + match.url;
            }
        };
        module.exports = LinkifyIt;
    }, {
        "./lib/re": 115
    } ],
    115: [ function(require, module, exports) {
        "use strict";
        var src_Any = exports.src_Any = require("uc.micro/properties/Any/regex").source;
        var src_Cc = exports.src_Cc = require("uc.micro/categories/Cc/regex").source;
        var src_Z = exports.src_Z = require("uc.micro/categories/Z/regex").source;
        var src_P = exports.src_P = require("uc.micro/categories/P/regex").source;
        var src_ZPCc = exports.src_ZPCc = [ src_Z, src_P, src_Cc ].join("|");
        var src_ZCc = exports.src_ZCc = [ src_Z, src_Cc ].join("|");
        var src_pseudo_letter = "(?:(?!" + src_ZPCc + ")" + src_Any + ")";
        var src_pseudo_letter_non_d = "(?:(?![0-9]|" + src_ZPCc + ")" + src_Any + ")";
        var src_ip4 = exports.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
        exports.src_auth = "(?:(?:(?!" + src_ZCc + ").)+@)?";
        var src_port = exports.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
        var src_host_terminator = exports.src_host_terminator = "(?=$|" + src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + src_ZPCc + "))";
        var src_path = exports.src_path = "(?:" + "[/?#]" + "(?:" + "(?!" + src_ZCc + "|[()[\\]{}.,\"'?!\\-]).|" + "\\[(?:(?!" + src_ZCc + "|\\]).)*\\]|" + "\\((?:(?!" + src_ZCc + "|[)]).)*\\)|" + "\\{(?:(?!" + src_ZCc + "|[}]).)*\\}|" + '\\"(?:(?!' + src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + src_ZCc + "|[']).)+\\'|" + "\\'(?=" + src_pseudo_letter + ").|" + "\\.{2,3}[a-zA-Z0-9%/]|" + "\\.(?!" + src_ZCc + "|[.]).|" + "\\-(?!--(?:[^-]|$))(?:-*)|" + "\\,(?!" + src_ZCc + ").|" + "\\!(?!" + src_ZCc + "|[!]).|" + "\\?(?!" + src_ZCc + "|[?])." + ")+" + "|\\/" + ")?";
        var src_email_name = exports.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';
        var src_xn = exports.src_xn = "xn--[a-z0-9\\-]{1,59}";
        var src_domain_root = exports.src_domain_root = "(?:" + src_xn + "|" + src_pseudo_letter_non_d + "{1,63}" + ")";
        var src_domain = exports.src_domain = "(?:" + src_xn + "|" + "(?:" + src_pseudo_letter + ")" + "|" + "(?:" + src_pseudo_letter + "(?:-(?!-)|" + src_pseudo_letter + "){0,61}" + src_pseudo_letter + ")" + ")";
        var src_host = exports.src_host = "(?:" + src_ip4 + "|" + "(?:(?:(?:" + src_domain + ")\\.)*" + src_domain_root + ")" + ")";
        var tpl_host_fuzzy = exports.tpl_host_fuzzy = "(?:" + src_ip4 + "|" + "(?:(?:(?:" + src_domain + ")\\.)+(?:%TLDS%))" + ")";
        var tpl_host_no_ip_fuzzy = exports.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + src_domain + ")\\.)+(?:%TLDS%))";
        exports.src_host_strict = src_host + src_host_terminator;
        var tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict = tpl_host_fuzzy + src_host_terminator;
        exports.src_host_port_strict = src_host + src_port + src_host_terminator;
        var tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict = tpl_host_fuzzy + src_port + src_host_terminator;
        var tpl_host_port_no_ip_fuzzy_strict = exports.tpl_host_port_no_ip_fuzzy_strict = tpl_host_no_ip_fuzzy + src_port + src_host_terminator;
        exports.tpl_host_fuzzy_test = "localhost|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + src_ZPCc + "|$))";
        exports.tpl_email_fuzzy = "(^|>|" + src_ZCc + ")(" + src_email_name + "@" + tpl_host_fuzzy_strict + ")";
        exports.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + src_ZPCc + "))" + "((?![$+<=>^`|])" + tpl_host_port_fuzzy_strict + src_path + ")";
        exports.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + src_ZPCc + "))" + "((?![$+<=>^`|])" + tpl_host_port_no_ip_fuzzy_strict + src_path + ")";
    }, {
        "uc.micro/categories/Cc/regex": 121,
        "uc.micro/categories/P/regex": 123,
        "uc.micro/categories/Z/regex": 124,
        "uc.micro/properties/Any/regex": 126
    } ],
    116: [ function(require, module, exports) {
        "use strict";
        var decodeCache = {};
        function getDecodeCache(exclude) {
            var i, ch, cache = decodeCache[exclude];
            if (cache) {
                return cache;
            }
            cache = decodeCache[exclude] = [];
            for (i = 0; i < 128; i++) {
                ch = String.fromCharCode(i);
                cache.push(ch);
            }
            for (i = 0; i < exclude.length; i++) {
                ch = exclude.charCodeAt(i);
                cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
            }
            return cache;
        }
        function decode(string, exclude) {
            var cache;
            if (typeof exclude !== "string") {
                exclude = decode.defaultChars;
            }
            cache = getDecodeCache(exclude);
            return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
                var i, l, b1, b2, b3, b4, char, result = "";
                for (i = 0, l = seq.length; i < l; i += 3) {
                    b1 = parseInt(seq.slice(i + 1, i + 3), 16);
                    if (b1 < 128) {
                        result += cache[b1];
                        continue;
                    }
                    if ((b1 & 224) === 192 && i + 3 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        if ((b2 & 192) === 128) {
                            char = b1 << 6 & 1984 | b2 & 63;
                            if (char < 128) {
                                result += "";
                            } else {
                                result += String.fromCharCode(char);
                            }
                            i += 3;
                            continue;
                        }
                    }
                    if ((b1 & 240) === 224 && i + 6 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
                        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
                            char = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
                            if (char < 2048 || char >= 55296 && char <= 57343) {
                                result += "";
                            } else {
                                result += String.fromCharCode(char);
                            }
                            i += 6;
                            continue;
                        }
                    }
                    if ((b1 & 248) === 240 && i + 9 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
                        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
                        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
                            char = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
                            if (char < 65536 || char > 1114111) {
                                result += "";
                            } else {
                                char -= 65536;
                                result += String.fromCharCode(55296 + (char >> 10), 56320 + (char & 1023));
                            }
                            i += 9;
                            continue;
                        }
                    }
                    result += "";
                }
                return result;
            });
        }
        decode.defaultChars = ";/?:@&=+$,#";
        decode.componentChars = "";
        module.exports = decode;
    }, {} ],
    117: [ function(require, module, exports) {
        "use strict";
        var encodeCache = {};
        function getEncodeCache(exclude) {
            var i, ch, cache = encodeCache[exclude];
            if (cache) {
                return cache;
            }
            cache = encodeCache[exclude] = [];
            for (i = 0; i < 128; i++) {
                ch = String.fromCharCode(i);
                if (/^[0-9a-z]$/i.test(ch)) {
                    cache.push(ch);
                } else {
                    cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
                }
            }
            for (i = 0; i < exclude.length; i++) {
                cache[exclude.charCodeAt(i)] = exclude[i];
            }
            return cache;
        }
        function encode(string, exclude, keepEscaped) {
            var i, l, code, nextCode, cache, result = "";
            if (typeof exclude !== "string") {
                keepEscaped = exclude;
                exclude = encode.defaultChars;
            }
            if (typeof keepEscaped === "undefined") {
                keepEscaped = true;
            }
            cache = getEncodeCache(exclude);
            for (i = 0, l = string.length; i < l; i++) {
                code = string.charCodeAt(i);
                if (keepEscaped && code === 37 && i + 2 < l) {
                    if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                        result += string.slice(i, i + 3);
                        i += 2;
                        continue;
                    }
                }
                if (code < 128) {
                    result += cache[code];
                    continue;
                }
                if (code >= 55296 && code <= 57343) {
                    if (code >= 55296 && code <= 56319 && i + 1 < l) {
                        nextCode = string.charCodeAt(i + 1);
                        if (nextCode >= 56320 && nextCode <= 57343) {
                            result += encodeURIComponent(string[i] + string[i + 1]);
                            i++;
                            continue;
                        }
                    }
                    result += "%EF%BF%BD";
                    continue;
                }
                result += encodeURIComponent(string[i]);
            }
            return result;
        }
        encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
        encode.componentChars = "-_.!~*'()";
        module.exports = encode;
    }, {} ],
    118: [ function(require, module, exports) {
        "use strict";
        module.exports = function format(url) {
            var result = "";
            result += url.protocol || "";
            result += url.slashes ? "//" : "";
            result += url.auth ? url.auth + "@" : "";
            if (url.hostname && url.hostname.indexOf(":") !== -1) {
                result += "[" + url.hostname + "]";
            } else {
                result += url.hostname || "";
            }
            result += url.port ? ":" + url.port : "";
            result += url.pathname || "";
            result += url.search || "";
            result += url.hash || "";
            return result;
        };
    }, {} ],
    119: [ function(require, module, exports) {
        "use strict";
        module.exports.encode = require("./encode");
        module.exports.decode = require("./decode");
        module.exports.format = require("./format");
        module.exports.parse = require("./parse");
    }, {
        "./decode": 116,
        "./encode": 117,
        "./format": 118,
        "./parse": 120
    } ],
    120: [ function(require, module, exports) {
        "use strict";
        function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.pathname = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = [ "<", ">", '"', "`", " ", "\r", "\n", "	" ], unwise = [ "{", "}", "|", "\\", "^", "`" ].concat(delims), autoEscape = [ "'" ].concat(unwise), nonHostChars = [ "%", "/", "?", ";", "#" ].concat(autoEscape), hostEndingChars = [ "/", "?", "#" ], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
            javascript: true,
            "javascript:": true
        }, slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
        };
        function urlParse(url, slashesDenoteHost) {
            if (url && url instanceof Url) {
                return url;
            }
            var u = new Url();
            u.parse(url, slashesDenoteHost);
            return u;
        }
        Url.prototype.parse = function(url, slashesDenoteHost) {
            var i, l, lowerProto, hec, slashes, rest = url;
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                    this.pathname = simplePath[1];
                    if (simplePath[2]) {
                        this.search = simplePath[2];
                    }
                    return this;
                }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                lowerProto = proto.toLowerCase();
                this.protocol = proto;
                rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                var hostEnd = -1;
                for (i = 0; i < hostEndingChars.length; i++) {
                    hec = rest.indexOf(hostEndingChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                        hostEnd = hec;
                    }
                }
                var auth, atSign;
                if (hostEnd === -1) {
                    atSign = rest.lastIndexOf("@");
                } else {
                    atSign = rest.lastIndexOf("@", hostEnd);
                }
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = auth;
                }
                hostEnd = -1;
                for (i = 0; i < nonHostChars.length; i++) {
                    hec = rest.indexOf(nonHostChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                        hostEnd = hec;
                    }
                }
                if (hostEnd === -1) {
                    hostEnd = rest.length;
                }
                if (rest[hostEnd - 1] === ":") {
                    hostEnd--;
                }
                var host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                this.parseHost(host);
                this.hostname = this.hostname || "";
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for (i = 0, l = hostparts.length; i < l; i++) {
                        var part = hostparts[i];
                        if (!part) {
                            continue;
                        }
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = "";
                            for (var j = 0, k = part.length; j < k; j++) {
                                if (part.charCodeAt(j) > 127) {
                                    newpart += "x";
                                } else {
                                    newpart += part[j];
                                }
                            }
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i);
                                var notHost = hostparts.slice(i + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = notHost.join(".") + rest;
                                }
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                }
                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = "";
                }
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
                this.search = rest.substr(qm);
                rest = rest.slice(0, qm);
            }
            if (rest) {
                this.pathname = rest;
            }
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "";
            }
            return this;
        };
        Url.prototype.parseHost = function(host) {
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ":") {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host) {
                this.hostname = host;
            }
        };
        module.exports = urlParse;
    }, {} ],
    121: [ function(require, module, exports) {
        module.exports = /[\0-\x1F\x7F-\x9F]/;
    }, {} ],
    122: [ function(require, module, exports) {
        module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
    }, {} ],
    123: [ function(require, module, exports) {
        module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDE38-\uDE3D]|\uD805[\uDCC6\uDDC1-\uDDC9\uDE41-\uDE43]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F/;
    }, {} ],
    124: [ function(require, module, exports) {
        module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    }, {} ],
    125: [ function(require, module, exports) {
        module.exports.Any = require("./properties/Any/regex");
        module.exports.Cc = require("./categories/Cc/regex");
        module.exports.Cf = require("./categories/Cf/regex");
        module.exports.P = require("./categories/P/regex");
        module.exports.Z = require("./categories/Z/regex");
    }, {
        "./categories/Cc/regex": 121,
        "./categories/Cf/regex": 122,
        "./categories/P/regex": 123,
        "./categories/Z/regex": 124,
        "./properties/Any/regex": 126
    } ],
    126: [ function(require, module, exports) {
        module.exports = /[\0-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF]/;
    }, {} ],
    127: [ function(require, module, exports) {
        var createElement = require("./vdom/create-element.js");
        module.exports = createElement;
    }, {
        "./vdom/create-element.js": 139
    } ],
    128: [ function(require, module, exports) {
        var diff = require("./vtree/diff.js");
        module.exports = diff;
    }, {
        "./vtree/diff.js": 159
    } ],
    129: [ function(require, module, exports) {
        var h = require("./virtual-hyperscript/index.js");
        module.exports = h;
    }, {
        "./virtual-hyperscript/index.js": 146
    } ],
    130: [ function(require, module, exports) {
        module.exports = function split(undef) {
            var nativeSplit = String.prototype.split, compliantExecNpcg = /()??/.exec("")[1] === undef, self;
            self = function(str, separator, limit) {
                if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
                    return nativeSplit.call(str, separator, limit);
                }
                var output = [], flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, separator = new RegExp(separator.source, flags + "g"), separator2, match, lastIndex, lastLength;
                str += "";
                if (!compliantExecNpcg) {
                    separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
                }
                limit = limit === undef ? -1 >>> 0 : limit >>> 0;
                while (match = separator.exec(str)) {
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        output.push(str.slice(lastLastIndex, match.index));
                        if (!compliantExecNpcg && match.length > 1) {
                            match[0].replace(separator2, function() {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (arguments[i] === undef) {
                                        match[i] = undef;
                                    }
                                }
                            });
                        }
                        if (match.length > 1 && match.index < str.length) {
                            Array.prototype.push.apply(output, match.slice(1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= limit) {
                            break;
                        }
                    }
                    if (separator.lastIndex === match.index) {
                        separator.lastIndex++;
                    }
                }
                if (lastLastIndex === str.length) {
                    if (lastLength || !separator.test("")) {
                        output.push("");
                    }
                } else {
                    output.push(str.slice(lastLastIndex));
                }
                return output.length > limit ? output.slice(0, limit) : output;
            };
            return self;
        }();
    }, {} ],
    131: [ function(require, module, exports) {
        "use strict";
        var OneVersionConstraint = require("individual/one-version");
        var MY_VERSION = "7";
        OneVersionConstraint("ev-store", MY_VERSION);
        var hashKey = "__EV_STORE_KEY@" + MY_VERSION;
        module.exports = EvStore;
        function EvStore(elem) {
            var hash = elem[hashKey];
            if (!hash) {
                hash = elem[hashKey] = {};
            }
            return hash;
        }
    }, {
        "individual/one-version": 133
    } ],
    132: [ function(require, module, exports) {
        (function(global) {
            "use strict";
            var root = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
            module.exports = Individual;
            function Individual(key, value) {
                if (key in root) {
                    return root[key];
                }
                root[key] = value;
                return value;
            }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    133: [ function(require, module, exports) {
        "use strict";
        var Individual = require("./index.js");
        module.exports = OneVersion;
        function OneVersion(moduleName, version, defaultValue) {
            var key = "__INDIVIDUAL_ONE_VERSION_" + moduleName;
            var enforceKey = key + "_ENFORCE_SINGLETON";
            var versionValue = Individual(enforceKey, version);
            if (versionValue !== version) {
                throw new Error("Can only have one copy of " + moduleName + ".\n" + "You already have version " + versionValue + " installed.\n" + "This means you cannot install version " + version);
            }
            return Individual(key, defaultValue);
        }
    }, {
        "./index.js": 132
    } ],
    134: [ function(require, module, exports) {
        (function(global) {
            var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
            var minDoc = require("min-document");
            if (typeof document !== "undefined") {
                module.exports = document;
            } else {
                var doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                if (!doccy) {
                    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
                }
                module.exports = doccy;
            }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        "min-document": 2
    } ],
    135: [ function(require, module, exports) {
        "use strict";
        module.exports = function isObject(x) {
            return typeof x === "object" && x !== null;
        };
    }, {} ],
    136: [ function(require, module, exports) {
        var nativeIsArray = Array.isArray;
        var toString = Object.prototype.toString;
        module.exports = nativeIsArray || isArray;
        function isArray(obj) {
            return toString.call(obj) === "[object Array]";
        }
    }, {} ],
    137: [ function(require, module, exports) {
        var patch = require("./vdom/patch.js");
        module.exports = patch;
    }, {
        "./vdom/patch.js": 142
    } ],
    138: [ function(require, module, exports) {
        var isObject = require("is-object");
        var isHook = require("../vnode/is-vhook.js");
        module.exports = applyProperties;
        function applyProperties(node, props, previous) {
            for (var propName in props) {
                var propValue = props[propName];
                if (propValue === undefined) {
                    removeProperty(node, propName, propValue, previous);
                } else if (isHook(propValue)) {
                    removeProperty(node, propName, propValue, previous);
                    if (propValue.hook) {
                        propValue.hook(node, propName, previous ? previous[propName] : undefined);
                    }
                } else {
                    if (isObject(propValue)) {
                        patchObject(node, props, previous, propName, propValue);
                    } else {
                        node[propName] = propValue;
                    }
                }
            }
        }
        function removeProperty(node, propName, propValue, previous) {
            if (previous) {
                var previousValue = previous[propName];
                if (!isHook(previousValue)) {
                    if (propName === "attributes") {
                        for (var attrName in previousValue) {
                            node.removeAttribute(attrName);
                        }
                    } else if (propName === "style") {
                        for (var i in previousValue) {
                            node.style[i] = "";
                        }
                    } else if (typeof previousValue === "string") {
                        node[propName] = "";
                    } else {
                        node[propName] = null;
                    }
                } else if (previousValue.unhook) {
                    previousValue.unhook(node, propName, propValue);
                }
            }
        }
        function patchObject(node, props, previous, propName, propValue) {
            var previousValue = previous ? previous[propName] : undefined;
            if (propName === "attributes") {
                for (var attrName in propValue) {
                    var attrValue = propValue[attrName];
                    if (attrValue === undefined) {
                        node.removeAttribute(attrName);
                    } else {
                        node.setAttribute(attrName, attrValue);
                    }
                }
                return;
            }
            if (previousValue && isObject(previousValue) && getPrototype(previousValue) !== getPrototype(propValue)) {
                node[propName] = propValue;
                return;
            }
            if (!isObject(node[propName])) {
                node[propName] = {};
            }
            var replacer = propName === "style" ? "" : undefined;
            for (var k in propValue) {
                var value = propValue[k];
                node[propName][k] = value === undefined ? replacer : value;
            }
        }
        function getPrototype(value) {
            if (Object.getPrototypeOf) {
                return Object.getPrototypeOf(value);
            } else if (value.__proto__) {
                return value.__proto__;
            } else if (value.constructor) {
                return value.constructor.prototype;
            }
        }
    }, {
        "../vnode/is-vhook.js": 150,
        "is-object": 135
    } ],
    139: [ function(require, module, exports) {
        var document = require("global/document");
        var applyProperties = require("./apply-properties");
        var isVNode = require("../vnode/is-vnode.js");
        var isVText = require("../vnode/is-vtext.js");
        var isWidget = require("../vnode/is-widget.js");
        var handleThunk = require("../vnode/handle-thunk.js");
        module.exports = createElement;
        function createElement(vnode, opts) {
            var doc = opts ? opts.document || document : document;
            var warn = opts ? opts.warn : null;
            vnode = handleThunk(vnode).a;
            if (isWidget(vnode)) {
                return vnode.init();
            } else if (isVText(vnode)) {
                return doc.createTextNode(vnode.text);
            } else if (!isVNode(vnode)) {
                if (warn) {
                    warn("Item is not a valid virtual dom node", vnode);
                }
                return null;
            }
            var node = vnode.namespace === null ? doc.createElement(vnode.tagName) : doc.createElementNS(vnode.namespace, vnode.tagName);
            var props = vnode.properties;
            applyProperties(node, props);
            var children = vnode.children;
            for (var i = 0; i < children.length; i++) {
                var childNode = createElement(children[i], opts);
                if (childNode) {
                    node.appendChild(childNode);
                }
            }
            return node;
        }
    }, {
        "../vnode/handle-thunk.js": 148,
        "../vnode/is-vnode.js": 151,
        "../vnode/is-vtext.js": 152,
        "../vnode/is-widget.js": 153,
        "./apply-properties": 138,
        "global/document": 134
    } ],
    140: [ function(require, module, exports) {
        var noChild = {};
        module.exports = domIndex;
        function domIndex(rootNode, tree, indices, nodes) {
            if (!indices || indices.length === 0) {
                return {};
            } else {
                indices.sort(ascending);
                return recurse(rootNode, tree, indices, nodes, 0);
            }
        }
        function recurse(rootNode, tree, indices, nodes, rootIndex) {
            nodes = nodes || {};
            if (rootNode) {
                if (indexInRange(indices, rootIndex, rootIndex)) {
                    nodes[rootIndex] = rootNode;
                }
                var vChildren = tree.children;
                if (vChildren) {
                    var childNodes = rootNode.childNodes;
                    for (var i = 0; i < tree.children.length; i++) {
                        rootIndex += 1;
                        var vChild = vChildren[i] || noChild;
                        var nextIndex = rootIndex + (vChild.count || 0);
                        if (indexInRange(indices, rootIndex, nextIndex)) {
                            recurse(childNodes[i], vChild, indices, nodes, rootIndex);
                        }
                        rootIndex = nextIndex;
                    }
                }
            }
            return nodes;
        }
        function indexInRange(indices, left, right) {
            if (indices.length === 0) {
                return false;
            }
            var minIndex = 0;
            var maxIndex = indices.length - 1;
            var currentIndex;
            var currentItem;
            while (minIndex <= maxIndex) {
                currentIndex = (maxIndex + minIndex) / 2 >> 0;
                currentItem = indices[currentIndex];
                if (minIndex === maxIndex) {
                    return currentItem >= left && currentItem <= right;
                } else if (currentItem < left) {
                    minIndex = currentIndex + 1;
                } else if (currentItem > right) {
                    maxIndex = currentIndex - 1;
                } else {
                    return true;
                }
            }
            return false;
        }
        function ascending(a, b) {
            return a > b ? 1 : -1;
        }
    }, {} ],
    141: [ function(require, module, exports) {
        var applyProperties = require("./apply-properties");
        var isWidget = require("../vnode/is-widget.js");
        var VPatch = require("../vnode/vpatch.js");
        var render = require("./create-element");
        var updateWidget = require("./update-widget");
        module.exports = applyPatch;
        function applyPatch(vpatch, domNode, renderOptions) {
            var type = vpatch.type;
            var vNode = vpatch.vNode;
            var patch = vpatch.patch;
            switch (type) {
              case VPatch.REMOVE:
                return removeNode(domNode, vNode);

              case VPatch.INSERT:
                return insertNode(domNode, patch, renderOptions);

              case VPatch.VTEXT:
                return stringPatch(domNode, vNode, patch, renderOptions);

              case VPatch.WIDGET:
                return widgetPatch(domNode, vNode, patch, renderOptions);

              case VPatch.VNODE:
                return vNodePatch(domNode, vNode, patch, renderOptions);

              case VPatch.ORDER:
                reorderChildren(domNode, patch);
                return domNode;

              case VPatch.PROPS:
                applyProperties(domNode, patch, vNode.properties);
                return domNode;

              case VPatch.THUNK:
                return replaceRoot(domNode, renderOptions.patch(domNode, patch, renderOptions));

              default:
                return domNode;
            }
        }
        function removeNode(domNode, vNode) {
            var parentNode = domNode.parentNode;
            if (parentNode) {
                parentNode.removeChild(domNode);
            }
            destroyWidget(domNode, vNode);
            return null;
        }
        function insertNode(parentNode, vNode, renderOptions) {
            var newNode = render(vNode, renderOptions);
            if (parentNode) {
                parentNode.appendChild(newNode);
            }
            return parentNode;
        }
        function stringPatch(domNode, leftVNode, vText, renderOptions) {
            var newNode;
            if (domNode.nodeType === 3) {
                domNode.replaceData(0, domNode.length, vText.text);
                newNode = domNode;
            } else {
                var parentNode = domNode.parentNode;
                newNode = render(vText, renderOptions);
                if (parentNode && newNode !== domNode) {
                    parentNode.replaceChild(newNode, domNode);
                }
            }
            return newNode;
        }
        function widgetPatch(domNode, leftVNode, widget, renderOptions) {
            var updating = updateWidget(leftVNode, widget);
            var newNode;
            if (updating) {
                newNode = widget.update(leftVNode, domNode) || domNode;
            } else {
                newNode = render(widget, renderOptions);
            }
            var parentNode = domNode.parentNode;
            if (parentNode && newNode !== domNode) {
                parentNode.replaceChild(newNode, domNode);
            }
            if (!updating) {
                destroyWidget(domNode, leftVNode);
            }
            return newNode;
        }
        function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
            var parentNode = domNode.parentNode;
            var newNode = render(vNode, renderOptions);
            if (parentNode && newNode !== domNode) {
                parentNode.replaceChild(newNode, domNode);
            }
            return newNode;
        }
        function destroyWidget(domNode, w) {
            if (typeof w.destroy === "function" && isWidget(w)) {
                w.destroy(domNode);
            }
        }
        function reorderChildren(domNode, moves) {
            var childNodes = domNode.childNodes;
            var keyMap = {};
            var node;
            var remove;
            var insert;
            for (var i = 0; i < moves.removes.length; i++) {
                remove = moves.removes[i];
                node = childNodes[remove.from];
                if (remove.key) {
                    keyMap[remove.key] = node;
                }
                domNode.removeChild(node);
            }
            var length = childNodes.length;
            for (var j = 0; j < moves.inserts.length; j++) {
                insert = moves.inserts[j];
                node = keyMap[insert.key];
                domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
            }
        }
        function replaceRoot(oldRoot, newRoot) {
            if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
                oldRoot.parentNode.replaceChild(newRoot, oldRoot);
            }
            return newRoot;
        }
    }, {
        "../vnode/is-widget.js": 153,
        "../vnode/vpatch.js": 156,
        "./apply-properties": 138,
        "./create-element": 139,
        "./update-widget": 143
    } ],
    142: [ function(require, module, exports) {
        var document = require("global/document");
        var isArray = require("x-is-array");
        var domIndex = require("./dom-index");
        var patchOp = require("./patch-op");
        module.exports = patch;
        function patch(rootNode, patches) {
            return patchRecursive(rootNode, patches);
        }
        function patchRecursive(rootNode, patches, renderOptions) {
            var indices = patchIndices(patches);
            if (indices.length === 0) {
                return rootNode;
            }
            var index = domIndex(rootNode, patches.a, indices);
            var ownerDocument = rootNode.ownerDocument;
            if (!renderOptions) {
                renderOptions = {
                    patch: patchRecursive
                };
                if (ownerDocument !== document) {
                    renderOptions.document = ownerDocument;
                }
            }
            for (var i = 0; i < indices.length; i++) {
                var nodeIndex = indices[i];
                rootNode = applyPatch(rootNode, index[nodeIndex], patches[nodeIndex], renderOptions);
            }
            return rootNode;
        }
        function applyPatch(rootNode, domNode, patchList, renderOptions) {
            if (!domNode) {
                return rootNode;
            }
            var newNode;
            if (isArray(patchList)) {
                for (var i = 0; i < patchList.length; i++) {
                    newNode = patchOp(patchList[i], domNode, renderOptions);
                    if (domNode === rootNode) {
                        rootNode = newNode;
                    }
                }
            } else {
                newNode = patchOp(patchList, domNode, renderOptions);
                if (domNode === rootNode) {
                    rootNode = newNode;
                }
            }
            return rootNode;
        }
        function patchIndices(patches) {
            var indices = [];
            for (var key in patches) {
                if (key !== "a") {
                    indices.push(Number(key));
                }
            }
            return indices;
        }
    }, {
        "./dom-index": 140,
        "./patch-op": 141,
        "global/document": 134,
        "x-is-array": 136
    } ],
    143: [ function(require, module, exports) {
        var isWidget = require("../vnode/is-widget.js");
        module.exports = updateWidget;
        function updateWidget(a, b) {
            if (isWidget(a) && isWidget(b)) {
                if ("name" in a && "name" in b) {
                    return a.id === b.id;
                } else {
                    return a.init === b.init;
                }
            }
            return false;
        }
    }, {
        "../vnode/is-widget.js": 153
    } ],
    144: [ function(require, module, exports) {
        "use strict";
        var EvStore = require("ev-store");
        module.exports = EvHook;
        function EvHook(value) {
            if (!(this instanceof EvHook)) {
                return new EvHook(value);
            }
            this.value = value;
        }
        EvHook.prototype.hook = function(node, propertyName) {
            var es = EvStore(node);
            var propName = propertyName.substr(3);
            es[propName] = this.value;
        };
        EvHook.prototype.unhook = function(node, propertyName) {
            var es = EvStore(node);
            var propName = propertyName.substr(3);
            es[propName] = undefined;
        };
    }, {
        "ev-store": 131
    } ],
    145: [ function(require, module, exports) {
        "use strict";
        module.exports = SoftSetHook;
        function SoftSetHook(value) {
            if (!(this instanceof SoftSetHook)) {
                return new SoftSetHook(value);
            }
            this.value = value;
        }
        SoftSetHook.prototype.hook = function(node, propertyName) {
            if (node[propertyName] !== this.value) {
                node[propertyName] = this.value;
            }
        };
    }, {} ],
    146: [ function(require, module, exports) {
        "use strict";
        var isArray = require("x-is-array");
        var VNode = require("../vnode/vnode.js");
        var VText = require("../vnode/vtext.js");
        var isVNode = require("../vnode/is-vnode");
        var isVText = require("../vnode/is-vtext");
        var isWidget = require("../vnode/is-widget");
        var isHook = require("../vnode/is-vhook");
        var isVThunk = require("../vnode/is-thunk");
        var parseTag = require("./parse-tag.js");
        var softSetHook = require("./hooks/soft-set-hook.js");
        var evHook = require("./hooks/ev-hook.js");
        module.exports = h;
        function h(tagName, properties, children) {
            var childNodes = [];
            var tag, props, key, namespace;
            if (!children && isChildren(properties)) {
                children = properties;
                props = {};
            }
            props = props || properties || {};
            tag = parseTag(tagName, props);
            if (props.hasOwnProperty("key")) {
                key = props.key;
                props.key = undefined;
            }
            if (props.hasOwnProperty("namespace")) {
                namespace = props.namespace;
                props.namespace = undefined;
            }
            if (tag === "INPUT" && !namespace && props.hasOwnProperty("value") && props.value !== undefined && !isHook(props.value)) {
                props.value = softSetHook(props.value);
            }
            transformProperties(props);
            if (children !== undefined && children !== null) {
                addChild(children, childNodes, tag, props);
            }
            return new VNode(tag, props, childNodes, key, namespace);
        }
        function addChild(c, childNodes, tag, props) {
            if (typeof c === "string") {
                childNodes.push(new VText(c));
            } else if (isChild(c)) {
                childNodes.push(c);
            } else if (isArray(c)) {
                for (var i = 0; i < c.length; i++) {
                    addChild(c[i], childNodes, tag, props);
                }
            } else if (c === null || c === undefined) {
                return;
            } else {
                throw UnexpectedVirtualElement({
                    foreignObject: c,
                    parentVnode: {
                        tagName: tag,
                        properties: props
                    }
                });
            }
        }
        function transformProperties(props) {
            for (var propName in props) {
                if (props.hasOwnProperty(propName)) {
                    var value = props[propName];
                    if (isHook(value)) {
                        continue;
                    }
                    if (propName.substr(0, 3) === "ev-") {
                        props[propName] = evHook(value);
                    }
                }
            }
        }
        function isChild(x) {
            return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
        }
        function isChildren(x) {
            return typeof x === "string" || isArray(x) || isChild(x);
        }
        function UnexpectedVirtualElement(data) {
            var err = new Error();
            err.type = "virtual-hyperscript.unexpected.virtual-element";
            err.message = "Unexpected virtual child passed to h().\n" + "Expected a VNode / Vthunk / VWidget / string but:\n" + "got:\n" + errorString(data.foreignObject) + ".\n" + "The parent vnode is:\n" + errorString(data.parentVnode);
            "\n" + "Suggested fix: change your `h(..., [ ... ])` callsite.";
            err.foreignObject = data.foreignObject;
            err.parentVnode = data.parentVnode;
            return err;
        }
        function errorString(obj) {
            try {
                return JSON.stringify(obj, null, "    ");
            } catch (e) {
                return String(obj);
            }
        }
    }, {
        "../vnode/is-thunk": 149,
        "../vnode/is-vhook": 150,
        "../vnode/is-vnode": 151,
        "../vnode/is-vtext": 152,
        "../vnode/is-widget": 153,
        "../vnode/vnode.js": 155,
        "../vnode/vtext.js": 157,
        "./hooks/ev-hook.js": 144,
        "./hooks/soft-set-hook.js": 145,
        "./parse-tag.js": 147,
        "x-is-array": 136
    } ],
    147: [ function(require, module, exports) {
        "use strict";
        var split = require("browser-split");
        var classIdSplit = /([\.#]?[a-zA-Z0-9_:-]+)/;
        var notClassId = /^\.|#/;
        module.exports = parseTag;
        function parseTag(tag, props) {
            if (!tag) {
                return "DIV";
            }
            var noId = !props.hasOwnProperty("id");
            var tagParts = split(tag, classIdSplit);
            var tagName = null;
            if (notClassId.test(tagParts[1])) {
                tagName = "DIV";
            }
            var classes, part, type, i;
            for (i = 0; i < tagParts.length; i++) {
                part = tagParts[i];
                if (!part) {
                    continue;
                }
                type = part.charAt(0);
                if (!tagName) {
                    tagName = part;
                } else if (type === ".") {
                    classes = classes || [];
                    classes.push(part.substring(1, part.length));
                } else if (type === "#" && noId) {
                    props.id = part.substring(1, part.length);
                }
            }
            if (classes) {
                if (props.className) {
                    classes.push(props.className);
                }
                props.className = classes.join(" ");
            }
            return props.namespace ? tagName : tagName.toUpperCase();
        }
    }, {
        "browser-split": 130
    } ],
    148: [ function(require, module, exports) {
        var isVNode = require("./is-vnode");
        var isVText = require("./is-vtext");
        var isWidget = require("./is-widget");
        var isThunk = require("./is-thunk");
        module.exports = handleThunk;
        function handleThunk(a, b) {
            var renderedA = a;
            var renderedB = b;
            if (isThunk(b)) {
                renderedB = renderThunk(b, a);
            }
            if (isThunk(a)) {
                renderedA = renderThunk(a, null);
            }
            return {
                a: renderedA,
                b: renderedB
            };
        }
        function renderThunk(thunk, previous) {
            var renderedThunk = thunk.vnode;
            if (!renderedThunk) {
                renderedThunk = thunk.vnode = thunk.render(previous);
            }
            if (!(isVNode(renderedThunk) || isVText(renderedThunk) || isWidget(renderedThunk))) {
                throw new Error("thunk did not return a valid node");
            }
            return renderedThunk;
        }
    }, {
        "./is-thunk": 149,
        "./is-vnode": 151,
        "./is-vtext": 152,
        "./is-widget": 153
    } ],
    149: [ function(require, module, exports) {
        module.exports = isThunk;
        function isThunk(t) {
            return t && t.type === "Thunk";
        }
    }, {} ],
    150: [ function(require, module, exports) {
        module.exports = isHook;
        function isHook(hook) {
            return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
        }
    }, {} ],
    151: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = isVirtualNode;
        function isVirtualNode(x) {
            return x && x.type === "VirtualNode" && x.version === version;
        }
    }, {
        "./version": 154
    } ],
    152: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = isVirtualText;
        function isVirtualText(x) {
            return x && x.type === "VirtualText" && x.version === version;
        }
    }, {
        "./version": 154
    } ],
    153: [ function(require, module, exports) {
        module.exports = isWidget;
        function isWidget(w) {
            return w && w.type === "Widget";
        }
    }, {} ],
    154: [ function(require, module, exports) {
        module.exports = "2";
    }, {} ],
    155: [ function(require, module, exports) {
        var version = require("./version");
        var isVNode = require("./is-vnode");
        var isWidget = require("./is-widget");
        var isThunk = require("./is-thunk");
        var isVHook = require("./is-vhook");
        module.exports = VirtualNode;
        var noProperties = {};
        var noChildren = [];
        function VirtualNode(tagName, properties, children, key, namespace) {
            this.tagName = tagName;
            this.properties = properties || noProperties;
            this.children = children || noChildren;
            this.key = key != null ? String(key) : undefined;
            this.namespace = typeof namespace === "string" ? namespace : null;
            var count = children && children.length || 0;
            var descendants = 0;
            var hasWidgets = false;
            var hasThunks = false;
            var descendantHooks = false;
            var hooks;
            for (var propName in properties) {
                if (properties.hasOwnProperty(propName)) {
                    var property = properties[propName];
                    if (isVHook(property) && property.unhook) {
                        if (!hooks) {
                            hooks = {};
                        }
                        hooks[propName] = property;
                    }
                }
            }
            for (var i = 0; i < count; i++) {
                var child = children[i];
                if (isVNode(child)) {
                    descendants += child.count || 0;
                    if (!hasWidgets && child.hasWidgets) {
                        hasWidgets = true;
                    }
                    if (!hasThunks && child.hasThunks) {
                        hasThunks = true;
                    }
                    if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                        descendantHooks = true;
                    }
                } else if (!hasWidgets && isWidget(child)) {
                    if (typeof child.destroy === "function") {
                        hasWidgets = true;
                    }
                } else if (!hasThunks && isThunk(child)) {
                    hasThunks = true;
                }
            }
            this.count = count + descendants;
            this.hasWidgets = hasWidgets;
            this.hasThunks = hasThunks;
            this.hooks = hooks;
            this.descendantHooks = descendantHooks;
        }
        VirtualNode.prototype.version = version;
        VirtualNode.prototype.type = "VirtualNode";
    }, {
        "./is-thunk": 149,
        "./is-vhook": 150,
        "./is-vnode": 151,
        "./is-widget": 153,
        "./version": 154
    } ],
    156: [ function(require, module, exports) {
        var version = require("./version");
        VirtualPatch.NONE = 0;
        VirtualPatch.VTEXT = 1;
        VirtualPatch.VNODE = 2;
        VirtualPatch.WIDGET = 3;
        VirtualPatch.PROPS = 4;
        VirtualPatch.ORDER = 5;
        VirtualPatch.INSERT = 6;
        VirtualPatch.REMOVE = 7;
        VirtualPatch.THUNK = 8;
        module.exports = VirtualPatch;
        function VirtualPatch(type, vNode, patch) {
            this.type = Number(type);
            this.vNode = vNode;
            this.patch = patch;
        }
        VirtualPatch.prototype.version = version;
        VirtualPatch.prototype.type = "VirtualPatch";
    }, {
        "./version": 154
    } ],
    157: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = VirtualText;
        function VirtualText(text) {
            this.text = String(text);
        }
        VirtualText.prototype.version = version;
        VirtualText.prototype.type = "VirtualText";
    }, {
        "./version": 154
    } ],
    158: [ function(require, module, exports) {
        var isObject = require("is-object");
        var isHook = require("../vnode/is-vhook");
        module.exports = diffProps;
        function diffProps(a, b) {
            var diff;
            for (var aKey in a) {
                if (!(aKey in b)) {
                    diff = diff || {};
                    diff[aKey] = undefined;
                }
                var aValue = a[aKey];
                var bValue = b[aKey];
                if (aValue === bValue) {
                    continue;
                } else if (isObject(aValue) && isObject(bValue)) {
                    if (getPrototype(bValue) !== getPrototype(aValue)) {
                        diff = diff || {};
                        diff[aKey] = bValue;
                    } else if (isHook(bValue)) {
                        diff = diff || {};
                        diff[aKey] = bValue;
                    } else {
                        var objectDiff = diffProps(aValue, bValue);
                        if (objectDiff) {
                            diff = diff || {};
                            diff[aKey] = objectDiff;
                        }
                    }
                } else {
                    diff = diff || {};
                    diff[aKey] = bValue;
                }
            }
            for (var bKey in b) {
                if (!(bKey in a)) {
                    diff = diff || {};
                    diff[bKey] = b[bKey];
                }
            }
            return diff;
        }
        function getPrototype(value) {
            if (Object.getPrototypeOf) {
                return Object.getPrototypeOf(value);
            } else if (value.__proto__) {
                return value.__proto__;
            } else if (value.constructor) {
                return value.constructor.prototype;
            }
        }
    }, {
        "../vnode/is-vhook": 150,
        "is-object": 135
    } ],
    159: [ function(require, module, exports) {
        var isArray = require("x-is-array");
        var VPatch = require("../vnode/vpatch");
        var isVNode = require("../vnode/is-vnode");
        var isVText = require("../vnode/is-vtext");
        var isWidget = require("../vnode/is-widget");
        var isThunk = require("../vnode/is-thunk");
        var handleThunk = require("../vnode/handle-thunk");
        var diffProps = require("./diff-props");
        module.exports = diff;
        function diff(a, b) {
            var patch = {
                a: a
            };
            walk(a, b, patch, 0);
            return patch;
        }
        function walk(a, b, patch, index) {
            if (a === b) {
                return;
            }
            var apply = patch[index];
            var applyClear = false;
            if (isThunk(a) || isThunk(b)) {
                thunks(a, b, patch, index);
            } else if (b == null) {
                if (!isWidget(a)) {
                    clearState(a, patch, index);
                    apply = patch[index];
                }
                apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
            } else if (isVNode(b)) {
                if (isVNode(a)) {
                    if (a.tagName === b.tagName && a.namespace === b.namespace && a.key === b.key) {
                        var propsPatch = diffProps(a.properties, b.properties);
                        if (propsPatch) {
                            apply = appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));
                        }
                        apply = diffChildren(a, b, patch, apply, index);
                    } else {
                        apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                        applyClear = true;
                    }
                } else {
                    apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                    applyClear = true;
                }
            } else if (isVText(b)) {
                if (!isVText(a)) {
                    apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                    applyClear = true;
                } else if (a.text !== b.text) {
                    apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                }
            } else if (isWidget(b)) {
                if (!isWidget(a)) {
                    applyClear = true;
                }
                apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
            }
            if (apply) {
                patch[index] = apply;
            }
            if (applyClear) {
                clearState(a, patch, index);
            }
        }
        function diffChildren(a, b, patch, apply, index) {
            var aChildren = a.children;
            var orderedSet = reorder(aChildren, b.children);
            var bChildren = orderedSet.children;
            var aLen = aChildren.length;
            var bLen = bChildren.length;
            var len = aLen > bLen ? aLen : bLen;
            for (var i = 0; i < len; i++) {
                var leftNode = aChildren[i];
                var rightNode = bChildren[i];
                index += 1;
                if (!leftNode) {
                    if (rightNode) {
                        apply = appendPatch(apply, new VPatch(VPatch.INSERT, null, rightNode));
                    }
                } else {
                    walk(leftNode, rightNode, patch, index);
                }
                if (isVNode(leftNode) && leftNode.count) {
                    index += leftNode.count;
                }
            }
            if (orderedSet.moves) {
                apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));
            }
            return apply;
        }
        function clearState(vNode, patch, index) {
            unhook(vNode, patch, index);
            destroyWidgets(vNode, patch, index);
        }
        function destroyWidgets(vNode, patch, index) {
            if (isWidget(vNode)) {
                if (typeof vNode.destroy === "function") {
                    patch[index] = appendPatch(patch[index], new VPatch(VPatch.REMOVE, vNode, null));
                }
            } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
                var children = vNode.children;
                var len = children.length;
                for (var i = 0; i < len; i++) {
                    var child = children[i];
                    index += 1;
                    destroyWidgets(child, patch, index);
                    if (isVNode(child) && child.count) {
                        index += child.count;
                    }
                }
            } else if (isThunk(vNode)) {
                thunks(vNode, null, patch, index);
            }
        }
        function thunks(a, b, patch, index) {
            var nodes = handleThunk(a, b);
            var thunkPatch = diff(nodes.a, nodes.b);
            if (hasPatches(thunkPatch)) {
                patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
            }
        }
        function hasPatches(patch) {
            for (var index in patch) {
                if (index !== "a") {
                    return true;
                }
            }
            return false;
        }
        function unhook(vNode, patch, index) {
            if (isVNode(vNode)) {
                if (vNode.hooks) {
                    patch[index] = appendPatch(patch[index], new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));
                }
                if (vNode.descendantHooks || vNode.hasThunks) {
                    var children = vNode.children;
                    var len = children.length;
                    for (var i = 0; i < len; i++) {
                        var child = children[i];
                        index += 1;
                        unhook(child, patch, index);
                        if (isVNode(child) && child.count) {
                            index += child.count;
                        }
                    }
                }
            } else if (isThunk(vNode)) {
                thunks(vNode, null, patch, index);
            }
        }
        function undefinedKeys(obj) {
            var result = {};
            for (var key in obj) {
                result[key] = undefined;
            }
            return result;
        }
        function reorder(aChildren, bChildren) {
            var bChildIndex = keyIndex(bChildren);
            var bKeys = bChildIndex.keys;
            var bFree = bChildIndex.free;
            if (bFree.length === bChildren.length) {
                return {
                    children: bChildren,
                    moves: null
                };
            }
            var aChildIndex = keyIndex(aChildren);
            var aKeys = aChildIndex.keys;
            var aFree = aChildIndex.free;
            if (aFree.length === aChildren.length) {
                return {
                    children: bChildren,
                    moves: null
                };
            }
            var newChildren = [];
            var freeIndex = 0;
            var freeCount = bFree.length;
            var deletedItems = 0;
            for (var i = 0; i < aChildren.length; i++) {
                var aItem = aChildren[i];
                var itemIndex;
                if (aItem.key) {
                    if (bKeys.hasOwnProperty(aItem.key)) {
                        itemIndex = bKeys[aItem.key];
                        newChildren.push(bChildren[itemIndex]);
                    } else {
                        itemIndex = i - deletedItems++;
                        newChildren.push(null);
                    }
                } else {
                    if (freeIndex < freeCount) {
                        itemIndex = bFree[freeIndex++];
                        newChildren.push(bChildren[itemIndex]);
                    } else {
                        itemIndex = i - deletedItems++;
                        newChildren.push(null);
                    }
                }
            }
            var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex];
            for (var j = 0; j < bChildren.length; j++) {
                var newItem = bChildren[j];
                if (newItem.key) {
                    if (!aKeys.hasOwnProperty(newItem.key)) {
                        newChildren.push(newItem);
                    }
                } else if (j >= lastFreeIndex) {
                    newChildren.push(newItem);
                }
            }
            var simulate = newChildren.slice();
            var simulateIndex = 0;
            var removes = [];
            var inserts = [];
            var simulateItem;
            for (var k = 0; k < bChildren.length; ) {
                var wantedItem = bChildren[k];
                simulateItem = simulate[simulateIndex];
                while (simulateItem === null && simulate.length) {
                    removes.push(remove(simulate, simulateIndex, null));
                    simulateItem = simulate[simulateIndex];
                }
                if (!simulateItem || simulateItem.key !== wantedItem.key) {
                    if (wantedItem.key) {
                        if (simulateItem && simulateItem.key) {
                            if (bKeys[simulateItem.key] !== k + 1) {
                                removes.push(remove(simulate, simulateIndex, simulateItem.key));
                                simulateItem = simulate[simulateIndex];
                                if (!simulateItem || simulateItem.key !== wantedItem.key) {
                                    inserts.push({
                                        key: wantedItem.key,
                                        to: k
                                    });
                                } else {
                                    simulateIndex++;
                                }
                            } else {
                                inserts.push({
                                    key: wantedItem.key,
                                    to: k
                                });
                            }
                        } else {
                            inserts.push({
                                key: wantedItem.key,
                                to: k
                            });
                        }
                        k++;
                    } else if (simulateItem && simulateItem.key) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key));
                    }
                } else {
                    simulateIndex++;
                    k++;
                }
            }
            while (simulateIndex < simulate.length) {
                simulateItem = simulate[simulateIndex];
                removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key));
            }
            if (removes.length === deletedItems && !inserts.length) {
                return {
                    children: newChildren,
                    moves: null
                };
            }
            return {
                children: newChildren,
                moves: {
                    removes: removes,
                    inserts: inserts
                }
            };
        }
        function remove(arr, index, key) {
            arr.splice(index, 1);
            return {
                from: index,
                key: key
            };
        }
        function keyIndex(children) {
            var keys = {};
            var free = [];
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                if (child.key) {
                    keys[child.key] = i;
                } else {
                    free.push(i);
                }
            }
            return {
                keys: keys,
                free: free
            };
        }
        function appendPatch(apply, patch) {
            if (apply) {
                if (isArray(apply)) {
                    apply.push(patch);
                } else {
                    apply = [ apply, patch ];
                }
                return apply;
            } else {
                return patch;
            }
        }
    }, {
        "../vnode/handle-thunk": 148,
        "../vnode/is-thunk": 149,
        "../vnode/is-vnode": 151,
        "../vnode/is-vtext": 152,
        "../vnode/is-widget": 153,
        "../vnode/vpatch": 156,
        "./diff-props": 158,
        "x-is-array": 136
    } ]
}, {}, [ 1 ]);