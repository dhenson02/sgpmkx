(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        function DOMRef(nodes) {
            return {
                nodes: nodes,
                content: document.getElementById("content"),
                buttons: document.getElementById("buttons"),
                titleField: document.getElementById("titleField"),
                contentWrap: document.getElementById("contentWrap"),
                cheatSheet: document.getElementById("cheatSheet"),
                input: document.getElementById("input"),
                textarea: document.getElementById("textarea"),
                editor: null,
                output: document.getElementById("output"),
                set: function(data) {
                    var name;
                    data = data || nodes || this.nodes;
                    for (name in data) {
                        if (this.hasOwnProperty(name)) {
                            this[name] = data[name];
                        }
                    }
                    return this;
                },
                reset: function() {
                    var name;
                    for (name in nodes) {
                        if (this.hasOwnProperty(name)) {
                            this[name] = null;
                        }
                    }
                    nodes = null;
                }
            };
        }
        module.exports = DOMRef;
    }, {} ],
    2: [ function(require, module, exports) {
        String.prototype.toCamelCase = function() {
            return this.toLowerCase().replace(/\s(.)/g, function($1) {
                return $1.toUpperCase();
            }).replace(/\s/g, "");
        };
        function addEvent(evt, element, fnc) {
            return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent("on" + evt, fnc);
        }
        function removeEvent(evt, element, fnc) {
            return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent("on" + evt, fnc);
        }
        function connError(error) {
            console.log("error connecting:", error);
        }
        var regLoading = / ?loading/gi, regFullPage = / ?fullPage/gi, regCheatSheet = / ?cheatSheet/gi, regNoChange = / ?nochange/gi, md = markdownit({
            xhtmlOut: true,
            typographer: true,
            quotes: "“”‘’",
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(lang, code).value;
                    } catch (e) {}
                }
                return "";
            }
        });
        module.exports = {
            addEvent: addEvent,
            removeEvent: removeEvent,
            connError: connError,
            regLoading: regLoading,
            regFullPage: regFullPage,
            regCheatSheet: regCheatSheet,
            regNoChange: regNoChange,
            md: md
        };
    }, {} ],
    3: [ function(require, module, exports) {
        try {
            var codeMirror = CodeMirror;
        } catch (e) {
            var codeMirror = null;
        }
        var h = require("virtual-dom/h"), diff = require("virtual-dom/diff"), patch = require("virtual-dom/patch"), createElement = require("virtual-dom/create-element"), reqwest = require("reqwest"), Router = require("director/build/director").Router, console = console || require("console"), util = require("./helpers"), Content = require("./store"), DOMRef = require("./domStore"), renderNav = require("./nav"), baseURL = window.location.protocol + "//" + window.location.hostname + "/kj/kx7/PublicHealth", app = {
            sitePath: baseURL + "/_api/lists(guid'4522F7F9-1B5C-4990-9704-991725DEF693')",
            digest: document.getElementById("__REQUESTDIGEST").value,
            pages: {},
            currentContent: new Content(),
            domRefs: new DOMRef(),
            dirtyDOM: null,
            rootNode: null,
            modalDOM: null,
            modalOverlay: null,
            navDOM: null,
            router: null,
            menuItems: null,
            inTransition: {}
        };
        function render(navDOM) {
            return h("#wrapper", [ h("#sideNav", [ navDOM ]), h("#content.fullPage", [ h("#contentWrap", [ h("#output") ]) ]) ]);
        }
        function renderEditor(navDOM, title, text) {
            return h("#wrapper", [ h("#sideNav", [ navDOM ]), h("#content.fullPage", [ h("#buttons", [ h("#toggleButton.btn", {
                onclick: toggleEditor,
                role: "button",
                style: {
                    display: "none"
                }
            }, [ h("span", [ "Toggle Editor" ]) ]), h("div.clearfix"), h("#cheatSheetButton.btn", {
                onclick: toggleCheatSheet,
                role: "button"
            }, [ h("span", [ "Cheat Sheet" ]) ]), h("#saveButton.btn", {
                onclick: savePage,
                role: "button"
            }, [ h("span", [ "Save" ]) ]), h("#createButton.btn", {
                onclick: createPage,
                role: "button"
            }, [ h("span", [ "New" ]) ]) ]), h("#cheatSheet", {
                style: {
                    display: "none"
                }
            }, [ "This will be a cheat-sheet for markdown" ]), h("#contentWrap", [ h("#input", [ h("label#titleFieldLabel", [ "Page title: ", h("input#titleField", {
                onkeyup: updateTitle,
                value: String(title || ""),
                type: "text"
            }) ]), h("textarea#textarea", [ String(text || "") ]) ]), h("#output") ]) ]) ]);
        }
        function renderLink(category, title, li, attr, hr, id, parent, handleNav) {
            return h(li, attr, [ h("a", {
                href: "#" + category,
                onclick: handleNav,
                "data-id": id,
                "data-parent": parent
            }, [ String(title), h("span") ]), hr ]);
        }
        function loadingSomething(status, target) {
            if (status === true) {
                if (app.inTransition[target] === true) {
                    return false;
                }
                app.inTransition[target] = true;
                if (util.regLoading.test(target.className) === false) {
                    app.inTransition["tmp"] = target.innerHTML;
                    target.innerHTML = "<div class='loader-group'><div class='bigSqr'><div class='square first'></div><div class='square second'></div><div class='square third'></div><div class='square fourth'></div></div>loading...</div>";
                    target.className += " loading";
                }
            } else {
                app.inTransition[target] = false;
                target.className = target.className.replace(util.regLoading, "");
            }
        }
        function savePage(event) {
            event = event || window.event;
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            var self = this;
            if (self.nodeName === "#text" || self.nodeType === 3 || self.childNodes.length < 1) {
                self = self.parentNode.parentNode;
            }
            if (self.nodeName === "span") {
                self = self.parentNode;
            }
            app.currentContent.set({
                title: app.currentContent.title.trim(),
                text: app.currentContent.text.trim()
            });
            if (app.currentContent.text === app.currentContent.originalText && app.currentContent.title === app.currentContent.originalTitle) {
                if (!util.regNoChange.test(self.className)) {
                    self.className += " nochange";
                }
                try {
                    self.childNodes[0].innerHTML = "No change";
                } catch (e) {}
                if (app.domRefs.buttons.tempSaveText) {
                    clearTimeout(app.domRefs.buttons.tempSaveText);
                }
                app.domRefs.buttons.tempSaveText = setTimeout(function() {
                    try {
                        self.childNodes[0].innerHTML = "Save";
                    } catch (e) {}
                    self.className = self.className.replace(util.regNoChange, "");
                }, 2e3);
                return false;
            } else {}
            reqwest({
                url: app.sitePath + "/items(" + app.currentContent.id + ")",
                method: "POST",
                data: JSON.stringify({
                    __metadata: {
                        type: app.currentContent.listItemType
                    },
                    Title: app.currentContent.title,
                    Text: app.currentContent.text
                }),
                type: "json",
                contentType: "application/json",
                withCredentials: true,
                headers: {
                    "X-HTTP-Method": "MERGE",
                    Accept: "application/json;odata=verbose",
                    "text-Type": "application/json;odata=verbose",
                    "Content-Type": "application/json;odata=verbose",
                    "X-RequestDigest": app.digest,
                    "IF-MATCH": "*"
                },
                success: function() {
                    console.log("Successfully saved changes.");
                },
                error: util.connError,
                complete: function() {}
            });
        }
        function createPage() {
            newModal({
                title: [ h("h2", [ "New Page" ]) ],
                text: [ h("text", [ "Give it a name:" ]) ],
                selectLabel: [ h("text", [ "Select the parent category" ]) ],
                type: "new"
            }, function(inputValue) {
                if ("object" !== typeof inputValue) {
                    return false;
                }
                reqwest({
                    url: app.sitePath + "/items",
                    method: "POST",
                    data: JSON.stringify({
                        __metadata: {
                            type: app.currentContent.listItemType
                        },
                        Title: inputValue.title,
                        Text: "## New Page :)",
                        Category: inputValue.category
                    }),
                    type: "json",
                    contentType: "application/json",
                    withCredentials: true,
                    headers: {
                        Accept: "application/json;odata=verbose",
                        "text-Type": "application/json;odata=verbose",
                        "Content-Type": "application/json;odata=verbose",
                        "X-RequestDigest": app.digest
                    },
                    success: function() {
                        newModal({
                            title: [ h("h2", [ String(inputValue.title) ]), h("text", [ " was created" ]) ],
                            text: [ h("text", [ "Your page is located at " ]), h("strong", [ String(inputValue.category) ]), h("text", [ "**.\nGo fill it in!" ]) ],
                            type: "success",
                            okText: "Take me",
                            showCancelButton: false
                        }, function() {
                            app.router.setRoute(inputValue.category);
                        });
                    },
                    error: util.connError,
                    complete: function() {}
                });
            });
        }
        function updateTitle() {
            var val = app.domRefs.titleField.value;
            app.domRefs.output.innerHTML = util.md.render("# " + val + "\n" + app.currentContent.text);
            app.currentContent.set({
                title: val
            });
        }
        function newModal(options, callback) {
            options = {
                title: options.title || [ h("h2", [ "Info" ]) ],
                text: options.text || [ h("text", [ "Click OK to continue" ]) ],
                selectLabel: options.selectLabel || [ h("text", [ "Select the parent category" ]) ],
                type: options.type || "success",
                path: options.path || [ h("text", [ String(app.currentContent.category.join("/")) ]) ],
                okText: options.okText || "OK!",
                showCancelButton: typeof options.showCancelButton === "boolean" ? options.showCancelButton : true,
                closeOnConfirm: typeof options.closeOnConfirm === "boolean" ? options.closeOnConfirm : true
            };
            callback = "function" === typeof callback ? callback : null;
            var freshDOM = renderModal(options, callback);
            var patches = diff(app.modalDOM, freshDOM);
            app.modalOverlay = patch(app.modalOverlay, patches);
            app.modalDOM = freshDOM;
            util.addEvent("keyup", document, handleCancel);
        }
        function handleOk(event, callback) {
            event = event || window.event;
            event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            var keyCode = event.keyCode || event.which || event.charCode || null;
            if (event.type === "keyup" && keyCode === 13 || event.type === "click") {
                if (!callback) {
                    modalSuicide();
                    return false;
                }
                var title = document.getElementById("modalInput").value.trim();
                var category = document.getElementById("menuItems").value + title.toCamelCase();
                if (title && category) {
                    callback({
                        title: title,
                        category: category
                    });
                } else {
                    callback(true);
                }
                modalSuicide();
                return false;
            }
        }
        function handleCancel(event, callback) {
            event = event || window.event;
            event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            var self = event.currentTarget || event.srcElement || this;
            var keyCode = event.keyCode || event.which || event.charCode || null;
            if (self.nodeName === "span") {
                self = self.parentNode;
            }
            if (event.type === "click" && (self === event.target || self === event.srcElement) || event.type === "keyup" && keyCode === 27) {
                if (callback) {
                    callback();
                }
                modalSuicide();
                return false;
            }
        }
        function handleChange(event, options, callback) {
            event = event || window.event;
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            var title = document.getElementById("modalInput").value.trim();
            options.path = document.getElementById("menuItems").value + "/" + title.toCamelCase();
            var refreshDOM = renderModal(options, callback);
            var patches = diff(app.modalDOM, refreshDOM);
            app.modalOverlay = patch(app.modalOverlay, patches);
            app.modalDOM = refreshDOM;
            return false;
        }
        function renderLoader() {
            "use strict";
            return h(".loader-group", [ h(".bigSqr", [ h(".square.first"), h(".square.second"), h(".square.third"), h(".square.fourth") ]), h(".text", [ "loading..." ]) ]);
        }
        function renderModal(options, callback) {
            function ok(event) {
                handleOk(event, callback);
            }
            function cancel(event) {
                handleCancel(event, callback);
            }
            function change(event) {
                handleChange(event, options, callback);
            }
            return h(".modalOverlay", {
                style: {
                    zIndex: 7
                }
            }, [ h(".modalBg", {
                onclick: cancel
            }), h(".modal", [ h(".header", options.title), h("label", options.text.concat([ options.type === "new" && h("input#modalInput", {
                type: "text",
                tabIndex: 0,
                autofocus: "",
                onchange: change,
                onkeyup: ok
            }) || null ])), options.type === "new" && options.selectLabel && h("label", options.selectLabel.concat([ options.type === "new" && h("select#menuItems", {
                tabIndex: 1,
                onkeyup: ok,
                onchange: change
            }, app.menuItems || null) || null ])), options.type === "new" && h("blockquote#newPath", options.path), h(".modalButtons", [ h(".okButton.btn", {
                tabIndex: 2,
                onclick: options.type !== "new" ? cancel : ok,
                role: "button"
            }, [ h("span", [ String(options.okText || "OK!") ]) ]), options.showCancelButton && h(".cancelButton.btn", {
                tabIndex: 3,
                onclick: cancel,
                role: "button"
            }, [ h("span", [ "Nope." ]) ]) || null ]) ]) ]);
        }
        function modalSuicide() {
            app.modalOverlay.style.display = "none";
            var destroyModal = h(".modalOverlay", {
                style: {
                    display: "none",
                    zIndex: -1
                }
            });
            var patches = diff(app.modalDOM, destroyModal);
            app.modalOverlay = patch(app.modalOverlay, patches);
            app.modalDOM = destroyModal;
            util.removeEvent("keyup", document, handleCancel);
        }
        function toggleEditor() {
            var hasFullPage = util.regFullPage.test(app.domRefs.content.className);
            app.domRefs.contentWrap.className = "";
            app.domRefs.cheatSheet.className = "";
            if (hasFullPage) {
                app.domRefs.content.className = app.domRefs.content.className.replace(util.regFullPage, "");
                app.domRefs.editor.refresh();
            } else {
                app.domRefs.content.className = app.domRefs.content.className + " fullPage";
            }
            return false;
        }
        function toggleCheatSheet() {
            if (app.domRefs.cheatSheet.style.display === "none") {
                app.domRefs.cheatSheet.removeAttribute("style");
            } else {
                app.domRefs.cheatSheet.style.display = "none";
            }
            return false;
        }
        function update(e) {
            var val = e.getValue();
            app.domRefs.output.innerHTML = util.md.render("# " + app.currentContent.title + "\n" + val);
            app.currentContent.set({
                text: val
            });
        }
        function insertContent(title, text) {
            app.domRefs.output.innerHTML = util.md.render("# " + title + "\n" + text);
        }
        function pageSetup() {
            app.dirtyDOM = !codeMirror ? render(app.navDOM) : renderEditor(app.navDOM, app.currentContent.title, app.currentContent.text);
            app.rootNode = createElement(app.dirtyDOM);
            try {
                var wrapperTmp = document.getElementById("wrapper");
                wrapperTmp.parentNode.replaceChild(app.rootNode, wrapperTmp);
            } catch (e) {
                try {
                    wrapperTmp = document.getElementById("content");
                    wrapperTmp.style.display = "none";
                    wrapperTmp.parentNode.appendChild(app.rootNode);
                } catch (e) {
                    document.body.appendChild(app.rootNode);
                }
            }
            if (codeMirror) {
                app.modalDOM = h(".modalOverlay", {
                    style: {
                        display: "none",
                        opacity: 0
                    }
                });
                app.modalOverlay = createElement(app.modalDOM);
                document.body.appendChild(app.modalOverlay);
            }
            app.domRefs = new DOMRef();
            app.domRefs.set();
            if (window.location.hash) {
                app.router.init();
            } else {
                app.router.init("/");
            }
            try {
                app.rootNode.querySelector("#navWrap a[href='" + window.location.hash + "']").className = "active";
            } catch (e) {
                console.log(e);
            }
            try {
                var hashArray = window.location.hash.slice(2).split(/\//);
                if (hashArray.length > 1) {
                    var subCat = app.rootNode.querySelectorAll("#navWrap a[href^='#/" + hashArray[0] + "/" + hashArray[1] + "/']");
                    if (subCat) {
                        var i = 0, total = subCat.length;
                        for (;i < total; ++i) {
                            subCat[i].parentNode.removeAttribute("style");
                        }
                    }
                }
            } catch (e) {
                console.log("Failed to add sub-cat--open");
            }
        }
        function setupEditor() {
            console.log("Loading editor...");
            var refreshDOM = renderEditor(app.navDOM, app.currentContent.title, app.currentContent.text);
            var patches = diff(app.dirtyDOM, refreshDOM);
            app.rootNode = patch(app.rootNode, patches);
            app.dirtyDOM = refreshDOM;
            app.domRefs = new DOMRef();
            app.domRefs.set({
                editor: codeMirror.fromTextArea(app.domRefs.textarea, {
                    mode: "gfm",
                    lineNumbers: false,
                    matchBrackets: true,
                    lineWrapping: true,
                    theme: "neo",
                    extraKeys: {
                        Enter: "newlineAndIndentContinueMarkdownList"
                    }
                })
            });
            app.domRefs.editor.on("change", update);
            app.domRefs.editor.refresh();
            app.domRefs.buttons.childNodes[0].removeAttribute("style");
            console.log("Editor loaded");
        }
        function resetPage() {
            var oldActive = app.rootNode.querySelectorAll("a.active"), i = 0, total = oldActive.length;
            for (;i < total; ++i) {
                oldActive[i].className = oldActive[i].className.replace(/ ?active/gi, "");
            }
            console.log("PAGE RESET");
            var wrap, refreshDOM, modalRefreshDOM, patches;
            if (codeMirror) {
                if (app.domRefs.editor) {
                    wrap = app.domRefs.editor.getWrapperElement();
                    wrap.parentNode.removeChild(wrap);
                    app.domRefs.set({
                        editor: null
                    });
                }
                refreshDOM = renderEditor(app.navDOM, app.currentContent.title, app.currentContent.text);
                modalRefreshDOM = h(".modalOverlay", {
                    style: {
                        display: "none",
                        opacity: 0
                    }
                });
                patches = diff(app.modalDOM, modalRefreshDOM);
                if (patches.length > 1) {
                    app.modalOverlay = patch(app.modalOverlay, patches);
                    app.modalDOM = modalRefreshDOM;
                    modalSuicide();
                }
            } else {
                refreshDOM = render(app.navDOM);
            }
            patches = diff(app.dirtyDOM, refreshDOM);
            app.rootNode = patch(app.rootNode, patches);
            app.dirtyDOM = refreshDOM;
            app.domRefs = new DOMRef();
            app.domRefs.set();
        }
        function getList() {
            reqwest({
                url: app.sitePath + "/items/?$select=Title,Category",
                method: "GET",
                type: "json",
                contentType: "application/json",
                withCredentials: true,
                headers: {
                    Accept: "application/json;odata=verbose",
                    "text-Type": "application/json;odata=verbose",
                    "Content-Type": "application/json;odata=verbose"
                },
                success: function(data) {
                    function handleNav() {
                        try {
                            var categoryOld = window.location.hash.slice(2).split("/")[1], categoryNew = this.getAttribute("href").slice(2).split("/")[1];
                            if (/ ?sub-cat/gi.test(this.parentNode.className) === false && categoryOld !== categoryNew) {
                                var oldSubCat = app.rootNode.querySelectorAll("#navWrap .sub-cat");
                                i = 0;
                                total = oldSubCat.length;
                                for (;i < total; ++i) {
                                    oldSubCat[i].style.display = "none";
                                }
                            }
                        } catch (e) {
                            oldSubCat = app.rootNode.querySelectorAll("#navWrap .sub-cat");
                            i = 0;
                            total = oldSubCat.length;
                            for (;i < total; ++i) {
                                oldSubCat[i].style.display = "none";
                            }
                        }
                    }
                    var results = data.d.results, pages = {}, fhm = [], fhmLinks = [], comm = [], commLinks = [], i = 0, li, attr, hr, idArray, id, parent, count = results.length, page;
                    for (;i < count; ++i) {
                        li = "li";
                        attr = null;
                        hr = h("hr");
                        page = results[i];
                        pages[page.Category] = page.Title;
                        idArray = page.Category.slice(1).split(/\//g);
                        id = idArray.pop();
                        if (/^\/fhm\//i.test(page.Category)) {
                            fhm.push(h("option", {
                                value: page.Category
                            }, [ String(page.Title) ]));
                            parent = idArray.pop();
                            if (!/^\/fhm\/(\w+)$/i.test(page.Category)) {
                                li = "li.sub-cat";
                                hr = null;
                                attr = {
                                    style: {
                                        display: "none"
                                    }
                                };
                            }
                            fhmLinks.push(renderLink(page.Category, page.Title, li, attr, hr, id, parent, handleNav));
                        }
                        if (/^\/comm\//i.test(page.Category)) {
                            comm.push(h("option", {
                                value: page.Category
                            }, [ String(page.Title) ]));
                            parent = idArray.pop();
                            if (!/^\/comm\/(\w+)$/i.test(page.Category)) {
                                li = "li.sub-cat";
                                hr = null;
                                attr = {
                                    style: {
                                        display: "none"
                                    }
                                };
                            }
                            commLinks.push(renderLink(page.Category, page.Title, li, attr, hr, id, parent, handleNav));
                        }
                    }
                    app.menuItems = [ h("option", {
                        value: "/FHM"
                    }, [ "Force Health Management" ]), h("optgroup", {
                        label: "Sub-Cateogries"
                    }, fhm), h("option", {
                        value: "/Comm"
                    }, [ "Community Health" ]), h("optgroup", {
                        label: "Sub-Cateogries"
                    }, comm) ];
                    app.navDOM = renderNav(fhmLinks, commLinks);
                    console.log(pages);
                    pageSetup();
                },
                error: util.connError
            });
        }
        function init(path) {
            console.log("Begin init...");
            reqwest({
                url: app.sitePath + "/items/?$filter=Category eq '" + path + "'&$select=ID,Title,Text,References,Category",
                method: "GET",
                type: "json",
                contentType: "application/json",
                withCredentials: true,
                headers: {
                    Accept: "application/json;odata=verbose",
                    "text-Type": "application/json;odata=verbose",
                    "Content-Type": "application/json;odata=verbose"
                },
                success: function(data) {
                    if (!data.d.results[0]) {
                        window.location.href = baseURL + "/Pages/main.aspx";
                        return false;
                    }
                    var obj = data.d.results[0];
                    app.currentContent = new Content({
                        id: obj.ID,
                        title: obj.Title || "",
                        text: obj.Text || "",
                        references: obj.References.results || [],
                        category: obj.Category.split("/"),
                        contentType: "Content",
                        listItemType: obj.__metadata.type,
                        timestamp: Date && Date.now() || new Date()
                    });
                    app.currentContent.set();
                    insertContent(app.currentContent.title, app.currentContent.text);
                    loadingSomething(false, app.domRefs.output);
                    try {
                        app.rootNode.querySelector("#navWrap a[href='" + window.location.hash + "']").className = "active";
                    } catch (e) {}
                    try {
                        var hashArray = window.location.hash.slice(2).split(/\//);
                        var subCat = app.rootNode.querySelectorAll("#navWrap a[href^='#/" + hashArray[0] + "/" + hashArray[1] + "/']");
                        if (subCat) {
                            var i = 0;
                            var total = subCat.length;
                            for (;i < total; ++i) {
                                subCat[i].parentNode.style.display = "";
                                subCat[i].parentNode.removeAttribute("style");
                            }
                        }
                    } catch (e) {}
                },
                error: util.connError,
                complete: function() {
                    if (codeMirror) {
                        setupEditor();
                    }
                }
            });
        }
        app.router = Router({
            "/new": {
                on: function() {}
            },
            "/(\\w+)": {
                on: function(root) {
                    loadingSomething(true, app.domRefs.output);
                    init("/" + root);
                },
                "/(\\w+)": {
                    on: function(root, sub) {
                        loadingSomething(true, app.domRefs.output);
                        init("/" + root + "/" + sub);
                    },
                    "/(\\w+)": {
                        on: function(root, sub, inner) {
                            loadingSomething(true, app.domRefs.output);
                            init("/" + root + "/" + sub + "/" + inner);
                        }
                    }
                }
            }
        }).configure({
            strict: false,
            after: resetPage,
            notfound: function() {
                window.location.href = baseURL + "/Pages/main.aspx";
            }
        });
        getList();
        module.exports = app;
    }, {
        "./domStore": 1,
        "./helpers": 2,
        "./nav": 4,
        "./store": 49,
        console: 8,
        "director/build/director": 5,
        reqwest: 14,
        "virtual-dom/create-element": 15,
        "virtual-dom/diff": 16,
        "virtual-dom/h": 17,
        "virtual-dom/patch": 25
    } ],
    4: [ function(require, module, exports) {
        var h = require("virtual-dom/h"), createElement = require("virtual-dom/create-element");
        function render(fhm, comm) {
            return h("div#navWrap.nav", [ h("a.header", {
                href: "main.aspx"
            }, [ h("div.logo", [ h("img", {
                src: "/kj/kx7/PublicHealth/SiteAssets/Pages/landing/phLogo48-gs.png",
                alt: "Public Health Home",
                height: "48",
                width: "48"
            }) ]), h("p.text", [ "Public Health", h("br"), h("small", [ "US Air Force" ]) ]) ]), h("ul", [ h("li", [ h("p.root-cat", [ h("span", [ "Community Health" ]) ]), h("hr"), h("ul", comm) ]), h("li", [ h("p.root-cat", [ h("span", [ "Force Health Management" ]) ]), h("hr"), h("ul", fhm) ]) ]) ]);
        }
        module.exports = render;
    }, {
        "virtual-dom/create-element": 15,
        "virtual-dom/h": 17
    } ],
    5: [ function(require, module, exports) {
        (function(exports) {
            var dloc = document.location;
            function dlocHashEmpty() {
                return dloc.hash === "" || dloc.hash === "#";
            }
            var listener = {
                mode: "modern",
                hash: dloc.hash,
                history: false,
                check: function() {
                    var h = dloc.hash;
                    if (h != this.hash) {
                        this.hash = h;
                        this.onHashChanged();
                    }
                },
                fire: function() {
                    if (this.mode === "modern") {
                        this.history === true ? window.onpopstate() : window.onhashchange();
                    } else {
                        this.onHashChanged();
                    }
                },
                init: function(fn, history) {
                    var self = this;
                    this.history = history;
                    if (!Router.listeners) {
                        Router.listeners = [];
                    }
                    function onchange(onChangeEvent) {
                        for (var i = 0, l = Router.listeners.length; i < l; i++) {
                            Router.listeners[i](onChangeEvent);
                        }
                    }
                    if ("onhashchange" in window && (document.documentMode === undefined || document.documentMode > 7)) {
                        if (this.history === true) {
                            setTimeout(function() {
                                window.onpopstate = onchange;
                            }, 500);
                        } else {
                            window.onhashchange = onchange;
                        }
                        this.mode = "modern";
                    } else {
                        var frame = document.createElement("iframe");
                        frame.id = "state-frame";
                        frame.style.display = "none";
                        document.body.appendChild(frame);
                        this.writeFrame("");
                        if ("onpropertychange" in document && "attachEvent" in document) {
                            document.attachEvent("onpropertychange", function() {
                                if (event.propertyName === "location") {
                                    self.check();
                                }
                            });
                        }
                        window.setInterval(function() {
                            self.check();
                        }, 50);
                        this.onHashChanged = onchange;
                        this.mode = "legacy";
                    }
                    Router.listeners.push(fn);
                    return this.mode;
                },
                destroy: function(fn) {
                    if (!Router || !Router.listeners) {
                        return;
                    }
                    var listeners = Router.listeners;
                    for (var i = listeners.length - 1; i >= 0; i--) {
                        if (listeners[i] === fn) {
                            listeners.splice(i, 1);
                        }
                    }
                },
                setHash: function(s) {
                    if (this.mode === "legacy") {
                        this.writeFrame(s);
                    }
                    if (this.history === true) {
                        window.history.pushState({}, document.title, s);
                        this.fire();
                    } else {
                        dloc.hash = s[0] === "/" ? s : "/" + s;
                    }
                    return this;
                },
                writeFrame: function(s) {
                    var f = document.getElementById("state-frame");
                    var d = f.contentDocument || f.contentWindow.document;
                    d.open();
                    d.write("<script>_hash = '" + s + "'; onload = parent.listener.syncHash;<script>");
                    d.close();
                },
                syncHash: function() {
                    var s = this._hash;
                    if (s != dloc.hash) {
                        dloc.hash = s;
                    }
                    return this;
                },
                onHashChanged: function() {}
            };
            var Router = exports.Router = function(routes) {
                if (!(this instanceof Router)) return new Router(routes);
                this.params = {};
                this.routes = {};
                this.methods = [ "on", "once", "after", "before" ];
                this.scope = [];
                this._methods = {};
                this._insert = this.insert;
                this.insert = this.insertEx;
                this.historySupport = (window.history != null ? window.history.pushState : null) != null;
                this.configure();
                this.mount(routes || {});
            };
            Router.prototype.init = function(r) {
                var self = this, routeTo;
                this.handler = function(onChangeEvent) {
                    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;
                    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, "");
                    self.dispatch("on", url.charAt(0) === "/" ? url : "/" + url);
                };
                listener.init(this.handler, this.history);
                if (this.history === false) {
                    if (dlocHashEmpty() && r) {
                        dloc.hash = r;
                    } else if (!dlocHashEmpty()) {
                        self.dispatch("on", "/" + dloc.hash.replace(/^(#\/|#|\/)/, ""));
                    }
                } else {
                    if (this.convert_hash_in_init) {
                        routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, "") : null;
                        if (routeTo) {
                            window.history.replaceState({}, document.title, routeTo);
                        }
                    } else {
                        routeTo = this.getPath();
                    }
                    if (routeTo || this.run_in_init === true) {
                        this.handler();
                    }
                }
                return this;
            };
            Router.prototype.explode = function() {
                var v = this.history === true ? this.getPath() : dloc.hash;
                if (v.charAt(1) === "/") {
                    v = v.slice(1);
                }
                return v.slice(1, v.length).split("/");
            };
            Router.prototype.setRoute = function(i, v, val) {
                var url = this.explode();
                if (typeof i === "number" && typeof v === "string") {
                    url[i] = v;
                } else if (typeof val === "string") {
                    url.splice(i, v, s);
                } else {
                    url = [ i ];
                }
                listener.setHash(url.join("/"));
                return url;
            };
            Router.prototype.insertEx = function(method, path, route, parent) {
                if (method === "once") {
                    method = "on";
                    route = function(route) {
                        var once = false;
                        return function() {
                            if (once) return;
                            once = true;
                            return route.apply(this, arguments);
                        };
                    }(route);
                }
                return this._insert(method, path, route, parent);
            };
            Router.prototype.getRoute = function(v) {
                var ret = v;
                if (typeof v === "number") {
                    ret = this.explode()[v];
                } else if (typeof v === "string") {
                    var h = this.explode();
                    ret = h.indexOf(v);
                } else {
                    ret = this.explode();
                }
                return ret;
            };
            Router.prototype.destroy = function() {
                listener.destroy(this.handler);
                return this;
            };
            Router.prototype.getPath = function() {
                var path = window.location.pathname;
                if (path.substr(0, 1) !== "/") {
                    path = "/" + path;
                }
                return path;
            };
            function _every(arr, iterator) {
                for (var i = 0; i < arr.length; i += 1) {
                    if (iterator(arr[i], i, arr) === false) {
                        return;
                    }
                }
            }
            function _flatten(arr) {
                var flat = [];
                for (var i = 0, n = arr.length; i < n; i++) {
                    flat = flat.concat(arr[i]);
                }
                return flat;
            }
            function _asyncEverySeries(arr, iterator, callback) {
                if (!arr.length) {
                    return callback();
                }
                var completed = 0;
                (function iterate() {
                    iterator(arr[completed], function(err) {
                        if (err || err === false) {
                            callback(err);
                            callback = function() {};
                        } else {
                            completed += 1;
                            if (completed === arr.length) {
                                callback();
                            } else {
                                iterate();
                            }
                        }
                    });
                })();
            }
            function paramifyString(str, params, mod) {
                mod = str;
                for (var param in params) {
                    if (params.hasOwnProperty(param)) {
                        mod = params[param](str);
                        if (mod !== str) {
                            break;
                        }
                    }
                }
                return mod === str ? "([._a-zA-Z0-9-%()]+)" : mod;
            }
            function regifyString(str, params) {
                var matches, last = 0, out = "";
                while (matches = str.substr(last).match(/[^\w\d\- %@&]*\*[^\w\d\- %@&]*/)) {
                    last = matches.index + matches[0].length;
                    matches[0] = matches[0].replace(/^\*/, "([_.()!\\ %@&a-zA-Z0-9-]+)");
                    out += str.substr(0, matches.index) + matches[0];
                }
                str = out += str.substr(last);
                var captures = str.match(/:([^\/]+)/gi), capture, length;
                if (captures) {
                    length = captures.length;
                    for (var i = 0; i < length; i++) {
                        capture = captures[i];
                        if (capture.slice(0, 2) === "::") {
                            str = capture.slice(1);
                        } else {
                            str = str.replace(capture, paramifyString(capture, params));
                        }
                    }
                }
                return str;
            }
            function terminator(routes, delimiter, start, stop) {
                var last = 0, left = 0, right = 0, start = (start || "(").toString(), stop = (stop || ")").toString(), i;
                for (i = 0; i < routes.length; i++) {
                    var chunk = routes[i];
                    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {
                        left = chunk.indexOf(start, last);
                        right = chunk.indexOf(stop, last);
                        if (~left && !~right || !~left && ~right) {
                            var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);
                            routes = [ tmp ].concat(routes.slice((i || 1) + 1));
                        }
                        last = (right > left ? right : left) + 1;
                        i = 0;
                    } else {
                        last = 0;
                    }
                }
                return routes;
            }
            var QUERY_SEPARATOR = /\?.*/;
            Router.prototype.configure = function(options) {
                options = options || {};
                for (var i = 0; i < this.methods.length; i++) {
                    this._methods[this.methods[i]] = true;
                }
                this.recurse = options.recurse || this.recurse || false;
                this.async = options.async || false;
                this.delimiter = options.delimiter || "/";
                this.strict = typeof options.strict === "undefined" ? true : options.strict;
                this.notfound = options.notfound;
                this.resource = options.resource;
                this.history = options.html5history && this.historySupport || false;
                this.run_in_init = this.history === true && options.run_handler_in_init !== false;
                this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;
                this.every = {
                    after: options.after || null,
                    before: options.before || null,
                    on: options.on || null
                };
                return this;
            };
            Router.prototype.param = function(token, matcher) {
                if (token[0] !== ":") {
                    token = ":" + token;
                }
                var compiled = new RegExp(token, "g");
                this.params[token] = function(str) {
                    return str.replace(compiled, matcher.source || matcher);
                };
                return this;
            };
            Router.prototype.on = Router.prototype.route = function(method, path, route) {
                var self = this;
                if (!route && typeof path == "function") {
                    route = path;
                    path = method;
                    method = "on";
                }
                if (Array.isArray(path)) {
                    return path.forEach(function(p) {
                        self.on(method, p, route);
                    });
                }
                if (path.source) {
                    path = path.source.replace(/\\\//gi, "/");
                }
                if (Array.isArray(method)) {
                    return method.forEach(function(m) {
                        self.on(m.toLowerCase(), path, route);
                    });
                }
                path = path.split(new RegExp(this.delimiter));
                path = terminator(path, this.delimiter);
                this.insert(method, this.scope.concat(path), route);
            };
            Router.prototype.path = function(path, routesFn) {
                var self = this, length = this.scope.length;
                if (path.source) {
                    path = path.source.replace(/\\\//gi, "/");
                }
                path = path.split(new RegExp(this.delimiter));
                path = terminator(path, this.delimiter);
                this.scope = this.scope.concat(path);
                routesFn.call(this, this);
                this.scope.splice(length, path.length);
            };
            Router.prototype.dispatch = function(method, path, callback) {
                var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ""), this.routes, ""), invoked = this._invoked, after;
                this._invoked = true;
                if (!fns || fns.length === 0) {
                    this.last = [];
                    if (typeof this.notfound === "function") {
                        this.invoke([ this.notfound ], {
                            method: method,
                            path: path
                        }, callback);
                    }
                    return false;
                }
                if (this.recurse === "forward") {
                    fns = fns.reverse();
                }
                function updateAndInvoke() {
                    self.last = fns.after;
                    self.invoke(self.runlist(fns), self, callback);
                }
                after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];
                if (after && after.length > 0 && invoked) {
                    if (this.async) {
                        this.invoke(after, this, updateAndInvoke);
                    } else {
                        this.invoke(after, this);
                        updateAndInvoke();
                    }
                    return true;
                }
                updateAndInvoke();
                return true;
            };
            Router.prototype.invoke = function(fns, thisArg, callback) {
                var self = this;
                var apply;
                if (this.async) {
                    apply = function(fn, next) {
                        if (Array.isArray(fn)) {
                            return _asyncEverySeries(fn, apply, next);
                        } else if (typeof fn == "function") {
                            fn.apply(thisArg, (fns.captures || []).concat(next));
                        }
                    };
                    _asyncEverySeries(fns, apply, function() {
                        if (callback) {
                            callback.apply(thisArg, arguments);
                        }
                    });
                } else {
                    apply = function(fn) {
                        if (Array.isArray(fn)) {
                            return _every(fn, apply);
                        } else if (typeof fn === "function") {
                            return fn.apply(thisArg, fns.captures || []);
                        } else if (typeof fn === "string" && self.resource) {
                            self.resource[fn].apply(thisArg, fns.captures || []);
                        }
                    };
                    _every(fns, apply);
                }
            };
            Router.prototype.traverse = function(method, path, routes, regexp, filter) {
                var fns = [], current, exact, match, next, that;
                function filterRoutes(routes) {
                    if (!filter) {
                        return routes;
                    }
                    function deepCopy(source) {
                        var result = [];
                        for (var i = 0; i < source.length; i++) {
                            result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
                        }
                        return result;
                    }
                    function applyFilter(fns) {
                        for (var i = fns.length - 1; i >= 0; i--) {
                            if (Array.isArray(fns[i])) {
                                applyFilter(fns[i]);
                                if (fns[i].length === 0) {
                                    fns.splice(i, 1);
                                }
                            } else {
                                if (!filter(fns[i])) {
                                    fns.splice(i, 1);
                                }
                            }
                        }
                    }
                    var newRoutes = deepCopy(routes);
                    newRoutes.matched = routes.matched;
                    newRoutes.captures = routes.captures;
                    newRoutes.after = routes.after.filter(filter);
                    applyFilter(newRoutes);
                    return newRoutes;
                }
                if (path === this.delimiter && routes[method]) {
                    next = [ [ routes.before, routes[method] ].filter(Boolean) ];
                    next.after = [ routes.after ].filter(Boolean);
                    next.matched = true;
                    next.captures = [];
                    return filterRoutes(next);
                }
                for (var r in routes) {
                    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === "object" && !Array.isArray(routes[r]))) {
                        current = exact = regexp + this.delimiter + r;
                        if (!this.strict) {
                            exact += "[" + this.delimiter + "]?";
                        }
                        match = path.match(new RegExp("^" + exact));
                        if (!match) {
                            continue;
                        }
                        if (match[0] && match[0] == path && routes[r][method]) {
                            next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];
                            next.after = [ routes[r].after ].filter(Boolean);
                            next.matched = true;
                            next.captures = match.slice(1);
                            if (this.recurse && routes === this.routes) {
                                next.push([ routes.before, routes.on ].filter(Boolean));
                                next.after = next.after.concat([ routes.after ].filter(Boolean));
                            }
                            return filterRoutes(next);
                        }
                        next = this.traverse(method, path, routes[r], current);
                        if (next.matched) {
                            if (next.length > 0) {
                                fns = fns.concat(next);
                            }
                            if (this.recurse) {
                                fns.push([ routes[r].before, routes[r].on ].filter(Boolean));
                                next.after = next.after.concat([ routes[r].after ].filter(Boolean));
                                if (routes === this.routes) {
                                    fns.push([ routes["before"], routes["on"] ].filter(Boolean));
                                    next.after = next.after.concat([ routes["after"] ].filter(Boolean));
                                }
                            }
                            fns.matched = true;
                            fns.captures = next.captures;
                            fns.after = next.after;
                            return filterRoutes(fns);
                        }
                    }
                }
                return false;
            };
            Router.prototype.insert = function(method, path, route, parent) {
                var methodType, parentType, isArray, nested, part;
                path = path.filter(function(p) {
                    return p && p.length > 0;
                });
                parent = parent || this.routes;
                part = path.shift();
                if (/\:|\*/.test(part) && !/\\d|\\w/.test(part)) {
                    part = regifyString(part, this.params);
                }
                if (path.length > 0) {
                    parent[part] = parent[part] || {};
                    return this.insert(method, path, route, parent[part]);
                }
                if (!part && !path.length && parent === this.routes) {
                    methodType = typeof parent[method];
                    switch (methodType) {
                      case "function":
                        parent[method] = [ parent[method], route ];
                        return;

                      case "object":
                        parent[method].push(route);
                        return;

                      case "undefined":
                        parent[method] = route;
                        return;
                    }
                    return;
                }
                parentType = typeof parent[part];
                isArray = Array.isArray(parent[part]);
                if (parent[part] && !isArray && parentType == "object") {
                    methodType = typeof parent[part][method];
                    switch (methodType) {
                      case "function":
                        parent[part][method] = [ parent[part][method], route ];
                        return;

                      case "object":
                        parent[part][method].push(route);
                        return;

                      case "undefined":
                        parent[part][method] = route;
                        return;
                    }
                } else if (parentType == "undefined") {
                    nested = {};
                    nested[method] = route;
                    parent[part] = nested;
                    return;
                }
                throw new Error("Invalid route context: " + parentType);
            };
            Router.prototype.extend = function(methods) {
                var self = this, len = methods.length, i;
                function extend(method) {
                    self._methods[method] = true;
                    self[method] = function() {
                        var extra = arguments.length === 1 ? [ method, "" ] : [ method ];
                        self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
                    };
                }
                for (i = 0; i < len; i++) {
                    extend(methods[i]);
                }
            };
            Router.prototype.runlist = function(fns) {
                var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);
                if (this.every && this.every.on) {
                    runlist.push(this.every.on);
                }
                runlist.captures = fns.captures;
                runlist.source = fns.source;
                return runlist;
            };
            Router.prototype.mount = function(routes, path) {
                if (!routes || typeof routes !== "object" || Array.isArray(routes)) {
                    return;
                }
                var self = this;
                path = path || [];
                if (!Array.isArray(path)) {
                    path = path.split(self.delimiter);
                }
                function insertOrMount(route, local) {
                    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === "" || !self._methods[parts[0]], event = isRoute ? "on" : rename;
                    if (isRoute) {
                        rename = rename.slice((rename.match(new RegExp("^" + self.delimiter)) || [ "" ])[0].length);
                        parts.shift();
                    }
                    if (isRoute && routeType === "object" && !Array.isArray(routes[route])) {
                        local = local.concat(parts);
                        self.mount(routes[route], local);
                        return;
                    }
                    if (isRoute) {
                        local = local.concat(rename.split(self.delimiter));
                        local = terminator(local, self.delimiter);
                    }
                    self.insert(event, local, routes[route]);
                }
                for (var route in routes) {
                    if (routes.hasOwnProperty(route)) {
                        insertOrMount(route, path.slice(0));
                    }
                }
            };
        })(typeof exports === "object" ? exports : window);
    }, {} ],
    6: [ function(require, module, exports) {
        var util = require("util/");
        var pSlice = Array.prototype.slice;
        var hasOwn = Object.prototype.hasOwnProperty;
        var assert = module.exports = ok;
        assert.AssertionError = function AssertionError(options) {
            this.name = "AssertionError";
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
            } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
            }
            var stackStartFunction = options.stackStartFunction || fail;
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
            } else {
                var err = new Error();
                if (err.stack) {
                    var out = err.stack;
                    var fn_name = stackStartFunction.name;
                    var idx = out.indexOf("\n" + fn_name);
                    if (idx >= 0) {
                        var next_line = out.indexOf("\n", idx + 1);
                        out = out.substring(next_line + 1);
                    }
                    this.stack = out;
                }
            }
        };
        util.inherits(assert.AssertionError, Error);
        function replacer(key, value) {
            if (util.isUndefined(value)) {
                return "" + value;
            }
            if (util.isNumber(value) && !isFinite(value)) {
                return value.toString();
            }
            if (util.isFunction(value) || util.isRegExp(value)) {
                return value.toString();
            }
            return value;
        }
        function truncate(s, n) {
            if (util.isString(s)) {
                return s.length < n ? s : s.slice(0, n);
            } else {
                return s;
            }
        }
        function getMessage(self) {
            return truncate(JSON.stringify(self.actual, replacer), 128) + " " + self.operator + " " + truncate(JSON.stringify(self.expected, replacer), 128);
        }
        function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
                message: message,
                actual: actual,
                expected: expected,
                operator: operator,
                stackStartFunction: stackStartFunction
            });
        }
        assert.fail = fail;
        function ok(value, message) {
            if (!value) fail(value, true, message, "==", assert.ok);
        }
        assert.ok = ok;
        assert.equal = function equal(actual, expected, message) {
            if (actual != expected) fail(actual, expected, message, "==", assert.equal);
        };
        assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
                fail(actual, expected, message, "!=", assert.notEqual);
            }
        };
        assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected)) {
                fail(actual, expected, message, "deepEqual", assert.deepEqual);
            }
        };
        function _deepEqual(actual, expected) {
            if (actual === expected) {
                return true;
            } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
                if (actual.length != expected.length) return false;
                for (var i = 0; i < actual.length; i++) {
                    if (actual[i] !== expected[i]) return false;
                }
                return true;
            } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if (!util.isObject(actual) && !util.isObject(expected)) {
                return actual == expected;
            } else {
                return objEquiv(actual, expected);
            }
        }
        function isArguments(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
        }
        function objEquiv(a, b) {
            if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b)) return false;
            if (a.prototype !== b.prototype) return false;
            if (util.isPrimitive(a) || util.isPrimitive(b)) {
                return a === b;
            }
            var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
            if (aIsArgs) {
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b);
            }
            var ka = objectKeys(a), kb = objectKeys(b), key, i;
            if (ka.length != kb.length) return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] != kb[i]) return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key])) return false;
            }
            return true;
        }
        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected)) {
                fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
            }
        };
        assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
                fail(actual, expected, message, "===", assert.strictEqual);
            }
        };
        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
                fail(actual, expected, message, "!==", assert.notStrictEqual);
            }
        };
        function expectedException(actual, expected) {
            if (!actual || !expected) {
                return false;
            }
            if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                return expected.test(actual);
            } else if (actual instanceof expected) {
                return true;
            } else if (expected.call({}, actual) === true) {
                return true;
            }
            return false;
        }
        function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (util.isString(expected)) {
                message = expected;
                expected = null;
            }
            try {
                block();
            } catch (e) {
                actual = e;
            }
            message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
            if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
            }
            if (!shouldThrow && expectedException(actual, expected)) {
                fail(actual, expected, "Got unwanted exception" + message);
            }
            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                throw actual;
            }
        }
        assert.throws = function(block, error, message) {
            _throws.apply(this, [ true ].concat(pSlice.call(arguments)));
        };
        assert.doesNotThrow = function(block, message) {
            _throws.apply(this, [ false ].concat(pSlice.call(arguments)));
        };
        assert.ifError = function(err) {
            if (err) {
                throw err;
            }
        };
        var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
                if (hasOwn.call(obj, key)) keys.push(key);
            }
            return keys;
        };
    }, {
        "util/": 13
    } ],
    7: [ function(require, module, exports) {}, {} ],
    8: [ function(require, module, exports) {
        (function(global) {
            var util = require("util");
            var assert = require("assert");
            var now = require("date-now");
            var slice = Array.prototype.slice;
            var console;
            var times = {};
            if (typeof global !== "undefined" && global.console) {
                console = global.console;
            } else if (typeof window !== "undefined" && window.console) {
                console = window.console;
            } else {
                console = {};
            }
            var functions = [ [ log, "log" ], [ info, "info" ], [ warn, "warn" ], [ error, "error" ], [ time, "time" ], [ timeEnd, "timeEnd" ], [ trace, "trace" ], [ dir, "dir" ], [ consoleAssert, "assert" ] ];
            for (var i = 0; i < functions.length; i++) {
                var tuple = functions[i];
                var f = tuple[0];
                var name = tuple[1];
                if (!console[name]) {
                    console[name] = f;
                }
            }
            module.exports = console;
            function log() {}
            function info() {
                console.log.apply(console, arguments);
            }
            function warn() {
                console.log.apply(console, arguments);
            }
            function error() {
                console.warn.apply(console, arguments);
            }
            function time(label) {
                times[label] = now();
            }
            function timeEnd(label) {
                var time = times[label];
                if (!time) {
                    throw new Error("No such label: " + label);
                }
                var duration = now() - time;
                console.log(label + ": " + duration + "ms");
            }
            function trace() {
                var err = new Error();
                err.name = "Trace";
                err.message = util.format.apply(null, arguments);
                console.error(err.stack);
            }
            function dir(object) {
                console.log(util.inspect(object) + "\n");
            }
            function consoleAssert(expression) {
                if (!expression) {
                    var arr = slice.call(arguments, 1);
                    assert.ok(false, util.format.apply(null, arr));
                }
            }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        assert: 6,
        "date-now": 9,
        util: 13
    } ],
    9: [ function(require, module, exports) {
        module.exports = now;
        function now() {
            return new Date().getTime();
        }
    }, {} ],
    10: [ function(require, module, exports) {
        if (typeof Object.create === "function") {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            };
        }
    }, {} ],
    11: [ function(require, module, exports) {
        var process = module.exports = {};
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = setTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    currentQueue[queueIndex].run();
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            clearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                setTimeout(drainQueue, 0);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    12: [ function(require, module, exports) {
        module.exports = function isBuffer(arg) {
            return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
        };
    }, {} ],
    13: [ function(require, module, exports) {
        (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
                if (!isString(f)) {
                    var objects = [];
                    for (var i = 0; i < arguments.length; i++) {
                        objects.push(inspect(arguments[i]));
                    }
                    return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x) {
                    if (x === "%%") return "%";
                    if (i >= len) return x;
                    switch (x) {
                      case "%s":
                        return String(args[i++]);

                      case "%d":
                        return Number(args[i++]);

                      case "%j":
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return "[Circular]";
                        }

                      default:
                        return x;
                    }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                    if (isNull(x) || !isObject(x)) {
                        str += " " + x;
                    } else {
                        str += " " + inspect(x);
                    }
                }
                return str;
            };
            exports.deprecate = function(fn, msg) {
                if (isUndefined(global.process)) {
                    return function() {
                        return exports.deprecate(fn, msg).apply(this, arguments);
                    };
                }
                if (process.noDeprecation === true) {
                    return fn;
                }
                var warned = false;
                function deprecated() {
                    if (!warned) {
                        if (process.throwDeprecation) {
                            throw new Error(msg);
                        } else if (process.traceDeprecation) {
                            console.trace(msg);
                        } else {
                            console.error(msg);
                        }
                        warned = true;
                    }
                    return fn.apply(this, arguments);
                }
                return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports.debuglog = function(set) {
                if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
                set = set.toUpperCase();
                if (!debugs[set]) {
                    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error("%s %d: %s", set, pid, msg);
                        };
                    } else {
                        debugs[set] = function() {};
                    }
                }
                return debugs[set];
            };
            function inspect(obj, opts) {
                var ctx = {
                    seen: [],
                    stylize: stylizeNoColor
                };
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                    ctx.showHidden = opts;
                } else if (opts) {
                    exports._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;
            inspect.colors = {
                bold: [ 1, 22 ],
                italic: [ 3, 23 ],
                underline: [ 4, 24 ],
                inverse: [ 7, 27 ],
                white: [ 37, 39 ],
                grey: [ 90, 39 ],
                black: [ 30, 39 ],
                blue: [ 34, 39 ],
                cyan: [ 36, 39 ],
                green: [ 32, 39 ],
                magenta: [ 35, 39 ],
                red: [ 31, 39 ],
                yellow: [ 33, 39 ]
            };
            inspect.styles = {
                special: "cyan",
                number: "yellow",
                "boolean": "yellow",
                undefined: "grey",
                "null": "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            };
            function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
                } else {
                    return str;
                }
            }
            function stylizeNoColor(str, styleType) {
                return str;
            }
            function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                    hash[val] = true;
                });
                return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    if (!isString(ret)) {
                        ret = formatValue(ctx, ret, recurseTimes);
                    }
                    return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                    return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                    keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                    return formatError(value);
                }
                if (keys.length === 0) {
                    if (isFunction(value)) {
                        var name = value.name ? ": " + value.name : "";
                        return ctx.stylize("[Function" + name + "]", "special");
                    }
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    }
                    if (isDate(value)) {
                        return ctx.stylize(Date.prototype.toString.call(value), "date");
                    }
                    if (isError(value)) {
                        return formatError(value);
                    }
                }
                var base = "", array = false, braces = [ "{", "}" ];
                if (isArray(value)) {
                    array = true;
                    braces = [ "[", "]" ];
                }
                if (isFunction(value)) {
                    var n = value.name ? ": " + value.name : "";
                    base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                    base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                    base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                    base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                    return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    } else {
                        return ctx.stylize("[Object]", "special");
                    }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                    output = keys.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
                if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return ctx.stylize(simple, "string");
                }
                if (isNumber(value)) return ctx.stylize("" + value, "number");
                if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                if (isNull(value)) return ctx.stylize("null", "null");
            }
            function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                    if (hasOwnProperty(value, String(i))) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                    } else {
                        output.push("");
                    }
                }
                keys.forEach(function(key) {
                    if (!key.match(/^\d+$/)) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                    }
                });
                return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || {
                    value: value[key]
                };
                if (desc.get) {
                    if (desc.set) {
                        str = ctx.stylize("[Getter/Setter]", "special");
                    } else {
                        str = ctx.stylize("[Getter]", "special");
                    }
                } else {
                    if (desc.set) {
                        str = ctx.stylize("[Setter]", "special");
                    }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                    name = "[" + key + "]";
                }
                if (!str) {
                    if (ctx.seen.indexOf(desc.value) < 0) {
                        if (isNull(recurseTimes)) {
                            str = formatValue(ctx, desc.value, null);
                        } else {
                            str = formatValue(ctx, desc.value, recurseTimes - 1);
                        }
                        if (str.indexOf("\n") > -1) {
                            if (array) {
                                str = str.split("\n").map(function(line) {
                                    return "  " + line;
                                }).join("\n").substr(2);
                            } else {
                                str = "\n" + str.split("\n").map(function(line) {
                                    return "   " + line;
                                }).join("\n");
                            }
                        }
                    } else {
                        str = ctx.stylize("[Circular]", "special");
                    }
                }
                if (isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) {
                        return str;
                    }
                    name = JSON.stringify("" + key);
                    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                        name = name.substr(1, name.length - 2);
                        name = ctx.stylize(name, "name");
                    } else {
                        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                        name = ctx.stylize(name, "string");
                    }
                }
                return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                    numLinesEst++;
                    if (cur.indexOf("\n") >= 0) numLinesEst++;
                    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
                return typeof arg === "boolean";
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
                return typeof arg === "number";
            }
            exports.isNumber = isNumber;
            function isString(arg) {
                return typeof arg === "string";
            }
            exports.isString = isString;
            function isSymbol(arg) {
                return typeof arg === "symbol";
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
                return typeof arg === "object" && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports.isDate = isDate;
            function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
                return typeof arg === "function";
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
            }
            exports.isPrimitive = isPrimitive;
            exports.isBuffer = require("./support/isBuffer");
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
            function timestamp() {
                var d = new Date();
                var time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
                return [ d.getDate(), months[d.getMonth()], time ].join(" ");
            }
            exports.log = function() {
                console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
            };
            exports.inherits = require("inherits");
            exports._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                    origin[keys[i]] = add[keys[i]];
                }
                return origin;
            };
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
        }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        "./support/isBuffer": 12,
        _process: 11,
        inherits: 10
    } ],
    14: [ function(require, module, exports) {
        !function(name, context, definition) {
            if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
        }("reqwest", this, function() {
            var context = this;
            if ("window" in context) {
                var doc = document, byTag = "getElementsByTagName", head = doc[byTag]("head")[0];
            } else {
                var XHR2;
                try {
                    XHR2 = require("xhr2");
                } catch (ex) {
                    throw new Error("Peer dependency `xhr2` required! Please npm install xhr2");
                }
            }
            var httpsRe = /^http/, protocolRe = /(^\w+):\/\//, twoHundo = /^(20\d|1223)$/, readyState = "readyState", contentType = "Content-Type", requestedWith = "X-Requested-With", uniqid = 0, callbackPrefix = "reqwest_" + +new Date(), lastValue, xmlHttpRequest = "XMLHttpRequest", xDomainRequest = "XDomainRequest", noop = function() {}, isArray = typeof Array.isArray == "function" ? Array.isArray : function(a) {
                return a instanceof Array;
            }, defaultHeaders = {
                contentType: "application/x-www-form-urlencoded",
                requestedWith: xmlHttpRequest,
                accept: {
                    "*": "text/javascript, text/html, application/xml, text/xml, */*",
                    xml: "application/xml, text/xml",
                    html: "text/html",
                    text: "text/plain",
                    json: "application/json, text/javascript",
                    js: "application/javascript, text/javascript"
                }
            }, xhr = function(o) {
                if (o["crossOrigin"] === true) {
                    var xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null;
                    if (xhr && "withCredentials" in xhr) {
                        return xhr;
                    } else if (context[xDomainRequest]) {
                        return new XDomainRequest();
                    } else {
                        throw new Error("Browser does not support cross-origin requests");
                    }
                } else if (context[xmlHttpRequest]) {
                    return new XMLHttpRequest();
                } else if (XHR2) {
                    return new XHR2();
                } else {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                }
            }, globalSetupOptions = {
                dataFilter: function(data) {
                    return data;
                }
            };
            function succeed(r) {
                var protocol = protocolRe.exec(r.url);
                protocol = protocol && protocol[1] || context.location.protocol;
                return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
            }
            function handleReadyState(r, success, error) {
                return function() {
                    if (r._aborted) return error(r.request);
                    if (r._timedOut) return error(r.request, "Request is aborted: timeout");
                    if (r.request && r.request[readyState] == 4) {
                        r.request.onreadystatechange = noop;
                        if (succeed(r)) success(r.request); else error(r.request);
                    }
                };
            }
            function setHeaders(http, o) {
                var headers = o["headers"] || {}, h;
                headers["Accept"] = headers["Accept"] || defaultHeaders["accept"][o["type"]] || defaultHeaders["accept"]["*"];
                var isAFormData = typeof FormData === "function" && o["data"] instanceof FormData;
                if (!o["crossOrigin"] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders["requestedWith"];
                if (!headers[contentType] && !isAFormData) headers[contentType] = o["contentType"] || defaultHeaders["contentType"];
                for (h in headers) headers.hasOwnProperty(h) && "setRequestHeader" in http && http.setRequestHeader(h, headers[h]);
            }
            function setCredentials(http, o) {
                if (typeof o["withCredentials"] !== "undefined" && typeof http.withCredentials !== "undefined") {
                    http.withCredentials = !!o["withCredentials"];
                }
            }
            function generalCallback(data) {
                lastValue = data;
            }
            function urlappend(url, s) {
                return url + (/\?/.test(url) ? "&" : "?") + s;
            }
            function handleJsonp(o, fn, err, url) {
                var reqId = uniqid++, cbkey = o["jsonpCallback"] || "callback", cbval = o["jsonpCallbackName"] || reqwest.getcallbackPrefix(reqId), cbreg = new RegExp("((^|\\?|&)" + cbkey + ")=([^&]+)"), match = url.match(cbreg), script = doc.createElement("script"), loaded = 0, isIE10 = navigator.userAgent.indexOf("MSIE 10.0") !== -1;
                if (match) {
                    if (match[3] === "?") {
                        url = url.replace(cbreg, "$1=" + cbval);
                    } else {
                        cbval = match[3];
                    }
                } else {
                    url = urlappend(url, cbkey + "=" + cbval);
                }
                context[cbval] = generalCallback;
                script.type = "text/javascript";
                script.src = url;
                script.async = true;
                if (typeof script.onreadystatechange !== "undefined" && !isIE10) {
                    script.htmlFor = script.id = "_reqwest_" + reqId;
                }
                script.onload = script.onreadystatechange = function() {
                    if (script[readyState] && script[readyState] !== "complete" && script[readyState] !== "loaded" || loaded) {
                        return false;
                    }
                    script.onload = script.onreadystatechange = null;
                    script.onclick && script.onclick();
                    fn(lastValue);
                    lastValue = undefined;
                    head.removeChild(script);
                    loaded = 1;
                };
                head.appendChild(script);
                return {
                    abort: function() {
                        script.onload = script.onreadystatechange = null;
                        err({}, "Request is aborted: timeout", {});
                        lastValue = undefined;
                        head.removeChild(script);
                        loaded = 1;
                    }
                };
            }
            function getRequest(fn, err) {
                var o = this.o, method = (o["method"] || "GET").toUpperCase(), url = typeof o === "string" ? o : o["url"], data = o["processData"] !== false && o["data"] && typeof o["data"] !== "string" ? reqwest.toQueryString(o["data"]) : o["data"] || null, http, sendWait = false;
                if ((o["type"] == "jsonp" || method == "GET") && data) {
                    url = urlappend(url, data);
                    data = null;
                }
                if (o["type"] == "jsonp") return handleJsonp(o, fn, err, url);
                http = o.xhr && o.xhr(o) || xhr(o);
                http.open(method, url, o["async"] === false ? false : true);
                setHeaders(http, o);
                setCredentials(http, o);
                if (context[xDomainRequest] && http instanceof context[xDomainRequest]) {
                    http.onload = fn;
                    http.onerror = err;
                    http.onprogress = function() {};
                    sendWait = true;
                } else {
                    http.onreadystatechange = handleReadyState(this, fn, err);
                }
                o["before"] && o["before"](http);
                if (sendWait) {
                    setTimeout(function() {
                        http.send(data);
                    }, 200);
                } else {
                    http.send(data);
                }
                return http;
            }
            function Reqwest(o, fn) {
                this.o = o;
                this.fn = fn;
                init.apply(this, arguments);
            }
            function setType(header) {
                if (header.match("json")) return "json";
                if (header.match("javascript")) return "js";
                if (header.match("text")) return "html";
                if (header.match("xml")) return "xml";
            }
            function init(o, fn) {
                this.url = typeof o == "string" ? o : o["url"];
                this.timeout = null;
                this._fulfilled = false;
                this._successHandler = function() {};
                this._fulfillmentHandlers = [];
                this._errorHandlers = [];
                this._completeHandlers = [];
                this._erred = false;
                this._responseArgs = {};
                var self = this;
                fn = fn || function() {};
                if (o["timeout"]) {
                    this.timeout = setTimeout(function() {
                        timedOut();
                    }, o["timeout"]);
                }
                if (o["success"]) {
                    this._successHandler = function() {
                        o["success"].apply(o, arguments);
                    };
                }
                if (o["error"]) {
                    this._errorHandlers.push(function() {
                        o["error"].apply(o, arguments);
                    });
                }
                if (o["complete"]) {
                    this._completeHandlers.push(function() {
                        o["complete"].apply(o, arguments);
                    });
                }
                function complete(resp) {
                    o["timeout"] && clearTimeout(self.timeout);
                    self.timeout = null;
                    while (self._completeHandlers.length > 0) {
                        self._completeHandlers.shift()(resp);
                    }
                }
                function success(resp) {
                    var type = o["type"] || resp && setType(resp.getResponseHeader("Content-Type"));
                    resp = type !== "jsonp" ? self.request : resp;
                    var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type), r = filteredResponse;
                    try {
                        resp.responseText = r;
                    } catch (e) {}
                    if (r) {
                        switch (type) {
                          case "json":
                            try {
                                resp = context.JSON ? context.JSON.parse(r) : eval("(" + r + ")");
                            } catch (err) {
                                return error(resp, "Could not parse JSON in response", err);
                            }
                            break;

                          case "js":
                            resp = eval(r);
                            break;

                          case "html":
                            resp = r;
                            break;

                          case "xml":
                            resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
                            break;
                        }
                    }
                    self._responseArgs.resp = resp;
                    self._fulfilled = true;
                    fn(resp);
                    self._successHandler(resp);
                    while (self._fulfillmentHandlers.length > 0) {
                        resp = self._fulfillmentHandlers.shift()(resp);
                    }
                    complete(resp);
                }
                function timedOut() {
                    self._timedOut = true;
                    self.request.abort();
                }
                function error(resp, msg, t) {
                    resp = self.request;
                    self._responseArgs.resp = resp;
                    self._responseArgs.msg = msg;
                    self._responseArgs.t = t;
                    self._erred = true;
                    while (self._errorHandlers.length > 0) {
                        self._errorHandlers.shift()(resp, msg, t);
                    }
                    complete(resp);
                }
                this.request = getRequest.call(this, success, error);
            }
            Reqwest.prototype = {
                abort: function() {
                    this._aborted = true;
                    this.request.abort();
                },
                retry: function() {
                    init.call(this, this.o, this.fn);
                },
                then: function(success, fail) {
                    success = success || function() {};
                    fail = fail || function() {};
                    if (this._fulfilled) {
                        this._responseArgs.resp = success(this._responseArgs.resp);
                    } else if (this._erred) {
                        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
                    } else {
                        this._fulfillmentHandlers.push(success);
                        this._errorHandlers.push(fail);
                    }
                    return this;
                },
                always: function(fn) {
                    if (this._fulfilled || this._erred) {
                        fn(this._responseArgs.resp);
                    } else {
                        this._completeHandlers.push(fn);
                    }
                    return this;
                },
                fail: function(fn) {
                    if (this._erred) {
                        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
                    } else {
                        this._errorHandlers.push(fn);
                    }
                    return this;
                },
                "catch": function(fn) {
                    return this.fail(fn);
                }
            };
            function reqwest(o, fn) {
                return new Reqwest(o, fn);
            }
            function normalize(s) {
                return s ? s.replace(/\r?\n/g, "\r\n") : "";
            }
            function serial(el, cb) {
                var n = el.name, t = el.tagName.toLowerCase(), optCb = function(o) {
                    if (o && !o["disabled"]) cb(n, normalize(o["attributes"]["value"] && o["attributes"]["value"]["specified"] ? o["value"] : o["text"]));
                }, ch, ra, val, i;
                if (el.disabled || !n) return;
                switch (t) {
                  case "input":
                    if (!/reset|button|image|file/i.test(el.type)) {
                        ch = /checkbox/i.test(el.type);
                        ra = /radio/i.test(el.type);
                        val = el.value;
                        (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === "" ? "on" : val));
                    }
                    break;

                  case "textarea":
                    cb(n, normalize(el.value));
                    break;

                  case "select":
                    if (el.type.toLowerCase() === "select-one") {
                        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
                    } else {
                        for (i = 0; el.length && i < el.length; i++) {
                            el.options[i].selected && optCb(el.options[i]);
                        }
                    }
                    break;
                }
            }
            function eachFormElement() {
                var cb = this, e, i, serializeSubtags = function(e, tags) {
                    var i, j, fa;
                    for (i = 0; i < tags.length; i++) {
                        fa = e[byTag](tags[i]);
                        for (j = 0; j < fa.length; j++) serial(fa[j], cb);
                    }
                };
                for (i = 0; i < arguments.length; i++) {
                    e = arguments[i];
                    if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
                    serializeSubtags(e, [ "input", "select", "textarea" ]);
                }
            }
            function serializeQueryString() {
                return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
            }
            function serializeHash() {
                var hash = {};
                eachFormElement.apply(function(name, value) {
                    if (name in hash) {
                        hash[name] && !isArray(hash[name]) && (hash[name] = [ hash[name] ]);
                        hash[name].push(value);
                    } else hash[name] = value;
                }, arguments);
                return hash;
            }
            reqwest.serializeArray = function() {
                var arr = [];
                eachFormElement.apply(function(name, value) {
                    arr.push({
                        name: name,
                        value: value
                    });
                }, arguments);
                return arr;
            };
            reqwest.serialize = function() {
                if (arguments.length === 0) return "";
                var opt, fn, args = Array.prototype.slice.call(arguments, 0);
                opt = args.pop();
                opt && opt.nodeType && args.push(opt) && (opt = null);
                opt && (opt = opt.type);
                if (opt == "map") fn = serializeHash; else if (opt == "array") fn = reqwest.serializeArray; else fn = serializeQueryString;
                return fn.apply(null, args);
            };
            reqwest.toQueryString = function(o, trad) {
                var prefix, i, traditional = trad || false, s = [], enc = encodeURIComponent, add = function(key, value) {
                    value = "function" === typeof value ? value() : value == null ? "" : value;
                    s[s.length] = enc(key) + "=" + enc(value);
                };
                if (isArray(o)) {
                    for (i = 0; o && i < o.length; i++) add(o[i]["name"], o[i]["value"]);
                } else {
                    for (prefix in o) {
                        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
                    }
                }
                return s.join("&").replace(/%20/g, "+");
            };
            function buildParams(prefix, obj, traditional, add) {
                var name, i, v, rbracket = /\[\]$/;
                if (isArray(obj)) {
                    for (i = 0; obj && i < obj.length; i++) {
                        v = obj[i];
                        if (traditional || rbracket.test(prefix)) {
                            add(prefix, v);
                        } else {
                            buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                        }
                    }
                } else if (obj && obj.toString() === "[object Object]") {
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }
                } else {
                    add(prefix, obj);
                }
            }
            reqwest.getcallbackPrefix = function() {
                return callbackPrefix;
            };
            reqwest.compat = function(o, fn) {
                if (o) {
                    o["type"] && (o["method"] = o["type"]) && delete o["type"];
                    o["dataType"] && (o["type"] = o["dataType"]);
                    o["jsonpCallback"] && (o["jsonpCallbackName"] = o["jsonpCallback"]) && delete o["jsonpCallback"];
                    o["jsonp"] && (o["jsonpCallback"] = o["jsonp"]);
                }
                return new Reqwest(o, fn);
            };
            reqwest.ajaxSetup = function(options) {
                options = options || {};
                for (var k in options) {
                    globalSetupOptions[k] = options[k];
                }
            };
            return reqwest;
        });
    }, {
        xhr2: 48
    } ],
    15: [ function(require, module, exports) {
        var createElement = require("./vdom/create-element.js");
        module.exports = createElement;
    }, {
        "./vdom/create-element.js": 27
    } ],
    16: [ function(require, module, exports) {
        var diff = require("./vtree/diff.js");
        module.exports = diff;
    }, {
        "./vtree/diff.js": 47
    } ],
    17: [ function(require, module, exports) {
        var h = require("./virtual-hyperscript/index.js");
        module.exports = h;
    }, {
        "./virtual-hyperscript/index.js": 34
    } ],
    18: [ function(require, module, exports) {
        module.exports = function split(undef) {
            var nativeSplit = String.prototype.split, compliantExecNpcg = /()??/.exec("")[1] === undef, self;
            self = function(str, separator, limit) {
                if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
                    return nativeSplit.call(str, separator, limit);
                }
                var output = [], flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, separator = new RegExp(separator.source, flags + "g"), separator2, match, lastIndex, lastLength;
                str += "";
                if (!compliantExecNpcg) {
                    separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
                }
                limit = limit === undef ? -1 >>> 0 : limit >>> 0;
                while (match = separator.exec(str)) {
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        output.push(str.slice(lastLastIndex, match.index));
                        if (!compliantExecNpcg && match.length > 1) {
                            match[0].replace(separator2, function() {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (arguments[i] === undef) {
                                        match[i] = undef;
                                    }
                                }
                            });
                        }
                        if (match.length > 1 && match.index < str.length) {
                            Array.prototype.push.apply(output, match.slice(1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= limit) {
                            break;
                        }
                    }
                    if (separator.lastIndex === match.index) {
                        separator.lastIndex++;
                    }
                }
                if (lastLastIndex === str.length) {
                    if (lastLength || !separator.test("")) {
                        output.push("");
                    }
                } else {
                    output.push(str.slice(lastLastIndex));
                }
                return output.length > limit ? output.slice(0, limit) : output;
            };
            return self;
        }();
    }, {} ],
    19: [ function(require, module, exports) {
        "use strict";
        var OneVersionConstraint = require("individual/one-version");
        var MY_VERSION = "7";
        OneVersionConstraint("ev-store", MY_VERSION);
        var hashKey = "__EV_STORE_KEY@" + MY_VERSION;
        module.exports = EvStore;
        function EvStore(elem) {
            var hash = elem[hashKey];
            if (!hash) {
                hash = elem[hashKey] = {};
            }
            return hash;
        }
    }, {
        "individual/one-version": 21
    } ],
    20: [ function(require, module, exports) {
        (function(global) {
            "use strict";
            var root = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
            module.exports = Individual;
            function Individual(key, value) {
                if (key in root) {
                    return root[key];
                }
                root[key] = value;
                return value;
            }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    21: [ function(require, module, exports) {
        "use strict";
        var Individual = require("./index.js");
        module.exports = OneVersion;
        function OneVersion(moduleName, version, defaultValue) {
            var key = "__INDIVIDUAL_ONE_VERSION_" + moduleName;
            var enforceKey = key + "_ENFORCE_SINGLETON";
            var versionValue = Individual(enforceKey, version);
            if (versionValue !== version) {
                throw new Error("Can only have one copy of " + moduleName + ".\n" + "You already have version " + versionValue + " installed.\n" + "This means you cannot install version " + version);
            }
            return Individual(key, defaultValue);
        }
    }, {
        "./index.js": 20
    } ],
    22: [ function(require, module, exports) {
        (function(global) {
            var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
            var minDoc = require("min-document");
            if (typeof document !== "undefined") {
                module.exports = document;
            } else {
                var doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                if (!doccy) {
                    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
                }
                module.exports = doccy;
            }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        "min-document": 7
    } ],
    23: [ function(require, module, exports) {
        "use strict";
        module.exports = function isObject(x) {
            return typeof x === "object" && x !== null;
        };
    }, {} ],
    24: [ function(require, module, exports) {
        var nativeIsArray = Array.isArray;
        var toString = Object.prototype.toString;
        module.exports = nativeIsArray || isArray;
        function isArray(obj) {
            return toString.call(obj) === "[object Array]";
        }
    }, {} ],
    25: [ function(require, module, exports) {
        var patch = require("./vdom/patch.js");
        module.exports = patch;
    }, {
        "./vdom/patch.js": 30
    } ],
    26: [ function(require, module, exports) {
        var isObject = require("is-object");
        var isHook = require("../vnode/is-vhook.js");
        module.exports = applyProperties;
        function applyProperties(node, props, previous) {
            for (var propName in props) {
                var propValue = props[propName];
                if (propValue === undefined) {
                    removeProperty(node, propName, propValue, previous);
                } else if (isHook(propValue)) {
                    removeProperty(node, propName, propValue, previous);
                    if (propValue.hook) {
                        propValue.hook(node, propName, previous ? previous[propName] : undefined);
                    }
                } else {
                    if (isObject(propValue)) {
                        patchObject(node, props, previous, propName, propValue);
                    } else {
                        node[propName] = propValue;
                    }
                }
            }
        }
        function removeProperty(node, propName, propValue, previous) {
            if (previous) {
                var previousValue = previous[propName];
                if (!isHook(previousValue)) {
                    if (propName === "attributes") {
                        for (var attrName in previousValue) {
                            node.removeAttribute(attrName);
                        }
                    } else if (propName === "style") {
                        for (var i in previousValue) {
                            node.style[i] = "";
                        }
                    } else if (typeof previousValue === "string") {
                        node[propName] = "";
                    } else {
                        node[propName] = null;
                    }
                } else if (previousValue.unhook) {
                    previousValue.unhook(node, propName, propValue);
                }
            }
        }
        function patchObject(node, props, previous, propName, propValue) {
            var previousValue = previous ? previous[propName] : undefined;
            if (propName === "attributes") {
                for (var attrName in propValue) {
                    var attrValue = propValue[attrName];
                    if (attrValue === undefined) {
                        node.removeAttribute(attrName);
                    } else {
                        node.setAttribute(attrName, attrValue);
                    }
                }
                return;
            }
            if (previousValue && isObject(previousValue) && getPrototype(previousValue) !== getPrototype(propValue)) {
                node[propName] = propValue;
                return;
            }
            if (!isObject(node[propName])) {
                node[propName] = {};
            }
            var replacer = propName === "style" ? "" : undefined;
            for (var k in propValue) {
                var value = propValue[k];
                node[propName][k] = value === undefined ? replacer : value;
            }
        }
        function getPrototype(value) {
            if (Object.getPrototypeOf) {
                return Object.getPrototypeOf(value);
            } else if (value.__proto__) {
                return value.__proto__;
            } else if (value.constructor) {
                return value.constructor.prototype;
            }
        }
    }, {
        "../vnode/is-vhook.js": 38,
        "is-object": 23
    } ],
    27: [ function(require, module, exports) {
        var document = require("global/document");
        var applyProperties = require("./apply-properties");
        var isVNode = require("../vnode/is-vnode.js");
        var isVText = require("../vnode/is-vtext.js");
        var isWidget = require("../vnode/is-widget.js");
        var handleThunk = require("../vnode/handle-thunk.js");
        module.exports = createElement;
        function createElement(vnode, opts) {
            var doc = opts ? opts.document || document : document;
            var warn = opts ? opts.warn : null;
            vnode = handleThunk(vnode).a;
            if (isWidget(vnode)) {
                return vnode.init();
            } else if (isVText(vnode)) {
                return doc.createTextNode(vnode.text);
            } else if (!isVNode(vnode)) {
                if (warn) {
                    warn("Item is not a valid virtual dom node", vnode);
                }
                return null;
            }
            var node = vnode.namespace === null ? doc.createElement(vnode.tagName) : doc.createElementNS(vnode.namespace, vnode.tagName);
            var props = vnode.properties;
            applyProperties(node, props);
            var children = vnode.children;
            for (var i = 0; i < children.length; i++) {
                var childNode = createElement(children[i], opts);
                if (childNode) {
                    node.appendChild(childNode);
                }
            }
            return node;
        }
    }, {
        "../vnode/handle-thunk.js": 36,
        "../vnode/is-vnode.js": 39,
        "../vnode/is-vtext.js": 40,
        "../vnode/is-widget.js": 41,
        "./apply-properties": 26,
        "global/document": 22
    } ],
    28: [ function(require, module, exports) {
        var noChild = {};
        module.exports = domIndex;
        function domIndex(rootNode, tree, indices, nodes) {
            if (!indices || indices.length === 0) {
                return {};
            } else {
                indices.sort(ascending);
                return recurse(rootNode, tree, indices, nodes, 0);
            }
        }
        function recurse(rootNode, tree, indices, nodes, rootIndex) {
            nodes = nodes || {};
            if (rootNode) {
                if (indexInRange(indices, rootIndex, rootIndex)) {
                    nodes[rootIndex] = rootNode;
                }
                var vChildren = tree.children;
                if (vChildren) {
                    var childNodes = rootNode.childNodes;
                    for (var i = 0; i < tree.children.length; i++) {
                        rootIndex += 1;
                        var vChild = vChildren[i] || noChild;
                        var nextIndex = rootIndex + (vChild.count || 0);
                        if (indexInRange(indices, rootIndex, nextIndex)) {
                            recurse(childNodes[i], vChild, indices, nodes, rootIndex);
                        }
                        rootIndex = nextIndex;
                    }
                }
            }
            return nodes;
        }
        function indexInRange(indices, left, right) {
            if (indices.length === 0) {
                return false;
            }
            var minIndex = 0;
            var maxIndex = indices.length - 1;
            var currentIndex;
            var currentItem;
            while (minIndex <= maxIndex) {
                currentIndex = (maxIndex + minIndex) / 2 >> 0;
                currentItem = indices[currentIndex];
                if (minIndex === maxIndex) {
                    return currentItem >= left && currentItem <= right;
                } else if (currentItem < left) {
                    minIndex = currentIndex + 1;
                } else if (currentItem > right) {
                    maxIndex = currentIndex - 1;
                } else {
                    return true;
                }
            }
            return false;
        }
        function ascending(a, b) {
            return a > b ? 1 : -1;
        }
    }, {} ],
    29: [ function(require, module, exports) {
        var applyProperties = require("./apply-properties");
        var isWidget = require("../vnode/is-widget.js");
        var VPatch = require("../vnode/vpatch.js");
        var render = require("./create-element");
        var updateWidget = require("./update-widget");
        module.exports = applyPatch;
        function applyPatch(vpatch, domNode, renderOptions) {
            var type = vpatch.type;
            var vNode = vpatch.vNode;
            var patch = vpatch.patch;
            switch (type) {
              case VPatch.REMOVE:
                return removeNode(domNode, vNode);

              case VPatch.INSERT:
                return insertNode(domNode, patch, renderOptions);

              case VPatch.VTEXT:
                return stringPatch(domNode, vNode, patch, renderOptions);

              case VPatch.WIDGET:
                return widgetPatch(domNode, vNode, patch, renderOptions);

              case VPatch.VNODE:
                return vNodePatch(domNode, vNode, patch, renderOptions);

              case VPatch.ORDER:
                reorderChildren(domNode, patch);
                return domNode;

              case VPatch.PROPS:
                applyProperties(domNode, patch, vNode.properties);
                return domNode;

              case VPatch.THUNK:
                return replaceRoot(domNode, renderOptions.patch(domNode, patch, renderOptions));

              default:
                return domNode;
            }
        }
        function removeNode(domNode, vNode) {
            var parentNode = domNode.parentNode;
            if (parentNode) {
                parentNode.removeChild(domNode);
            }
            destroyWidget(domNode, vNode);
            return null;
        }
        function insertNode(parentNode, vNode, renderOptions) {
            var newNode = render(vNode, renderOptions);
            if (parentNode) {
                parentNode.appendChild(newNode);
            }
            return parentNode;
        }
        function stringPatch(domNode, leftVNode, vText, renderOptions) {
            var newNode;
            if (domNode.nodeType === 3) {
                domNode.replaceData(0, domNode.length, vText.text);
                newNode = domNode;
            } else {
                var parentNode = domNode.parentNode;
                newNode = render(vText, renderOptions);
                if (parentNode && newNode !== domNode) {
                    parentNode.replaceChild(newNode, domNode);
                }
            }
            return newNode;
        }
        function widgetPatch(domNode, leftVNode, widget, renderOptions) {
            var updating = updateWidget(leftVNode, widget);
            var newNode;
            if (updating) {
                newNode = widget.update(leftVNode, domNode) || domNode;
            } else {
                newNode = render(widget, renderOptions);
            }
            var parentNode = domNode.parentNode;
            if (parentNode && newNode !== domNode) {
                parentNode.replaceChild(newNode, domNode);
            }
            if (!updating) {
                destroyWidget(domNode, leftVNode);
            }
            return newNode;
        }
        function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
            var parentNode = domNode.parentNode;
            var newNode = render(vNode, renderOptions);
            if (parentNode && newNode !== domNode) {
                parentNode.replaceChild(newNode, domNode);
            }
            return newNode;
        }
        function destroyWidget(domNode, w) {
            if (typeof w.destroy === "function" && isWidget(w)) {
                w.destroy(domNode);
            }
        }
        function reorderChildren(domNode, moves) {
            var childNodes = domNode.childNodes;
            var keyMap = {};
            var node;
            var remove;
            var insert;
            for (var i = 0; i < moves.removes.length; i++) {
                remove = moves.removes[i];
                node = childNodes[remove.from];
                if (remove.key) {
                    keyMap[remove.key] = node;
                }
                domNode.removeChild(node);
            }
            var length = childNodes.length;
            for (var j = 0; j < moves.inserts.length; j++) {
                insert = moves.inserts[j];
                node = keyMap[insert.key];
                domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
            }
        }
        function replaceRoot(oldRoot, newRoot) {
            if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
                oldRoot.parentNode.replaceChild(newRoot, oldRoot);
            }
            return newRoot;
        }
    }, {
        "../vnode/is-widget.js": 41,
        "../vnode/vpatch.js": 44,
        "./apply-properties": 26,
        "./create-element": 27,
        "./update-widget": 31
    } ],
    30: [ function(require, module, exports) {
        var document = require("global/document");
        var isArray = require("x-is-array");
        var domIndex = require("./dom-index");
        var patchOp = require("./patch-op");
        module.exports = patch;
        function patch(rootNode, patches) {
            return patchRecursive(rootNode, patches);
        }
        function patchRecursive(rootNode, patches, renderOptions) {
            var indices = patchIndices(patches);
            if (indices.length === 0) {
                return rootNode;
            }
            var index = domIndex(rootNode, patches.a, indices);
            var ownerDocument = rootNode.ownerDocument;
            if (!renderOptions) {
                renderOptions = {
                    patch: patchRecursive
                };
                if (ownerDocument !== document) {
                    renderOptions.document = ownerDocument;
                }
            }
            for (var i = 0; i < indices.length; i++) {
                var nodeIndex = indices[i];
                rootNode = applyPatch(rootNode, index[nodeIndex], patches[nodeIndex], renderOptions);
            }
            return rootNode;
        }
        function applyPatch(rootNode, domNode, patchList, renderOptions) {
            if (!domNode) {
                return rootNode;
            }
            var newNode;
            if (isArray(patchList)) {
                for (var i = 0; i < patchList.length; i++) {
                    newNode = patchOp(patchList[i], domNode, renderOptions);
                    if (domNode === rootNode) {
                        rootNode = newNode;
                    }
                }
            } else {
                newNode = patchOp(patchList, domNode, renderOptions);
                if (domNode === rootNode) {
                    rootNode = newNode;
                }
            }
            return rootNode;
        }
        function patchIndices(patches) {
            var indices = [];
            for (var key in patches) {
                if (key !== "a") {
                    indices.push(Number(key));
                }
            }
            return indices;
        }
    }, {
        "./dom-index": 28,
        "./patch-op": 29,
        "global/document": 22,
        "x-is-array": 24
    } ],
    31: [ function(require, module, exports) {
        var isWidget = require("../vnode/is-widget.js");
        module.exports = updateWidget;
        function updateWidget(a, b) {
            if (isWidget(a) && isWidget(b)) {
                if ("name" in a && "name" in b) {
                    return a.id === b.id;
                } else {
                    return a.init === b.init;
                }
            }
            return false;
        }
    }, {
        "../vnode/is-widget.js": 41
    } ],
    32: [ function(require, module, exports) {
        "use strict";
        var EvStore = require("ev-store");
        module.exports = EvHook;
        function EvHook(value) {
            if (!(this instanceof EvHook)) {
                return new EvHook(value);
            }
            this.value = value;
        }
        EvHook.prototype.hook = function(node, propertyName) {
            var es = EvStore(node);
            var propName = propertyName.substr(3);
            es[propName] = this.value;
        };
        EvHook.prototype.unhook = function(node, propertyName) {
            var es = EvStore(node);
            var propName = propertyName.substr(3);
            es[propName] = undefined;
        };
    }, {
        "ev-store": 19
    } ],
    33: [ function(require, module, exports) {
        "use strict";
        module.exports = SoftSetHook;
        function SoftSetHook(value) {
            if (!(this instanceof SoftSetHook)) {
                return new SoftSetHook(value);
            }
            this.value = value;
        }
        SoftSetHook.prototype.hook = function(node, propertyName) {
            if (node[propertyName] !== this.value) {
                node[propertyName] = this.value;
            }
        };
    }, {} ],
    34: [ function(require, module, exports) {
        "use strict";
        var isArray = require("x-is-array");
        var VNode = require("../vnode/vnode.js");
        var VText = require("../vnode/vtext.js");
        var isVNode = require("../vnode/is-vnode");
        var isVText = require("../vnode/is-vtext");
        var isWidget = require("../vnode/is-widget");
        var isHook = require("../vnode/is-vhook");
        var isVThunk = require("../vnode/is-thunk");
        var parseTag = require("./parse-tag.js");
        var softSetHook = require("./hooks/soft-set-hook.js");
        var evHook = require("./hooks/ev-hook.js");
        module.exports = h;
        function h(tagName, properties, children) {
            var childNodes = [];
            var tag, props, key, namespace;
            if (!children && isChildren(properties)) {
                children = properties;
                props = {};
            }
            props = props || properties || {};
            tag = parseTag(tagName, props);
            if (props.hasOwnProperty("key")) {
                key = props.key;
                props.key = undefined;
            }
            if (props.hasOwnProperty("namespace")) {
                namespace = props.namespace;
                props.namespace = undefined;
            }
            if (tag === "INPUT" && !namespace && props.hasOwnProperty("value") && props.value !== undefined && !isHook(props.value)) {
                props.value = softSetHook(props.value);
            }
            transformProperties(props);
            if (children !== undefined && children !== null) {
                addChild(children, childNodes, tag, props);
            }
            return new VNode(tag, props, childNodes, key, namespace);
        }
        function addChild(c, childNodes, tag, props) {
            if (typeof c === "string") {
                childNodes.push(new VText(c));
            } else if (isChild(c)) {
                childNodes.push(c);
            } else if (isArray(c)) {
                for (var i = 0; i < c.length; i++) {
                    addChild(c[i], childNodes, tag, props);
                }
            } else if (c === null || c === undefined) {
                return;
            } else {
                throw UnexpectedVirtualElement({
                    foreignObject: c,
                    parentVnode: {
                        tagName: tag,
                        properties: props
                    }
                });
            }
        }
        function transformProperties(props) {
            for (var propName in props) {
                if (props.hasOwnProperty(propName)) {
                    var value = props[propName];
                    if (isHook(value)) {
                        continue;
                    }
                    if (propName.substr(0, 3) === "ev-") {
                        props[propName] = evHook(value);
                    }
                }
            }
        }
        function isChild(x) {
            return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
        }
        function isChildren(x) {
            return typeof x === "string" || isArray(x) || isChild(x);
        }
        function UnexpectedVirtualElement(data) {
            var err = new Error();
            err.type = "virtual-hyperscript.unexpected.virtual-element";
            err.message = "Unexpected virtual child passed to h().\n" + "Expected a VNode / Vthunk / VWidget / string but:\n" + "got:\n" + errorString(data.foreignObject) + ".\n" + "The parent vnode is:\n" + errorString(data.parentVnode);
            "\n" + "Suggested fix: change your `h(..., [ ... ])` callsite.";
            err.foreignObject = data.foreignObject;
            err.parentVnode = data.parentVnode;
            return err;
        }
        function errorString(obj) {
            try {
                return JSON.stringify(obj, null, "    ");
            } catch (e) {
                return String(obj);
            }
        }
    }, {
        "../vnode/is-thunk": 37,
        "../vnode/is-vhook": 38,
        "../vnode/is-vnode": 39,
        "../vnode/is-vtext": 40,
        "../vnode/is-widget": 41,
        "../vnode/vnode.js": 43,
        "../vnode/vtext.js": 45,
        "./hooks/ev-hook.js": 32,
        "./hooks/soft-set-hook.js": 33,
        "./parse-tag.js": 35,
        "x-is-array": 24
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        var split = require("browser-split");
        var classIdSplit = /([\.#]?[a-zA-Z0-9_:-]+)/;
        var notClassId = /^\.|#/;
        module.exports = parseTag;
        function parseTag(tag, props) {
            if (!tag) {
                return "DIV";
            }
            var noId = !props.hasOwnProperty("id");
            var tagParts = split(tag, classIdSplit);
            var tagName = null;
            if (notClassId.test(tagParts[1])) {
                tagName = "DIV";
            }
            var classes, part, type, i;
            for (i = 0; i < tagParts.length; i++) {
                part = tagParts[i];
                if (!part) {
                    continue;
                }
                type = part.charAt(0);
                if (!tagName) {
                    tagName = part;
                } else if (type === ".") {
                    classes = classes || [];
                    classes.push(part.substring(1, part.length));
                } else if (type === "#" && noId) {
                    props.id = part.substring(1, part.length);
                }
            }
            if (classes) {
                if (props.className) {
                    classes.push(props.className);
                }
                props.className = classes.join(" ");
            }
            return props.namespace ? tagName : tagName.toUpperCase();
        }
    }, {
        "browser-split": 18
    } ],
    36: [ function(require, module, exports) {
        var isVNode = require("./is-vnode");
        var isVText = require("./is-vtext");
        var isWidget = require("./is-widget");
        var isThunk = require("./is-thunk");
        module.exports = handleThunk;
        function handleThunk(a, b) {
            var renderedA = a;
            var renderedB = b;
            if (isThunk(b)) {
                renderedB = renderThunk(b, a);
            }
            if (isThunk(a)) {
                renderedA = renderThunk(a, null);
            }
            return {
                a: renderedA,
                b: renderedB
            };
        }
        function renderThunk(thunk, previous) {
            var renderedThunk = thunk.vnode;
            if (!renderedThunk) {
                renderedThunk = thunk.vnode = thunk.render(previous);
            }
            if (!(isVNode(renderedThunk) || isVText(renderedThunk) || isWidget(renderedThunk))) {
                throw new Error("thunk did not return a valid node");
            }
            return renderedThunk;
        }
    }, {
        "./is-thunk": 37,
        "./is-vnode": 39,
        "./is-vtext": 40,
        "./is-widget": 41
    } ],
    37: [ function(require, module, exports) {
        module.exports = isThunk;
        function isThunk(t) {
            return t && t.type === "Thunk";
        }
    }, {} ],
    38: [ function(require, module, exports) {
        module.exports = isHook;
        function isHook(hook) {
            return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
        }
    }, {} ],
    39: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = isVirtualNode;
        function isVirtualNode(x) {
            return x && x.type === "VirtualNode" && x.version === version;
        }
    }, {
        "./version": 42
    } ],
    40: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = isVirtualText;
        function isVirtualText(x) {
            return x && x.type === "VirtualText" && x.version === version;
        }
    }, {
        "./version": 42
    } ],
    41: [ function(require, module, exports) {
        module.exports = isWidget;
        function isWidget(w) {
            return w && w.type === "Widget";
        }
    }, {} ],
    42: [ function(require, module, exports) {
        module.exports = "2";
    }, {} ],
    43: [ function(require, module, exports) {
        var version = require("./version");
        var isVNode = require("./is-vnode");
        var isWidget = require("./is-widget");
        var isThunk = require("./is-thunk");
        var isVHook = require("./is-vhook");
        module.exports = VirtualNode;
        var noProperties = {};
        var noChildren = [];
        function VirtualNode(tagName, properties, children, key, namespace) {
            this.tagName = tagName;
            this.properties = properties || noProperties;
            this.children = children || noChildren;
            this.key = key != null ? String(key) : undefined;
            this.namespace = typeof namespace === "string" ? namespace : null;
            var count = children && children.length || 0;
            var descendants = 0;
            var hasWidgets = false;
            var hasThunks = false;
            var descendantHooks = false;
            var hooks;
            for (var propName in properties) {
                if (properties.hasOwnProperty(propName)) {
                    var property = properties[propName];
                    if (isVHook(property) && property.unhook) {
                        if (!hooks) {
                            hooks = {};
                        }
                        hooks[propName] = property;
                    }
                }
            }
            for (var i = 0; i < count; i++) {
                var child = children[i];
                if (isVNode(child)) {
                    descendants += child.count || 0;
                    if (!hasWidgets && child.hasWidgets) {
                        hasWidgets = true;
                    }
                    if (!hasThunks && child.hasThunks) {
                        hasThunks = true;
                    }
                    if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                        descendantHooks = true;
                    }
                } else if (!hasWidgets && isWidget(child)) {
                    if (typeof child.destroy === "function") {
                        hasWidgets = true;
                    }
                } else if (!hasThunks && isThunk(child)) {
                    hasThunks = true;
                }
            }
            this.count = count + descendants;
            this.hasWidgets = hasWidgets;
            this.hasThunks = hasThunks;
            this.hooks = hooks;
            this.descendantHooks = descendantHooks;
        }
        VirtualNode.prototype.version = version;
        VirtualNode.prototype.type = "VirtualNode";
    }, {
        "./is-thunk": 37,
        "./is-vhook": 38,
        "./is-vnode": 39,
        "./is-widget": 41,
        "./version": 42
    } ],
    44: [ function(require, module, exports) {
        var version = require("./version");
        VirtualPatch.NONE = 0;
        VirtualPatch.VTEXT = 1;
        VirtualPatch.VNODE = 2;
        VirtualPatch.WIDGET = 3;
        VirtualPatch.PROPS = 4;
        VirtualPatch.ORDER = 5;
        VirtualPatch.INSERT = 6;
        VirtualPatch.REMOVE = 7;
        VirtualPatch.THUNK = 8;
        module.exports = VirtualPatch;
        function VirtualPatch(type, vNode, patch) {
            this.type = Number(type);
            this.vNode = vNode;
            this.patch = patch;
        }
        VirtualPatch.prototype.version = version;
        VirtualPatch.prototype.type = "VirtualPatch";
    }, {
        "./version": 42
    } ],
    45: [ function(require, module, exports) {
        var version = require("./version");
        module.exports = VirtualText;
        function VirtualText(text) {
            this.text = String(text);
        }
        VirtualText.prototype.version = version;
        VirtualText.prototype.type = "VirtualText";
    }, {
        "./version": 42
    } ],
    46: [ function(require, module, exports) {
        var isObject = require("is-object");
        var isHook = require("../vnode/is-vhook");
        module.exports = diffProps;
        function diffProps(a, b) {
            var diff;
            for (var aKey in a) {
                if (!(aKey in b)) {
                    diff = diff || {};
                    diff[aKey] = undefined;
                }
                var aValue = a[aKey];
                var bValue = b[aKey];
                if (aValue === bValue) {
                    continue;
                } else if (isObject(aValue) && isObject(bValue)) {
                    if (getPrototype(bValue) !== getPrototype(aValue)) {
                        diff = diff || {};
                        diff[aKey] = bValue;
                    } else if (isHook(bValue)) {
                        diff = diff || {};
                        diff[aKey] = bValue;
                    } else {
                        var objectDiff = diffProps(aValue, bValue);
                        if (objectDiff) {
                            diff = diff || {};
                            diff[aKey] = objectDiff;
                        }
                    }
                } else {
                    diff = diff || {};
                    diff[aKey] = bValue;
                }
            }
            for (var bKey in b) {
                if (!(bKey in a)) {
                    diff = diff || {};
                    diff[bKey] = b[bKey];
                }
            }
            return diff;
        }
        function getPrototype(value) {
            if (Object.getPrototypeOf) {
                return Object.getPrototypeOf(value);
            } else if (value.__proto__) {
                return value.__proto__;
            } else if (value.constructor) {
                return value.constructor.prototype;
            }
        }
    }, {
        "../vnode/is-vhook": 38,
        "is-object": 23
    } ],
    47: [ function(require, module, exports) {
        var isArray = require("x-is-array");
        var VPatch = require("../vnode/vpatch");
        var isVNode = require("../vnode/is-vnode");
        var isVText = require("../vnode/is-vtext");
        var isWidget = require("../vnode/is-widget");
        var isThunk = require("../vnode/is-thunk");
        var handleThunk = require("../vnode/handle-thunk");
        var diffProps = require("./diff-props");
        module.exports = diff;
        function diff(a, b) {
            var patch = {
                a: a
            };
            walk(a, b, patch, 0);
            return patch;
        }
        function walk(a, b, patch, index) {
            if (a === b) {
                return;
            }
            var apply = patch[index];
            var applyClear = false;
            if (isThunk(a) || isThunk(b)) {
                thunks(a, b, patch, index);
            } else if (b == null) {
                if (!isWidget(a)) {
                    clearState(a, patch, index);
                    apply = patch[index];
                }
                apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
            } else if (isVNode(b)) {
                if (isVNode(a)) {
                    if (a.tagName === b.tagName && a.namespace === b.namespace && a.key === b.key) {
                        var propsPatch = diffProps(a.properties, b.properties);
                        if (propsPatch) {
                            apply = appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));
                        }
                        apply = diffChildren(a, b, patch, apply, index);
                    } else {
                        apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                        applyClear = true;
                    }
                } else {
                    apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                    applyClear = true;
                }
            } else if (isVText(b)) {
                if (!isVText(a)) {
                    apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                    applyClear = true;
                } else if (a.text !== b.text) {
                    apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                }
            } else if (isWidget(b)) {
                if (!isWidget(a)) {
                    applyClear = true;
                }
                apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
            }
            if (apply) {
                patch[index] = apply;
            }
            if (applyClear) {
                clearState(a, patch, index);
            }
        }
        function diffChildren(a, b, patch, apply, index) {
            var aChildren = a.children;
            var orderedSet = reorder(aChildren, b.children);
            var bChildren = orderedSet.children;
            var aLen = aChildren.length;
            var bLen = bChildren.length;
            var len = aLen > bLen ? aLen : bLen;
            for (var i = 0; i < len; i++) {
                var leftNode = aChildren[i];
                var rightNode = bChildren[i];
                index += 1;
                if (!leftNode) {
                    if (rightNode) {
                        apply = appendPatch(apply, new VPatch(VPatch.INSERT, null, rightNode));
                    }
                } else {
                    walk(leftNode, rightNode, patch, index);
                }
                if (isVNode(leftNode) && leftNode.count) {
                    index += leftNode.count;
                }
            }
            if (orderedSet.moves) {
                apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));
            }
            return apply;
        }
        function clearState(vNode, patch, index) {
            unhook(vNode, patch, index);
            destroyWidgets(vNode, patch, index);
        }
        function destroyWidgets(vNode, patch, index) {
            if (isWidget(vNode)) {
                if (typeof vNode.destroy === "function") {
                    patch[index] = appendPatch(patch[index], new VPatch(VPatch.REMOVE, vNode, null));
                }
            } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
                var children = vNode.children;
                var len = children.length;
                for (var i = 0; i < len; i++) {
                    var child = children[i];
                    index += 1;
                    destroyWidgets(child, patch, index);
                    if (isVNode(child) && child.count) {
                        index += child.count;
                    }
                }
            } else if (isThunk(vNode)) {
                thunks(vNode, null, patch, index);
            }
        }
        function thunks(a, b, patch, index) {
            var nodes = handleThunk(a, b);
            var thunkPatch = diff(nodes.a, nodes.b);
            if (hasPatches(thunkPatch)) {
                patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
            }
        }
        function hasPatches(patch) {
            for (var index in patch) {
                if (index !== "a") {
                    return true;
                }
            }
            return false;
        }
        function unhook(vNode, patch, index) {
            if (isVNode(vNode)) {
                if (vNode.hooks) {
                    patch[index] = appendPatch(patch[index], new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));
                }
                if (vNode.descendantHooks || vNode.hasThunks) {
                    var children = vNode.children;
                    var len = children.length;
                    for (var i = 0; i < len; i++) {
                        var child = children[i];
                        index += 1;
                        unhook(child, patch, index);
                        if (isVNode(child) && child.count) {
                            index += child.count;
                        }
                    }
                }
            } else if (isThunk(vNode)) {
                thunks(vNode, null, patch, index);
            }
        }
        function undefinedKeys(obj) {
            var result = {};
            for (var key in obj) {
                result[key] = undefined;
            }
            return result;
        }
        function reorder(aChildren, bChildren) {
            var bChildIndex = keyIndex(bChildren);
            var bKeys = bChildIndex.keys;
            var bFree = bChildIndex.free;
            if (bFree.length === bChildren.length) {
                return {
                    children: bChildren,
                    moves: null
                };
            }
            var aChildIndex = keyIndex(aChildren);
            var aKeys = aChildIndex.keys;
            var aFree = aChildIndex.free;
            if (aFree.length === aChildren.length) {
                return {
                    children: bChildren,
                    moves: null
                };
            }
            var newChildren = [];
            var freeIndex = 0;
            var freeCount = bFree.length;
            var deletedItems = 0;
            for (var i = 0; i < aChildren.length; i++) {
                var aItem = aChildren[i];
                var itemIndex;
                if (aItem.key) {
                    if (bKeys.hasOwnProperty(aItem.key)) {
                        itemIndex = bKeys[aItem.key];
                        newChildren.push(bChildren[itemIndex]);
                    } else {
                        itemIndex = i - deletedItems++;
                        newChildren.push(null);
                    }
                } else {
                    if (freeIndex < freeCount) {
                        itemIndex = bFree[freeIndex++];
                        newChildren.push(bChildren[itemIndex]);
                    } else {
                        itemIndex = i - deletedItems++;
                        newChildren.push(null);
                    }
                }
            }
            var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex];
            for (var j = 0; j < bChildren.length; j++) {
                var newItem = bChildren[j];
                if (newItem.key) {
                    if (!aKeys.hasOwnProperty(newItem.key)) {
                        newChildren.push(newItem);
                    }
                } else if (j >= lastFreeIndex) {
                    newChildren.push(newItem);
                }
            }
            var simulate = newChildren.slice();
            var simulateIndex = 0;
            var removes = [];
            var inserts = [];
            var simulateItem;
            for (var k = 0; k < bChildren.length; ) {
                var wantedItem = bChildren[k];
                simulateItem = simulate[simulateIndex];
                while (simulateItem === null && simulate.length) {
                    removes.push(remove(simulate, simulateIndex, null));
                    simulateItem = simulate[simulateIndex];
                }
                if (!simulateItem || simulateItem.key !== wantedItem.key) {
                    if (wantedItem.key) {
                        if (simulateItem && simulateItem.key) {
                            if (bKeys[simulateItem.key] !== k + 1) {
                                removes.push(remove(simulate, simulateIndex, simulateItem.key));
                                simulateItem = simulate[simulateIndex];
                                if (!simulateItem || simulateItem.key !== wantedItem.key) {
                                    inserts.push({
                                        key: wantedItem.key,
                                        to: k
                                    });
                                } else {
                                    simulateIndex++;
                                }
                            } else {
                                inserts.push({
                                    key: wantedItem.key,
                                    to: k
                                });
                            }
                        } else {
                            inserts.push({
                                key: wantedItem.key,
                                to: k
                            });
                        }
                        k++;
                    } else if (simulateItem && simulateItem.key) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key));
                    }
                } else {
                    simulateIndex++;
                    k++;
                }
            }
            while (simulateIndex < simulate.length) {
                simulateItem = simulate[simulateIndex];
                removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key));
            }
            if (removes.length === deletedItems && !inserts.length) {
                return {
                    children: newChildren,
                    moves: null
                };
            }
            return {
                children: newChildren,
                moves: {
                    removes: removes,
                    inserts: inserts
                }
            };
        }
        function remove(arr, index, key) {
            arr.splice(index, 1);
            return {
                from: index,
                key: key
            };
        }
        function keyIndex(children) {
            var keys = {};
            var free = [];
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                if (child.key) {
                    keys[child.key] = i;
                } else {
                    free.push(i);
                }
            }
            return {
                keys: keys,
                free: free
            };
        }
        function appendPatch(apply, patch) {
            if (apply) {
                if (isArray(apply)) {
                    apply.push(patch);
                } else {
                    apply = [ apply, patch ];
                }
                return apply;
            } else {
                return patch;
            }
        }
    }, {
        "../vnode/handle-thunk": 36,
        "../vnode/is-thunk": 37,
        "../vnode/is-vnode": 39,
        "../vnode/is-vtext": 40,
        "../vnode/is-widget": 41,
        "../vnode/vpatch": 44,
        "./diff-props": 46,
        "x-is-array": 24
    } ],
    48: [ function(require, module, exports) {
        module.exports = XMLHttpRequest;
    }, {} ],
    49: [ function(require, module, exports) {
        function Content(page) {
            try {
                var originalTitle = page.title;
                var originalText = page.text;
                var originalReferences = page.references;
            } catch (e) {}
            return {
                page: page || this,
                id: -1,
                title: "",
                text: "",
                references: [],
                category: [],
                contentType: "Content",
                listItemType: "",
                timestamp: null,
                originalTitle: originalTitle || "",
                originalText: originalText || "",
                originalReferences: originalReferences || [],
                set: function(data) {
                    var name;
                    data = data || page || this.page;
                    for (name in data) {
                        if (this.hasOwnProperty(name)) {
                            this[name] = data[name];
                        }
                    }
                    return this;
                },
                reset: function() {
                    var name;
                    for (name in page) {
                        if (this.hasOwnProperty(name)) {
                            this[name] = null;
                        }
                    }
                    page = null;
                }
            };
        }
        module.exports = Content;
    }, {} ]
}, {}, [ 3 ]);